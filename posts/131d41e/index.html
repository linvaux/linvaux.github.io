<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>深入理解Java中的序列化和反序列化 | 写bug的大耳朵图图</title>
  <meta name="description" content="1. 技术背景​	互联网的迅猛发展受益于网络通信技术的成熟和稳定。网络通信协议是机器双方共同约定的协议。在应用层看到的是结构体、对象，但是在网络协议里，机器之间传输的都是二进制流。网络编程中，需要定义应用层协议。最原始的应用层协议是字节数组，在 Java 语言里以 byte［］体现，在C语言里以 char［］体现。不管是 Java 语言还是 C 语言，开发人员都需要知道字节数组里每个字节的含义才能">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Java中的序列化和反序列化">
<meta property="og:url" content="https://linvaux.github.io/posts/131d41e/index.html">
<meta property="og:site_name" content="写bug的大耳朵图图">
<meta property="og:description" content="1. 技术背景​	互联网的迅猛发展受益于网络通信技术的成熟和稳定。网络通信协议是机器双方共同约定的协议。在应用层看到的是结构体、对象，但是在网络协议里，机器之间传输的都是二进制流。网络编程中，需要定义应用层协议。最原始的应用层协议是字节数组，在 Java 语言里以 byte［］体现，在C语言里以 char［］体现。不管是 Java 语言还是 C 语言，开发人员都需要知道字节数组里每个字节的含义才能">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://linvaux.github.io/images/1gTCneXGk1gBEGnis6FRtz5M.jpg">
<meta property="og:image" content="https://linvaux.github.io/images/hELYzbRMotrUMeYVsRa5vr9i.jpg">
<meta property="og:image" content="https://linvaux.github.io/images/Y1ECwL99NPQ9CM8ivPzgBVHo.jpg">
<meta property="og:image" content="https://linvaux.github.io/images/2VNC72QBgSZyBYvENcVCm2bq.jpg">
<meta property="og:image" content="https://linvaux.github.io/images/PyvHnp3XR3K5NXyT1MK4cr6D.png">
<meta property="og:image" content="https://linvaux.github.io/images/ZJ9fqjsXpnfXGsH7i5P1iYw5.png">
<meta property="og:image" content="https://linvaux.github.io/images/qpTtpLL9DYbfFPFkSN5onUmd.jpg">
<meta property="og:image" content="https://linvaux.github.io/images/eoWEk2V81BTRTxPzzit3BcEw.jpg">
<meta property="og:image" content="https://linvaux.github.io/images/D4zoDNdPDaHmkVdGgKk2J9Uh.jpg">
<meta property="og:image" content="https://linvaux.github.io/images/4Qb15TfgRvpQVzKXeovi4x6n.jpg">
<meta property="og:image" content="https://linvaux.github.io/images/GT5b8caHzuYKzwVp3UELmE1J.jpg">
<meta property="og:image" content="https://linvaux.github.io/images/nnhkeZR9xVtXQ4HnDPLJKW8n.jpg">
<meta property="og:image" content="https://linvaux.github.io/images/SvQVRsCFmpzJeBTjx6ELCScy.jpg">
<meta property="og:image" content="https://linvaux.github.io/images/DPzF8Spr8Y1DeJAGaAyFxfgd.jpg">
<meta property="og:image" content="https://linvaux.github.io/images/rGryaNJzbY1qfN2fLNPeMoU9.jpg">
<meta property="og:image" content="https://linvaux.github.io/images/zit43xT8vvpH2TSrFCk4WaJE.jpg">
<meta property="og:image" content="https://linvaux.github.io/images/pHupFXsgkCUmToA3Xn1ZqSaH.jpg">
<meta property="og:image" content="https://linvaux.github.io/images/Jaou5jiRioCwnQy7rMkzizdY.jpg">
<meta property="og:image" content="https://linvaux.github.io/images/xk3DXSuHLEZe6h1gWBdsZTao.jpg">
<meta property="og:image" content="https://linvaux.github.io/images/Eqhuh4qAQWUGvqxbxvSAN7um.jpg">
<meta property="og:image" content="https://linvaux.github.io/images/7J2xJTK42JMS8aEvQswTH1Ta.jpg">
<meta property="og:image" content="https://linvaux.github.io/images/fLhYY1UfUXYaYS8Sib2GqewM.jpg">
<meta property="og:image" content="https://linvaux.github.io/images/T499tgA9fZSSP5p9PPyYbTxV.jpg">
<meta property="og:image" content="https://linvaux.github.io/images/6LkQhoJM6ZDiYWqgZ2Ugg8Yp.jpg">
<meta property="og:image" content="https://linvaux.github.io/images/eKGGeVsFyVRtbWwq9U8874nm.jpg">
<meta property="article:published_time" content="2023-07-26T14:14:54.000Z">
<meta property="article:modified_time" content="2024-09-21T00:59:08.945Z">
<meta property="article:author" content="Wick">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://linvaux.github.io/images/1gTCneXGk1gBEGnis6FRtz5M.jpg">
  <!-- Canonical links -->
  <link rel="canonical" href="https://linvaux.github.io/posts/131d41e/index.html">
  
    <link rel="alternate" href="/atom.xml" title="写bug的大耳朵图图" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
    <link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet">
  
  
<meta name="generator" content="Hexo 7.3.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://gitee.com/linvaux" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar1.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">大耳朵图图</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Java开发/高级测试开发</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> 中国·南京</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form" method="GET" action="https://www.baidu.com/s?">
	<div class="input-group">
    	<input name="wd" type="text" class="form-control search-form-input" placeholder="搜索" />
	    <span class="input-group-btn">
	    	<button type="submit" class=" btn btn-flat search-form-submit"><i class="icon icon-search"></i></button>
	    </span>
    </div>
</form>

</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <h5>原博客地址：<a href = "https://geeknote.net/wick">https://geeknote.net/wick</a></h5>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/Docker/" style="font-size: 13.6px;">Docker</a> <a href="/tags/EasyExcel/" style="font-size: 13.4px;">EasyExcel</a> <a href="/tags/IDEA/" style="font-size: 13.4px;">IDEA</a> <a href="/tags/Java/" style="font-size: 14px;">Java</a> <a href="/tags/Jenkins/" style="font-size: 13px;">Jenkins</a> <a href="/tags/Jmeter%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91/" style="font-size: 13px;">Jmeter扩展开发</a> <a href="/tags/Jmeter%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/" style="font-size: 13.8px;">Jmeter源码系列</a> <a href="/tags/LogStash/" style="font-size: 13px;">LogStash</a> <a href="/tags/Mac/" style="font-size: 13px;">Mac</a> <a href="/tags/Pytest/" style="font-size: 13px;">Pytest</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/" style="font-size: 13.2px;">代码覆盖率</a> <a href="/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" style="font-size: 13px;">自动化测试</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 13px;">随笔</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">八月 2024</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">七月 2024</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">五月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">十月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">八月 2023</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">七月 2023</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">六月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">四月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">三月 2023</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/posts/a7b6bddb/" class="title">Github Pages使用Hexo搭建个人博客</a>
              </p>
              <p class="item-date">
                <time datetime="2024-08-24T13:59:39.000Z" itemprop="datePublished">2024-08-24</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/posts/fbd833ae/" class="title">Jmeter源码系列(5)-JmeterEngine-Jmeter的执行引擎</a>
              </p>
              <p class="item-date">
                <time datetime="2024-08-04T04:41:26.000Z" itemprop="datePublished">2024-08-04</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/posts/75270eba/" class="title">【Jmeter扩展开发】自定义Java请求</a>
              </p>
              <p class="item-date">
                <time datetime="2024-08-03T01:36:37.000Z" itemprop="datePublished">2024-08-03</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/posts/67f865da/" class="title">IDEA插件整理(二)</a>
              </p>
              <p class="item-date">
                <time datetime="2024-07-31T14:02:28.000Z" itemprop="datePublished">2024-07-31</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/posts/7d6bf7a5/" class="title">Jmeter源码系列(4) - Jmeter 类详解-runNonGui()，无界面模式下的脚本执行过程</a>
              </p>
              <p class="item-date">
                <time datetime="2024-07-28T14:03:54.000Z" itemprop="datePublished">2024-07-28</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-深入理解Java中的序列化和反序列化" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      深入理解Java中的序列化和反序列化
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/posts/131d41e/" class="article-date">
	  <time datetime="2023-07-26T14:14:54.000Z" itemprop="datePublished">2023-07-26</time>
	</a>
</span>
        
        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/Java/" rel="tag">Java</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/posts/131d41e/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 11.2k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 43(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h2 id="1-技术背景"><a href="#1-技术背景" class="headerlink" title="1. 技术背景"></a>1. 技术背景</h2><p>​	互联网的迅猛发展受益于网络通信技术的成熟和稳定。网络通信协议是机器双方共同约定的协议。在应用层看到的是结构体、对象，但是在网络协议里，机器之间传输的都是二进制流。网络编程中，需要定义应用层协议。最原始的应用层协议是字节数组，在 Java 语言里以 byte［］体现，在C语言里以 char［］体现。不管是 Java 语言还是 C 语言，开发人员都需要知道字节数组里每个字节的含义才能保证数据写入和读取的正确性。这对开发人员来说，是非常严苛且低效的。<br>如何将程序中的结构体、对象等结构化内存对象转换为扁平的二进制流？如何将二进制流还原为结构化内存对象？为了解决这些问题，序列化&#x2F;反序列化技术应运而生。</p>
<p><img src="/../images/1gTCneXGk1gBEGnis6FRtz5M.jpg" alt="image.jpg"></p>
<p>核心意义：对象状态的保存(序列化)和重建(反序列化)</p>
<h2 id="2-序列化协议的特性"><a href="#2-序列化协议的特性" class="headerlink" title="2. 序列化协议的特性"></a>2. 序列化协议的特性</h2><ol>
<li><p>通用性</p>
<ul>
<li>技术层面，序列化协议是否支持跨平台、跨语言。如果不支持，在技术层面上的通用性就大大降低了。</li>
<li>流行程度，社区是否成熟，是否能及时跟进Issue并解决Bug。</li>
</ul>
</li>
<li><p>鲁棒性</p>
<ul>
<li>成熟度不够，一个协议从制定到实施，到最后成熟往往是一个漫长的阶段。协议的强健性依赖于大量而全面的测试，对于致力于提供高质量服务的系统，采用处于测试阶段的序列化协议会带来很高的风险。</li>
<li>语言&#x2F;平台的不公平性。为了支持跨语言、跨平台的功能，序列化协议的制定者需要做大量的工作；但是，当所支持的语言或者平台之间存在难以调和的特性的时候，协议制定者需要做一个艰难的决定–支持更多人使用的语言&#x2F;平台，亦或支持更多的语言&#x2F;平台而放弃某个特性。当协议的制定者决定为某种语言或平台提供更多支持的时候，对于使用者而言，协议的强健性就被牺牲了。</li>
</ul>
</li>
<li><p>可扩展性&#x2F;兼容性</p>
<ul>
<li>扩展性表现为随着业务需求变化需要增减字段。字段变化的过程中，不会对现有系统的数据存储、数据访问造成影响，具有向后兼容性。扩展性也是序列化&#x2F;反序列化技术的核心指标之一。</li>
</ul>
</li>
<li><p>性能</p>
<ul>
<li>时间开销，复杂的序列化协议会导致较长的解析时间，这可能会使得序列化和反序列化阶段成为整个系统的瓶颈。</li>
<li>空间开销，如果序列化过程引入的额外开销过高，可能会导致过大的网络，磁盘等各方面的压力。对于海量分布式存储系统，数据量往往以TB为单位，巨大的的额外空间开销意味着高昂的成本。</li>
</ul>
</li>
<li><p>易用性</p>
<ul>
<li>易用性决定了开发者是不是需要花很多时间去学习，门槛是不是很高，接口是不是容易理解和使用。</li>
</ul>
</li>
<li><p>安全性</p>
<ul>
<li>安全性也是序列化工具选型的重要参考意见，比如广泛使用的fastjson，很多版本都存在RCE漏洞。</li>
</ul>
</li>
</ol>
<h2 id="3-序列化引擎"><a href="#3-序列化引擎" class="headerlink" title="3. 序列化引擎"></a>3. 序列化引擎</h2><p>​		一般来说，序列化&#x2F;反序列化分为IDL（Interface Description Language，接口描述语言）和非IDL两类。非IDL技术方案包含 JSON、XML等，提供构造和解析的工具包即可使用，不需要做代码生成的工作。IDL技术方案包含 Thrift、Protocol Buffer、Avro 等，有比较完整的规约和框架实现。</p>
<p><img src="/../images/hELYzbRMotrUMeYVsRa5vr9i.jpg" alt="image.jpg"></p>
<p>IDL 描述文件：比如，Thrift 是以 thrift 为后缀的文件，Protocol Buffer是以 proto 为后缀的文件。<br>IDL 文件编译器：根据 IDL 文件生成具有序列化&#x2F;反序列化功能的代码文件。例如，Thrift 通过 thrift 命令行指定编程语言类型来生成代码文件，Protocol Buffer 根据 protoc 命令行生成代码文件。<br>Stub&#x2F;Skeleton 代码：在客户（Client）端，一般称为 Stub 代码。在服务器（Server）端，一般称为 Skeleton 代码。</p>
<h2 id="4-Java序列化方式"><a href="#4-Java序列化方式" class="headerlink" title="4. Java序列化方式"></a>4. Java序列化方式</h2><h3 id="4-1-实现Serializable接口"><a href="#4-1-实现Serializable接口" class="headerlink" title="4.1 实现Serializable接口"></a>4.1 实现Serializable接口</h3><h4 id="4-1-1-默认的序列化-反序列化"><a href="#4-1-1-默认的序列化-反序列化" class="headerlink" title="4.1.1 默认的序列化&#x2F;反序列化"></a>4.1.1 默认的序列化&#x2F;反序列化</h4><p>实现 <code>Serializable</code> 接口是最常用的序列化方式，以下是简单示例</p>
<ul>
<li>准备一个待序列化的对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wick.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行序列化操作 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wick;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wick.pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;wick&quot;</span>, <span class="number">18</span>, <span class="string">&quot;beijing&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(Files.newOutputStream(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;user.out&quot;</span>).toPath())))&#123;</span><br><span class="line">            os.writeObject(user);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p> 在上面的例子中，我们使用 <code>ObjectOutputStream.writeObject(Object obj )</code> 方法来完成对象的序列化，并保存到本地文件中，我们可以使用二进制文件编辑器打开看下文件内容</p>
<p><img src="/../images/Y1ECwL99NPQ9CM8ivPzgBVHo.jpg" alt="iShot_2023-05-03_11.08.28.jpg"></p>
<p>同样的，我们也可以使用 <code>ObjectInputStream.readObject() </code> 方法来将一个对象反序列化出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(Files.newInputStream(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;user.out&quot;</span>).toPath()));</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) ins.readObject();</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// out: User(name=wick, age=18, address=beijing)</span></span><br></pre></td></tr></table></figure>

<p>除了使用默认的序列化机制外，对于一些特殊的类， 我们需要定制序列化和反序列化方法的时候，可以通过重写以下方法实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObjectNoData</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException;</span><br></pre></td></tr></table></figure>

<p>上面的三个方法，并不是 <code>Serializable</code> 接口中的方法，而是特殊名称的方法，只要实现了 <code>Serializable</code> 接口，就可以通过重写这几个方法来实现定制的序列化和反序列化需求，jdk 中的很多类都有此操作，有兴趣的可以自行查看各自的实现，此处不做展开。</p>
<p><img src="/../images/2VNC72QBgSZyBYvENcVCm2bq.jpg" alt="iShot_2023-05-03_11.30.00.jpg"></p>
<h4 id="4-1-2-自定义序列化-反序列化"><a href="#4-1-2-自定义序列化-反序列化" class="headerlink" title="4.1.2 自定义序列化&#x2F;反序列化"></a>4.1.2 自定义序列化&#x2F;反序列化</h4><ul>
<li>对于上面的 User 类，我们可以通过重写 <code>writeObject(java.io.ObjectOutputStream out)</code> 方法来实现自定义的序列化，代码如下所示</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wick.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line">        <span class="comment">// 追加 toString() 的内容</span></span><br><span class="line">        s.writeBytes(<span class="string">&quot;name: &quot;</span> + name + <span class="string">&quot;, age: &quot;</span> + age + <span class="string">&quot;, address: &quot;</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>序列化对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSerializer</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;wick&quot;</span>, <span class="number">18</span>, <span class="string">&quot;beijing&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(Files.newOutputStream(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;user1.out&quot;</span>).toPath())))&#123;</span><br><span class="line">        os.writeObject(user);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用工具查看生成的二进制文件内容，可以明显看到后面追加了刚才 <code>toString()</code> 方法的内容，这样就实现了对象的自定义序列化。</p>
<p><img src="/../images/PyvHnp3XR3K5NXyT1MK4cr6D.png" alt="image-20230503115610143.png"></p>
</li>
<li><p>同样的，我们也可以通过重写 <code>readObject(java.io.ObjectInputStream s) </code> 方法来实现自定义的反序列化操作</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span> <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">   s.defaultReadObject();</span><br><span class="line">   <span class="comment">// 读取 toString() 的内容</span></span><br><span class="line">   <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">   <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.read(bytes);</span><br><span class="line">   String[] split = <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len).split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">  	<span class="comment">// 此处，将 name 和 address 属性交换读取，不然看不出来区别</span></span><br><span class="line">   <span class="built_in">this</span>.address = split[<span class="number">0</span>].split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>].trim();</span><br><span class="line">   <span class="built_in">this</span>.age = Integer.parseInt(split[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>].trim());</span><br><span class="line">   <span class="built_in">this</span>.name = split[<span class="number">2</span>].split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>].trim();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>反序列化对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(Files.newInputStream(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;user1.out&quot;</span>).toPath()));</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) ins.readObject();</span><br><span class="line">    System.out.println(user.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// out: User(name=beijing, age=18, address=wick)</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-实现Externalizable接口"><a href="#4-2-实现Externalizable接口" class="headerlink" title="4.2 实现Externalizable接口"></a>4.2 实现Externalizable接口</h3><p>除了实现 <code>Serializable</code> 接口完成序列化&#x2F;反序列化外，还可以通过实现 <code>Externalizable</code> 接口达到序列化&#x2F;反序列化的目的， 但是如果实现了 <code>Externalizable</code> 接口， 那就必须实现 <code>writeExternal(ObjectOutput out) </code> 和 <code>readExternal(ObjectInput in)</code> 方法。</p>
<ul>
<li>以下我们还是以简单的 Person 类来举例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wick.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Externalizable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInput;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutput;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wick</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2023/5/3 12:09</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span> <span class="comment">// 必须要有无参构造，如果没有重写构造方法，则默认会有无参构造</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Externalizable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        out.writeObject(name);</span><br><span class="line">        out.writeInt(age);</span><br><span class="line">        out.writeObject(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        name = (String) in.readObject();</span><br><span class="line">        age = in.readInt();</span><br><span class="line">        address = (String) in.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>序列化对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;wick&quot;</span>, <span class="number">18</span>, <span class="string">&quot;nanjing&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(Files.newOutputStream(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;person.out&quot;</span>).toPath())))&#123;</span><br><span class="line">        os.writeObject(person);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用工具查看序列化后的内容</li>
</ul>
<p> <img src="/../images/ZJ9fqjsXpnfXGsH7i5P1iYw5.png" alt="image-20230503122846877.png"></p>
<ul>
<li>反序列化对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(Files.newInputStream(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;person.out&quot;</span>).toPath()));</span><br><span class="line">    <span class="type">Person</span> <span class="variable">user</span> <span class="operator">=</span> (Person) ins.readObject();</span><br><span class="line">    System.out.println(user.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// out: Person(name=wick, age=18, address=nanjing)</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-两种序列化方式的比较"><a href="#4-3-两种序列化方式的比较" class="headerlink" title="4.3 两种序列化方式的比较"></a>4.3 两种序列化方式的比较</h3><ul>
<li><p>实现方式</p>
<ul>
<li><p>Serializable 接口：是 Java 语言提供的标记接口，即不需要实现任何方法，只需要在类名加上 <code>implements Serializable</code> 即可。当一个对象被序列化时，Java 的序列化机制会把对象的状态保存到一个字节序列中。而当一个对象被反序列化时，Java 的序列化机制会根据保存的字节序列来创建并初始化一个对象。</p>
</li>
<li><p>Externalizable 接口：需要实现 <code>readExternal</code> 和 <code>writeExternal</code> 两个方法，用来表示如何序列化和反序列化一个对象。可以通过这两个方法来控制对象状态的写入和读取。 <code>readExternal</code> 和 <code>writeExternal</code> 方法不是由 Java 序列化机制调用的，而是需要手动调用，因此可以进行一些额外的初始化或特殊操作。</p>
</li>
</ul>
</li>
<li><p>序列化效率</p>
<ul>
<li><p>Serializable 接口：在序列化和反序列化一个对象时，序列化机制会自动地对该对象的所有非静态成员进行序列化和反序列化操作。因为使用的是自动序列化机制，这可能会创建一些不必要的对象和字节数组，从而降低序列化的效率，尤其当某个类的父类也实现了可序列化接口时，更耗费资源。</p>
</li>
<li><p>Externalizable 接口：由于对对象的序列化和反序列化过程都是手动控制的，<code>Externalizable</code> 实现的序列化效率比 <code>Serializable</code> 高，特别是在序列化大型对象图时。但是，需要手动调用接口的方法，可能需要更多的代码开销和维护成本。</p>
</li>
</ul>
</li>
</ul>
<p>综上所述，<code>Serializable</code> 接口更加简单且容易实现，但是效率相比于 <code>Externalizable</code> 接口会下降；而 <code>Externalizable</code> 接口需要手动编写序列化和反序列化的方法，但是它提供了更好的控制序列化的过程并且具有更高的序列化效率。</p>
<h2 id="5-Java序列化核心类-接口"><a href="#5-Java序列化核心类-接口" class="headerlink" title="5 Java序列化核心类&#x2F;接口"></a>5 Java序列化核心类&#x2F;接口</h2><h3 id="5-1-Serializable"><a href="#5-1-Serializable" class="headerlink" title="5.1 Serializable"></a>5.1 Serializable</h3><p>Serializable 接口源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Serializable</code> 是一个空接口，表明了实现自该接口的子类具有序列化行为特征，所有要支持序列化的类都应该实现这个接口。在后面介绍 <code>ObjectOutputStream</code> 的<code>writeObject</code> 方法时，会解释为什么必须这么做。</p>
<h3 id="5-2-Externalizable"><a href="#5-2-Externalizable" class="headerlink" title="5.2 Externalizable"></a>5.2 Externalizable</h3><p><code>Externalizable</code> 接口源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Externalizable</span> <span class="keyword">extends</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此接口有两个必须要重写的方法，在上面我们已经介绍过，<code>writeExternal</code> 的参数是 <code>ObjectOutput</code>，表示输出对象的抽象，它继承自 <code>DataOutput</code>，能支持基本类型、String、数组、对象的输出。实际应用中，会使用它的实现类 <code>ObjectOutputStream</code>。 <code>readExternal</code> 的参数是 <code>ObjectInput</code>，表示输入对象的抽象，它继承自 <code>DataInput</code>，能支持基本类型、String、数组、对象的输入。实际应用中，会使用它的实现类 <code>ObjectInputStream</code>。自定义的类必须包含无参构造函数。</p>
<h3 id="5-3-ObjectOutputStream"><a href="#5-3-ObjectOutputStream" class="headerlink" title="5.3 ObjectOutputStream"></a>5.3 ObjectOutputStream</h3><p><code>java.io.ObjectOutputStream</code> 是实现序列化的关键类，它可以将一个对象转换成二进制流，然后通过 <code>ObjectInputStream</code> 将二进制流还原成对象。为了能更好地理解 <code>ObjectOutputStream</code>，先简要说明其内部的几个关键类：</p>
<h4 id="5-3-1-BlockDataOutputStream"><a href="#5-3-1-BlockDataOutputStream" class="headerlink" title="5.3.1 BlockDataOutputStream"></a>5.3.1 BlockDataOutputStream</h4><p><code>BlockDataOutputStream</code> 是Java标准库中的一个类，它是<code>DataOutputStream</code> 的子类，用于提供对数据进行块写入的功能。<code>BlockDataOutputStream </code>类主要用于为<code>ObjectOutputStream</code> 类提供支持。在对象序列化过程中，<code>ObjectOutputStream </code>会使用 <code>BlockDataOutputStream</code> 来处理原始数据的写入。</p>
<p>以下是<code>BlockDataOutputStream</code>的一些主要特点和功能：</p>
<ol>
<li><p>块数据写入：<code>BlockDataOutputStream</code>允许以块的形式，将原始数据按照一组字节进行写入。块数据包含了一些元信息，如块长度、类型等，以便在反序列化时进行正确的解析。</p>
</li>
<li><p>压缩：<code>BlockDataOutputStream </code>可以对数据进行压缩，以减小序列化数据的大小，提高传输效率。</p>
</li>
<li><p>写入类型：除了基本的数据类型，<code>BlockDataOutputStream</code> 还支持写入字符串、数组、特定类型对象等。</p>
<p><img src="/../images/qpTtpLL9DYbfFPFkSN5onUmd.jpg" alt="WeChat1fff69b0fbc7927f0b6236408eb494ae.jpg"></p>
</li>
<li><p>缓冲区管理：<code>BlockDataOutputStream</code>使用内部缓冲区（Buffer）来提高写操作的性能。缓冲区会在需要时被填满并进行刷出。</p>
</li>
</ol>
<p>简单来说，<code>BlockDataOutputStream</code>是用于支持对象序列化过程中的底层数据写入。它提供了块数据写入的功能，可以进行压缩以减小数据大小，同时也实现了缓冲区管理，以提高写入操作的性能。作为 <code>ObjectOutputStream</code> 内置的具有缓冲作用的输出功能类，包含阻塞和非阻塞两种工作模式。两种模式的工作流程相同，都是先把待写的数据写到缓冲区，直到缓冲区满后再执行真正的写入操作，只是在阻塞模式下，每次将缓冲区数据写入之前会写入一个阻塞标记头部（Block Data Header）。 </p>
<h4 id="5-3-2-HandleTable"><a href="#5-3-2-HandleTable" class="headerlink" title="5.3.2 HandleTable"></a>5.3.2 HandleTable</h4><p>管理对象引用的处理，在 Java 的序列化机制中，如果一个对象被多次引用，那么在序列化过程中会将对象序列化为多个拷贝，这样会导致序列化结果变得冗长。为了解决这个问题，Java 序列化机制使用了对象引用句柄。<code>HandleTable</code> 类的作用是维护了一张对象引用句柄表，用来管理对象的序列化和反序列化过程中的引用处理。它通过使用句柄来代替重复的对象，从而实现对象的共享和压缩。具体来说，<code>HandleTable</code> 类中的 <code>handles</code> 数组存储了对象的引用句柄，索引值作为句柄值。当序列化一个对象时，<code>ObjectOutputStream </code>会将对象写入输出流，并将其句柄（索引值）写入句柄表中。当序列化过程中遇到同一个对象的引用时，它会使用相同的句柄值来表示该对象，这样就实现了对象的共享。在反序列化过程中，<code>ObjectInputStream</code>会根据句柄值从句柄表中获取对应的对象引用。通过使用句柄表，<code>HandleTable</code> 类可以有效地减少序列化结果的大小，并提高序列化和反序列化的效率。它是Java序列化机制中的一个关键组件，帮助实现了序列化对象的共享和压缩。我们可以通过下面一张图来理解这个过程。</p>
<p><img src="/../images/eoWEk2V81BTRTxPzzit3BcEw.jpg" alt="HandleTable.jpg"></p>
<p>在上面这张简单的表示组合关系的类图中，我们可以看到 A 类是由 B 和 C 两个类来组合得到的，而 B，C 类内部都有 T 类，如果没有 <code>HandleTable</code>，那 A类的序列化过程就会变成：</p>
<ul>
<li>构造对象 B 和 C</li>
<li>在 B 中构造对象 T，在 C 中构造对象 T</li>
</ul>
<p>从上面这个过程我们发现，T 这个对象会分别在 B 和 C 中被构造一次，如果是更为复杂的对象，那么对于 T 来说，可能会出现非常多的拷贝对象，但是当引入 <code>HandleTable</code> 之后，事情就变得简单了，比先构造对象 B，然后发现用到了 T，则构造一次，并使用一个 <code>Object[]</code> 来缓存这个 T 对象，当构造 C 的时候发现它也用到了对象 T，则直接会从 <code>Object[]</code> 中取到这个对象的引用，避免了二次创建对象，下面是<code>HandleTable</code>类的简化示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HandlesTable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] handles; <span class="comment">// 引用句柄表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setObject</span><span class="params">(<span class="type">int</span> handle, Object obj)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置句柄对应的对象引用</span></span><br><span class="line">        handles[handle] = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">(<span class="type">int</span> handle)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取句柄对应的对象引用</span></span><br><span class="line">        <span class="keyword">return</span> handles[handle];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用数组作为存储结构，<code>HandleTable</code> 能够快速通过句柄值来获取对应的对象引用。通过索引操作，可以直接访问数组的元素，无需进行遍历或搜索操作，因此具有较快的存取速度。当需要序列化和反序列化对象时，<code>HandleTable</code> 会根据需要动态扩展数组的大小，以适应不同数量的对象引用。</p>
<h4 id="5-3-3-ReplaceTable"><a href="#5-3-3-ReplaceTable" class="headerlink" title="5.3.3 ReplaceTable"></a>5.3.3 ReplaceTable</h4><p><code>ReplaceTable</code>类的主要作用是在序列化过程中，当遇到可以被替换的对象时，将对象替换为其他对象。这样可以更好地控制序列化的结果，实现自定义的序列化逻辑。具体来说，<code>ReplaceTable</code>类维护了一个替换表（Replacement table），它是一个<code>Map</code>数据结构，用于存储对象的替代对应关系。在序列化过程中，当要序列化一个对象时，<code>ObjectOutputStream</code>会检查该对象是否实现了<code>writeReplace()</code>方法。若实现了此方法，<code>ObjectOutputStream</code>会调用该方法获取替代对象，并将替代对象进行序列化。如果替代对象不为<code>null</code>，则将替代对象添加到替换表中。在后续的序列化过程中，如果遇到与替换表中的对象相等的对象时，<code>ObjectOutputStream</code>会将该对象替换为替代对象进行序列化。这样可以在序列化过程中实现对象替换，更好地控制序列化结果。通过使用<code>ReplaceTable</code>类，可以在序列化过程中灵活地替换对象，实现自定义的序列化行为，例如实现对象的版本控制、对象的压缩、对象的安全性检查等。</p>
<h4 id="5-3-4-ObjectStreamClass"><a href="#5-3-4-ObjectStreamClass" class="headerlink" title="5.3.4 ObjectStreamClass"></a>5.3.4 ObjectStreamClass</h4><p><code>ObjectStreamClass</code> 的主要作用是提供关于类的序列化和反序列化的元数据信息。它存储了与类相关的信息，并在序列化和反序列化时使用这些信息来进行匹配和操作。通过 <code>ObjectStreamClass</code> ，我们可以了解类的版本号、类的字段信息以及类的序列化支持情况等。这使得在进行序列化和反序列化过程时，能够正确地处理对象的属性和版本兼容性。以下是其核心字段及作用：</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">字段意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Class&lt;?&gt; cl</td>
<td align="left">序列化类的 Class 类型</td>
</tr>
<tr>
<td align="left">String name</td>
<td align="left">序列化类的完整类名</td>
</tr>
<tr>
<td align="left">volatile Long suid</td>
<td align="left">序列化 ID，使用 volatile 关键字还可以禁止编译器进行某些优化，例如重排序。这是因为在对象序列化和反序列化的过程中，与版本号相关的操作必须按照特定的顺序进行，否则可能导致不正确的结果。</td>
</tr>
<tr>
<td align="left">boolean isProxy</td>
<td align="left">是否是代理类</td>
</tr>
<tr>
<td align="left">boolean isEnum</td>
<td align="left">是否是枚举类</td>
</tr>
<tr>
<td align="left">boolean serializable</td>
<td align="left">是否实现了 Serializable 接口</td>
</tr>
<tr>
<td align="left">boolean externalizable</td>
<td align="left">是否实现了 Externalizable 接口</td>
</tr>
<tr>
<td align="left">boolean hasWriteObjectData</td>
<td align="left">是否使用自定义的 writeObject 方法写数据</td>
</tr>
<tr>
<td align="left">boolean hasBlockExternalData</td>
<td align="left">类是否包含阻塞式外部数据，阻塞式外部数据指的是在进行对象的序列化时，如果存在某些在序列化过程中需要阻塞的外部数据（比如通过网络传输），那么阻塞式外部数据就会设置为<code>true</code>。 当<code>hasBlockExternalData</code>字段为<code>true</code>时，序列化和反序列化过程中的某些步骤可能会被阻塞，直到外部数据就绪或可用。这样可以确保在序列化和反序列化过程中正确地处理外部依赖。通过这个字段，<code>ObjectStreamClass</code>类在序列化和反序列化时可以根据需要采取相应的行动，以确保阻塞式外部数据正常处理。</td>
</tr>
<tr>
<td align="left">ClassNotFoundException resolveEx</td>
<td align="left">尝试解析类时发生的异常</td>
</tr>
<tr>
<td align="left">ExceptionInfo deserializeEx</td>
<td align="left">非枚举类反序列化异常，ExceptionInfo 也是 ObjectStreamClass 的一个内部类，表示操作类时产生的异常</td>
</tr>
<tr>
<td align="left">ExceptionInfo serializeEx</td>
<td align="left">非枚举类序列化异常</td>
</tr>
<tr>
<td align="left">ExceptionInfo defaultSerializeEx</td>
<td align="left">尝试默认序列化时引发的异常</td>
</tr>
<tr>
<td align="left">ObjectStreamField[] fields</td>
<td align="left">可序列化字段</td>
</tr>
<tr>
<td align="left">int primDataSize</td>
<td align="left">基本类型的成员字段个数，不包含被 static 和 transient 修饰的字段</td>
</tr>
<tr>
<td align="left">int numObjFields</td>
<td align="left">非基本类型的成员字段个数</td>
</tr>
<tr>
<td align="left">FieldReflector fieldRefl</td>
<td align="left">缓存与类相关联的字段反射信息。它提供了一个快速访问字段的能力，避免了每次进行字段反射访问时的性能开销</td>
</tr>
<tr>
<td align="left">volatile ClassDataSlot[] dataLayout</td>
<td align="left">类的层次结构：当前类，父类，及其所有子类的类描述</td>
</tr>
<tr>
<td align="left">Constructor&lt;?&gt; cons</td>
<td align="left">适合序列化的构造函数，如果没有，则为 null</td>
</tr>
<tr>
<td align="left">ProtectionDomain[] domains</td>
<td align="left">与类相关联的保护域（<code>ProtectionDomain</code>）的数组。这些保护域定义了在序列化和反序列化过程中对类的访问权限。<code>ProtectionDomain</code>是Java安全性机制中的一个概念，它代表了一组相关代码的安全域。每个<code>ProtectionDomain</code>都由一个代码源（code source）和一组权限（permissions）组成。当一个对象被序列化时，其类信息会被存储在序列化数据中。在反序列化过程中，为了确保安全性，Java虚拟机（JVM）必须验证反序列化的类是否具有足够的权限进行访问。这个验证过程使用了类的保护域信息。通过<code>domains</code>属性，<code>ObjectStreamClass</code>可以存储和获取与类相关联的保护域信息。这些保护域将在反序列化过程中被用于验证类的访问权限。</td>
</tr>
<tr>
<td align="left">Method writeObjectMethod</td>
<td align="left">序列化方法，通过反射获取</td>
</tr>
<tr>
<td align="left">Method readObjectMethod</td>
<td align="left">反序列化方法，通过反射获取</td>
</tr>
<tr>
<td align="left">Method writeReplaceMethod</td>
<td align="left">当一个对象被序列化时，如果该对象类中定义了<code>writeReplace()</code>方法，那么在序列化过程中将调用这个方法来确定要序列化的对象。<code>writeReplace()</code>方法负责返回实际要序列化的对象。这样可以灵活地控制对象的序列化过程。</td>
</tr>
<tr>
<td align="left">Method readObjectNoDataMethod</td>
<td align="left">如果该对象类中定义了<code>readObjectNoData()</code>方法，那么在反序列化过程中将调用这个方法进行对象的初始化。<code>readObjectNoData()</code>方法用于在反序列化之后对反序列化得到的对象进行进一步处理，以确保对象的完整性和一致性</td>
</tr>
<tr>
<td align="left">Method readResolveMethod</td>
<td align="left">当一个对象被反序列化时，如果该对象类中定义了<code>readResolve()</code>方法，那么在反序列化过程中将调用这个方法来确定实际要返回的对象。<code>readResolve()</code>方法负责返回一个替代的对象，以确保在反序列化后得到的对象与原始对象保持一致。</td>
</tr>
<tr>
<td align="left">ObjectStreamClass localDesc</td>
<td align="left">当前类描述</td>
</tr>
<tr>
<td align="left">ObjectStreamClass superDesc</td>
<td align="left">父类描述</td>
</tr>
<tr>
<td align="left">boolean initialized</td>
<td align="left">对象是否已经初始化完成</td>
</tr>
</tbody></table>
<h3 id="5-4-ObjectInputStream"><a href="#5-4-ObjectInputStream" class="headerlink" title="5.4 ObjectInputStream"></a>5.4 ObjectInputStream</h3><p><code>java.io.ObjectInputStream</code> 是实现Java反序列化的关键类，和 <code>ObjectOutputStream</code> 是对应的，内部包含了 <code>BlockDataInputStream</code>、<code>HandleTable</code>、<code>ReplaceTable</code>、<code>ObjectStreamClass</code> 等，这里不展开描述。</p>
<h2 id="6-Java-序列化原理"><a href="#6-Java-序列化原理" class="headerlink" title="6. Java 序列化原理"></a>6. Java 序列化原理</h2><p>以上，我们了解到了 java 实现序列化的方式，以及序列化过程中会用到的核心类&#x2F;接口，接下来我们需要知道Java序列化的流程、原理，以及各种类型数据进行Java序列化后的格式和占用空间大小等细节，这也是序列化技术的核心所在。不同序列化方案的技术细节不尽相同，对各种数据类型处理后的格式和大小也不尽相同。</p>
<h3 id="6-1-基本类型数据序列化流程"><a href="#6-1-基本类型数据序列化流程" class="headerlink" title="6.1 基本类型数据序列化流程"></a>6.1 基本类型数据序列化流程</h3><p>在学习基本类型的序列化流程之前，我们先回顾两个知识点</p>
<ol>
<li>Java 中基本数据类型有几种，及其长度</li>
</ol>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>字节长度</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>4字节（-2,147,483,648 到 2,147,483,647）</td>
</tr>
<tr>
<td>long</td>
<td>8字节（-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807）</td>
</tr>
<tr>
<td>double</td>
<td>8字节（IEEE 754双精度浮点数）</td>
</tr>
<tr>
<td>char</td>
<td>2字节（无符号Unicode字符，以UTF-16编码表示，可存储一个unicode字符）</td>
</tr>
<tr>
<td>byte</td>
<td>1字节（-128 到 127）</td>
</tr>
<tr>
<td>boolean</td>
<td>1 位，只能是 true 或者 false</td>
</tr>
<tr>
<td>short</td>
<td>2字节（-32,768 到 32,767）</td>
</tr>
<tr>
<td>float</td>
<td>4字节（IEEE 754单精度浮点数）</td>
</tr>
</tbody></table>
<ol start="2">
<li>字节的高低位</li>
</ol>
<p>在计算机中，一个字节由8个位（bit）组成。在一个字节中的每个位都有特定的位置。位可以被编号，从最右边的位（称为最低有效位）开始，往左依次递增编号，最左边的位称为最高有效位，也称为高位。其实这个很好理解，在电视上我们也见过支票，支票的金额就是从左往右写的</p>
<p><img src="/../images/D4zoDNdPDaHmkVdGgKk2J9Uh.jpg" alt="iShot_2023-07-30_09.06.14.jpg"></p>
<p>比如上面这张图，在右边的金额栏，从左往右依次是高单位到低单位，所以最左边的就是高位，最右边的就是低位。</p>
<p>字节的高位和低位术语通常用于表示多字节数据类型（如整数）的个别字节在内存中的存储顺序。在多字节的数据类型中，数据在内存中以连续的字节序列存储，而字节序列的顺序可以是”大端”或”小端”。</p>
<ul>
<li>大端字节序：最高有效位存储在起始地址，最低有效位存储在最后地址。</li>
<li>小端字节序：最低有效位存储在起始地址，最高有效位存储在最后地址。</li>
</ul>
<p>举个例子，假设一个整数值0x12345678在内存中按照大端字节序存储。将这个整数值转换为字节序列时，高位字节0x12存储在起始地址，低位字节0x78存储在最后地址。</p>
<p>地址:  0             1          2          3       </p>
<p>​     |  0x12 | 0x34 | 0x56 | 0x78 |</p>
<p>相反，如果按照小端字节序存储，高位字节0x78存储在起始地址，低位字节0x12存储在最后地址。</p>
<p>地址:  0             1           2         3       </p>
<p>​     |  0x78 | 0x56 | 0x34 | 0x12 |</p>
<p>在Java中，默认使用的是采用大端字节序（Big Endian）的内存存储模式。这意味着在多字节数据类型（如int、long、float、double等）存储在内存中时，最高有效字节存储在起始地址，按顺序向后存储。</p>
<p>回顾完上面两个问题，我们继续看 Java 是如何序列化基本类型数据的，Java序列化对基本类型数据的处理，严格按照其内存占用大小来进行。比如int类型占用4字节，Java 序列化按照高位到低位依次放到字节数组，再写入到序列化输出对象，真正的写入是通过调用 <code>BlockDataOutputStream</code> 的 <code>writeInt</code> 方法实现的。<code>BlockDataOutputStream</code> 内部维护了一个1024字节大小的缓冲区，如果缓冲区还可以容纳待写入的 int 类型数据，则把当前数据放入缓冲区；如果缓冲区不能容纳待写入的int类型数据，则调用 <code>DataOutputStream</code> 的 <code>writeInt</code> 方法，如以下代码所示：</p>
<p><img src="/../images/4Qb15TfgRvpQVzKXeovi4x6n.jpg" alt="iShot_2023-07-30_08.42.21.jpg"></p>
<p>接下来我们看下 <code>DataOutputStream</code> 的<code> writeInt()</code> 方法是如何写 int 类型数据的</p>
<p><img src="/../images/GT5b8caHzuYKzwVp3UELmE1J.jpg" alt="iShot_2023-07-30_08.46.04.jpg"></p>
<p>我们可以逐步看下这几段代码的含义：</p>
<ol>
<li>out.write(): 很明显这是一个写入操作，可以将内容写入文件或者套接字。</li>
<li>v &gt;&gt;&gt; 24: 这是一个无符号右移操作符，将v向右移动24位（int 长度 4 字节，即 32 位，从第一个字节(8位)开始向右移动24 位即可达到最低位 32 ）。右移操作是将二进制表示中的各位数值向右移动指定的位数，右边的空位用零填充。无符号右移运算符保证移位后左边空出的位总是用零填充。在这个表达式中，我们将整数v的最高8位移动到最低8位，并将其余位数清零，这样就可以提取一个 int 类型变量的最高有效字节的值，而不考虑符号位。</li>
<li>&amp; 0xFF: 这是一个按位与操作符，将上一步的结果与0xFF（十进制为255）进行按位与操作。0xFF的二进制表示为 00000000 00000000 00000000 11111111。这个操作可以确保结果只保留v最高的8位，将其他位数清零。</li>
</ol>
<p>从上面的代码我们可以看出，确实是按照从高到低的顺序来写入的。我们继续看 <code>out.write()</code> 做了什么(在当前流程中，out 是 BlockDataOutputStream 实例)</p>
<p><img src="/../images/nnhkeZR9xVtXQ4HnDPLJKW8n.jpg" alt="iShot_2023-07-30_09.19.46.jpg"></p>
<p><img src="/../images/SvQVRsCFmpzJeBTjx6ELCScy.jpg" alt="iShot_2023-07-30_09.21.17.jpg"></p>
<p>如果缓冲区能容纳当前待写入字节，则把当前字节写入缓冲区；如果缓冲区已满，则会先执行 drain 方法把缓冲区的数据输出，再把当前待写入字节放到缓冲区。通过上述流程，一个 int 类型的数据就写完了，其他类型数据流程类似，此处不做展开。</p>
<h3 id="6-2-对象类型数据序列化流程"><a href="#6-2-对象类型数据序列化流程" class="headerlink" title="6.2 对象类型数据序列化流程"></a>6.2 对象类型数据序列化流程</h3><p>学习完基本类型的序列化流程，我们来看下对象类型的数据是怎么被序列化的。Java序列化对非基本类型的数据处理比基本类型的数据处理更复杂，这里说的非基本类型包括Object、Enum、Array等。Java序列化对非基本类型数据的序列化操作是通过 <code>ObjectOutputStream</code> 的 <code>writeObject</code> 方法实现的，接下来将介绍其内部工作原理。</p>
<p>我们先看下 <code>writeObjet</code> 方法定义</p>
<p><img src="/../images/DPzF8Spr8Y1DeJAGaAyFxfgd.jpg" alt="iShot_2023-07-30_09.25.21.jpg"></p>
<p>首先检查是否启用了对象写入的重写功能。如果启用了，将调用<code>writeObjectOverride</code>方法，并立即返回。这个条件语句允许自定义的子类重写写入对象的逻辑。obj表示自定义的序列化对象或者Array、Enum类型对象。<code>writeObject0</code> 方法的第2个参数表示一个对象被多个对象共同引用时，在序列化的时候是否要共享写入。如果共享写入，被引用的对象实例只会被序列化一次，其他引用只会写入引用对象句柄。如果不共享写入，被引用的对象实例则会被序列化多次，序列化后的数据大小会增加。在 <code>writeObject</code> 方法里调用 <code>writeObject0</code>，第2个参数默认是false，表示共享写入。</p>
<p>我们继续看下 <code>writeObject0</code> 里面是如何处理非基本类型数据的。</p>
<p><img src="/../images/rGryaNJzbY1qfN2fLNPeMoU9.jpg" alt="iShot_2023-07-30_09.36.33.jpg"></p>
<p>代码比较简单，就是判断 obj 的类型，然后分别调用对应的处理方法，其实如果大家有翻过 String 或者 Enum 的源码，就会发现，这两个类也是实现了 <code>Serializable</code> 接口的，表示这些类都能被正常的序列化。对于Array对象，如果Array的元素是基本类型，则调用基本类型的序列化方式；如果Array的元素是Object类型，则递归调用writeObject0方法来执行序列化，又会执行到上述if分支判断。 如果是自定义的序列化类，则必须实现自Serializable。<br>总之，要能够被 <code>ObjectOutputStream</code> 的 <code>writeObject</code> 方法序列化，对象必须实现自Serializable，否则会抛NotSerializableException异常。 如果是自定义的序列化类，则会执行 <code>writeOrdinaryObject</code> 方法。</p>
<p>我们看下 <code>writeOrdinaryObject</code> 这个方法是如何处理我们自定义的序列化类的。</p>
<p><img src="/../images/zit43xT8vvpH2TSrFCk4WaJE.jpg" alt="iShot_2023-07-30_09.47.04.jpg"></p>
<p>如果自定义的类是 Externalizable 类型并且不是代理类，则调用writeExternalData方法；否则调用writeSerialData方法。Exernalizable继承自Serializable，并增加了writeExternal和readExternal两个接口。我们继续跟进 <code>writeSerialData</code>方法。</p>
<p><img src="/../images/pHupFXsgkCUmToA3Xn1ZqSaH.jpg" alt="iShot_2023-07-30_09.49.33.jpg"></p>
<p>首先获取 obj 对象的布局信息，<code>getClassDataLayout()</code> 表示获取当前类及继承链路上所有直接或间接实现了Serializable的祖先类对应的序列化元数据信息，返回值为ClassDataSlot类型数组，数组元素的顺序是从最根部的祖先类到当前类。ClassDataSlot包含了一个ObjectStreamClass类型的desc字段和boolean类型的hasData字段。ObjectStreamClass类前面已经提过，hasData字段表示desc对应的Java对象是否有数据被序列化。对于ClassDataSlot数组的每一个元素，如果该元素对应的类包含writeObject方法，则调用writeObjet方法。通过查看ObjectStreamClass里的invokeWriteObject方法内部实现，可以看出wirteObject方法以反射方式被调用，代码如下所示。</p>
<p><img src="/../images/Jaou5jiRioCwnQy7rMkzizdY.jpg" alt="iShot_2023-07-30_09.53.31.jpg"></p>
<p>回到writeSerialData方法内部实现，如果当前待序列化的类没有writeObject方法，则调用defaultWriteFields方法实现序列化，其内部实现如以下代码所示。</p>
<p><img src="/../images/xk3DXSuHLEZe6h1gWBdsZTao.jpg" alt="iShot_2023-07-30_09.55.58.jpg"></p>
<p>流程也比较简单，就是分开处理基本类型和对象类型的数据，其实没有 writeObject() 方法的类，但是还需要序列化的，我们很明显就知道是实现了 Serializable 接口的类，这也就是为什么你实现了这个序列化接口，但是无需实现序列化方法的原因。</p>
<p>回到writeOrdinaryObject方法实现，如果自定义类实现了Externalizable且不是动态代理类，则会调用writeExternalData方法实现序列化，核心代码如下所示。</p>
<p><img src="/../images/Eqhuh4qAQWUGvqxbxvSAN7um.jpg" alt="iShot_2023-07-30_10.00.30.jpg"></p>
<p>代码最终调用自定义类对象的writeExternal方法实现写入，看起来比Serializable类更简洁，原因是Externalizable接口中包含了readExternal和writeExternal方法，实现了Externalizable的子类必须覆盖readExternal和writeExternal方法。</p>
<h2 id="7-Java-序列化高级特性"><a href="#7-Java-序列化高级特性" class="headerlink" title="7. Java 序列化高级特性"></a>7. Java 序列化高级特性</h2><h3 id="7-1-transient-关键字"><a href="#7-1-transient-关键字" class="headerlink" title="7.1 transient 关键字"></a>7.1 transient 关键字</h3><p>Java序列化可以通过transient关键字来控制字段不被序列化。通过跟进ObjectStreamClass的getDefaultSerialFields方法内部实现，可以看到序列化字段不能为static 且不能为 transient，如以下代码所示：</p>
<p><img src="/../images/7J2xJTK42JMS8aEvQswTH1Ta.jpg" alt="iShot_2023-07-30_10.11.25.jpg"></p>
<h3 id="7-2-static-关键字"><a href="#7-2-static-关键字" class="headerlink" title="7.2 static 关键字"></a>7.2 static 关键字</h3><p>static字段属于类全局共有，不会被序列化。在反序列化得到的结果里，静态变量的值依赖类对该静态字段的初始化操作以及是否在同一个JVM进程内。比如说静态变量初始值为0，在序列化之前静态变量的值被设置为10，在同一个JVM进程内执行反序列化操作，得到的静态变量的值为10。如果在另外一个JVM进程内执行反序列化操作，得到的静态变量的值为0。这是因为类在JVM进程内只会被加载一次，相同的类在不同的JVM内都会初始化一遍。</p>
<h3 id="7-3-serialVersionUID"><a href="#7-3-serialVersionUID" class="headerlink" title="7.3 serialVersionUID"></a>7.3 serialVersionUID</h3><p>serialVersionUID用来实现类版本兼容，在实际开发中能满足类字段变化的需求。如果我们有一个 Person 类，实现了 Serializable 接口，但是没有定义serialVersionUID字段，对Person类增加一个double类型的字段height，再读取增加字段之前的序列化数据，反序列化会报<code>InvalidCastException</code> 异常。如果Person类定义了serialVersionUID字段，对Person类增加一个double类型的字段height，再读取增加字段之前的序列化数据，反序列化可以成功。<br> serialVersionUID字段必须是 <code>static+final</code> 类型，否则serialVersionUID字段不会被序列化，通过 <code>ObjectStreamClass</code> 的 <code>getDeclaredSUID</code> 方法实现可以得到验证:</p>
<p><img src="/../images/fLhYY1UfUXYaYS8Sib2GqewM.jpg" alt="iShot_2023-07-30_10.14.50.jpg"></p>
<p>如果不定义serialVersionUID字段，Java序列化会根据类字段和其他上下文计算一个默认值。所以，当类字段发生变化时，serialVersionUID值也会跟着变化，就会出现上述因类字段变化导致反序列化失败的问题。在Java编码规范中，应该强制自定义的序列化类包含serialVersionUID字段，各个Java IDE开发工具均能配置针对serialVersionUID的检查告警级别。</p>
<h3 id="7-4-序列化-反序列化hook"><a href="#7-4-序列化-反序列化hook" class="headerlink" title="7.4 序列化&#x2F;反序列化hook"></a>7.4 序列化&#x2F;反序列化hook</h3><h4 id="7-4-1-writeReplace-方法"><a href="#7-4-1-writeReplace-方法" class="headerlink" title="7.4.1 writeReplace 方法"></a>7.4.1 writeReplace 方法</h4><p>writeReplace方法用于序列化写入时拦截并替换成一个自定义的对象。这个方法也是在 ObjectStreamClass 类中被反射获取的</p>
<p><img src="/../images/T499tgA9fZSSP5p9PPyYbTxV.jpg" alt="iShot_2023-07-30_10.24.33.jpg"></p>
<p>由于writeReplace方法调用是基于反射来执行的，所以作用域限定符不受限制，可以是private、default、protected、public中的任意一种。 如果定义了wirteReplace方法，就没必要再定义writeObject方法了。即使定义了writeObject方法，该方法也不会被调用，内部会先调用writeReplace方法将当前序列化对象替换成自定义目标对象。同理，也没必要定义readObject方法，即使定义了也不会被调用。writeReplace方法的生效原理见ObjectOutputStream的writeObject0方法实现，核心代码如下所示。</p>
<p><img src="/../images/6LkQhoJM6ZDiYWqgZ2Ugg8Yp.jpg" alt="iShot_2023-07-30_10.28.19.jpg"></p>
<h4 id="7-4-2-readReplace-方法"><a href="#7-4-2-readReplace-方法" class="headerlink" title="7.4.2 readReplace 方法"></a>7.4.2 readReplace 方法</h4><p>readResolve方法用于反序列化拦截并替换成自定义的对象。但和writeReplace方法不同的是，如果定义了readResolve方法，readObject方法是允许出现的。同样的，readResolve 方法也是在 ObjectStreamClass 类中被反射获取的。</p>
<p>readResolve方法的工作原理为： </p>
<ul>
<li>首先调用readObject0方法得到反序列化结果。 </li>
<li>如果readResolve方法存在，则会调用该方法返回自定义的对象。 </li>
<li>将自定义的对象作为ObjectInputStream的readObject的返回值。</li>
</ul>
<p>readResolve方法用在什么场景呢？常见的一种场景是类实现的枚举类型，枚举对象在反序列化时做恢复性保护。对于类实现的枚举类型，反序列化出来的枚举对象期望是定义的枚举对象，这也体现了枚举的意义。但是从代码执行情况看，反序列化出来的的枚举对象是一个新建出来的枚举对象，虽然值和枚举值定义的一样，但不是同一个对象。因此，需要在反序列化的过程中对枚举对象进行恢复保护，readResolve方法就派上用场了。示例如下：</p>
<p>未使用 readResolve 方法前：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oppo.serializedemo.pojo.po;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wick</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2023/7/29 22:17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoneType</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">PhoneType</span> <span class="variable">OPPO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhoneType</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">PhoneType</span> <span class="variable">VIVO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhoneType</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;phoneType.out&quot;</span>)));</span><br><span class="line">        os.writeObject(PhoneType.OPPO);</span><br><span class="line">        os.close();</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;phoneType.out&quot;</span>)));</span><br><span class="line">        <span class="type">PhoneType</span> <span class="variable">phoneType</span> <span class="operator">=</span> (PhoneType) is.readObject();</span><br><span class="line">        System.out.println(phoneType == PhoneType.OPPO); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加 readResolve 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oppo.serializedemo.pojo.po;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wick</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2023/7/29 22:17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoneType</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">PhoneType</span> <span class="variable">OPPO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhoneType</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">PhoneType</span> <span class="variable">VIVO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhoneType</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> OPPO;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> VIVO;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;phoneType.out&quot;</span>)));</span><br><span class="line">        os.writeObject(PhoneType.OPPO);</span><br><span class="line">        os.close();</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;phoneType.out&quot;</span>)));</span><br><span class="line">        <span class="type">PhoneType</span> <span class="variable">phoneType</span> <span class="operator">=</span> (PhoneType) is.readObject();</span><br><span class="line">        System.out.println(phoneType == PhoneType.OPPO); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-5-数据校验"><a href="#7-5-数据校验" class="headerlink" title="7.5 数据校验"></a>7.5 数据校验</h3><p>Java序列化机制在反序列化时支持对数据进行校验。这是因为Java序列化后的数据是明文形式，有可能被修改。在反序列化过程中，为了安全起见，可以对读取到的数据进行校验。默认的Java反序列化是不会校验数据的。 使用数据校验特性，需要让自定义的序列化类实现 <code>java.io.ObjectInputValidation</code> 接口，通过调用回调函数 <code>validateObject</code> 来实现数据验证。此处给出示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oppo.serializedemo.pojo.po;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wick</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2023/7/30 10:45</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>, ObjectInputValidation &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validateObject</span><span class="params">()</span> <span class="keyword">throws</span> InvalidObjectException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(name, <span class="string">&quot;zhangSan&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;用户已经被禁用&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        in.defaultReadObject(); <span class="comment">// 执行默认的反序列化操作</span></span><br><span class="line">        validateObject(); <span class="comment">// 在反序列化完成后进行对象验证</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangSan&quot;</span>);</span><br><span class="line">        os.writeObject(user);</span><br><span class="line">        os.close();</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">        <span class="comment">// 在此处就会抛出异常：java.io.InvalidObjectException: 用户已经被禁用</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> (User) is.readObject();</span><br><span class="line">        is.close();</span><br><span class="line">        System.out.println(user1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-选择-Serializable-还是-Externalizable"><a href="#8-选择-Serializable-还是-Externalizable" class="headerlink" title="8 选择 Serializable 还是 Externalizable"></a>8 选择 Serializable 还是 Externalizable</h2><p>在Java序列化应用方面，读者应该会困惑两种机制应选择哪种。从功能角度看，二者都是Java序列化已经支持的。从易用性方面来考虑，Serializable比Externalizable易用性好。首先，Serializable提供了默认的序列化与反序列化行为，用户不需要关注序列化的实现细节即可拿来使用；而Externalizable必须实现readExternal和writeExternal接口且要提供默认构造函数。其次，在自定义序列化行为方面，Serializable也可以通过readObject和writeObject来支持。 对于初学者或者对自己代码水平没啥自信的同学，可以优先选择Serializable。从很多JDK源码和开源代码中可以看到，序列化接口都实现自Serializable。在继承链路上，如果要终止一个子类的Serializable或者Externaizable特性，则在readObject&#x2F;writeObject方法或readExternal&#x2F;writeExternal方法接口里抛出 <code>UnsupportedOperationException</code> 异常，表示不支持序列化和反序列化功能。</p>
<h2 id="9-Java序列化安全"><a href="#9-Java序列化安全" class="headerlink" title="9. Java序列化安全"></a>9. Java序列化安全</h2><p>Java序列化后的数据是明文形式，而且数据的组成格式有明确的规律。当这些数据脱离Java安全体系存在磁盘中时，可以通过二进制数编辑工具查看，甚至修改。如果这些数据注入了病毒，应用程序的表现行为将无法预计。为了保障数据的安全性，引入SealedObject和SignedObject对序列化数据进行加密。</p>
<h3 id="9-1-SealedObject"><a href="#9-1-SealedObject" class="headerlink" title="9.1 SealedObject"></a>9.1 SealedObject</h3><p>以下演示如何使用 SealedObject 来保证序列化&#x2F;反序列化安全</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oppo.serializedemo.pojo.po;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SealedObject;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wick</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2023/7/30 10:45</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">key</span> <span class="operator">=</span> KeyGenerator.getInstance(<span class="string">&quot;DESede&quot;</span>).generateKey();</span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;DESede&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, key);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangSan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="type">SealedObject</span> <span class="variable">sealedObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SealedObject</span>(user, cipher);</span><br><span class="line">        os.writeObject(sealedObject);</span><br><span class="line">        os.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用二进制工具查看 user 文件，发现跟我们之前未加密的数据不一样，连基本字段和值都看不到了</p>
<p><img src="/../images/eKGGeVsFyVRtbWwq9U8874nm.jpg" alt="iShot_2023-07-30_11.16.58.jpg"></p>
<p>我们直接使用 ObjectInputStream 反序列化一下试试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oppo.serializedemo.pojo.po;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SealedObject;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wick</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2023/7/30 10:45</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">key</span> <span class="operator">=</span> KeyGenerator.getInstance(<span class="string">&quot;DESede&quot;</span>).generateKey();</span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;DESede&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, key);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangSan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="type">SealedObject</span> <span class="variable">sealedObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SealedObject</span>(user, cipher);</span><br><span class="line">        os.writeObject(sealedObject);</span><br><span class="line">        os.close();</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">        <span class="type">SealedObject</span> <span class="variable">sealedObject1</span> <span class="operator">=</span> (SealedObject) is.readObject();</span><br><span class="line">        is.close();</span><br><span class="line">        <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> (User) sealedObject1.getObject(key);</span><br><span class="line">        System.out.println(u1); <span class="comment">// User(name=zhangSan, age=18)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们就通过一个加密&#x2F;解密的手段来保护了对象在序列化&#x2F;反序列化过程中的安全。</p>
<h3 id="9-2-SignedObject"><a href="#9-2-SignedObject" class="headerlink" title="9.2 SignedObject"></a>9.2 SignedObject</h3><p>SignedObject 也是通过加解密的方式来保护序列化安全的，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oppo.serializedemo.pojo.po;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyPair;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyPairGenerator;</span><br><span class="line"><span class="keyword">import</span> java.security.Signature;</span><br><span class="line"><span class="keyword">import</span> java.security.SignedObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wick</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2023/7/30 11:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;account&quot;</span>));</span><br><span class="line">        <span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> KeyPairGenerator.getInstance(<span class="string">&quot;RSA&quot;</span>).generateKeyPair();</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="string">&quot;zhangSan&quot;</span>, <span class="number">1000.0</span>);</span><br><span class="line">        <span class="type">SignedObject</span> <span class="variable">signedObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SignedObject</span>(account, keyPair.getPrivate(), Signature.getInstance(<span class="string">&quot;SHA256withRSA&quot;</span>));</span><br><span class="line">        os.writeObject(signedObject);</span><br><span class="line">        os.close();</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;account&quot;</span>));</span><br><span class="line">        <span class="type">SignedObject</span> <span class="variable">signedObject1</span> <span class="operator">=</span> (SignedObject) is.readObject();</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account1</span> <span class="operator">=</span> (Account) signedObject1.getObject();</span><br><span class="line">        System.out.println(account1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-总结"><a href="#10-总结" class="headerlink" title="10. 总结"></a>10. 总结</h2><p>Java序列化方案成熟度高，但性能和压缩效果均一般，只适合JVM系列语言共享数据，不具备完全的跨语言能力。另外，它会带来一些数据安全性和完整性问题。在我们真正的 web 开发过程中，基本不会去使用以上的序列化方式，而是往往会选择具有跨语言能力、性能高效、压缩效果显著的方案，例如Thrift、Protocol Buffer、Json、Xml 等。但是了解 Java 的序列化&#x2F;反序列化过程，对于程序员能力的提升，还是有较大的意义。</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://linvaux.github.io/posts/131d41e/" title="深入理解Java中的序列化和反序列化" target="_blank" rel="external">https://linvaux.github.io/posts/131d41e/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://gitee.com/linvaux" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar1.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://gitee.com/linvaux" target="_blank"><span class="text-dark">大耳朵图图</span><small class="ml-1x">Java开发/高级测试开发</small></a></h3>
        <div>一个持续学习的靓仔</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/posts/a12172a0/" title="线上问题分析案例:一个小括号引发的惨案"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/posts/fb3714ea/" title="IDEA高效使用指南(一)"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>



    <script>
(function ($) {
    $('.search-form').on('submit', function (e) {
        var keyword = $('.search-form-input[name="wd"]').val();
        window.location = 'https://www.baidu.com/s?wd=site:linvaux.github.io ' + keyword;
        return false;
    });
})(jQuery);
</script>




   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   


  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script>
  <script>
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function() {
    $('article img').not('[hidden]').not('.panel-body img').each(function() {
      var $image = $(this);
      var imageCaption = $image.attr('alt');
      var $imageWrapLink = $image.parent('a');
      if ($imageWrapLink.length < 1) {
        var src = this.getAttribute('src');
        var idx = src.lastIndexOf('?');
        if (idx != -1) {
          src = src.substring(0, idx);
        }
        $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
      }
      $imageWrapLink.attr('data-fancybox', 'images');
      if (imageCaption) {
        $imageWrapLink.attr('data-caption', imageCaption);
      }
    });
    $().fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
    });
  });
  </script>





</body>
</html>