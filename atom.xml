<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>写bug的大耳朵图图</title>
  
  
  <link href="https://linvaux.github.io/atom.xml" rel="self"/>
  
  <link href="https://linvaux.github.io/"/>
  <updated>2024-09-21T00:59:08.923Z</updated>
  <id>https://linvaux.github.io/</id>
  
  <author>
    <name>Wick</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Github Pages使用Hexo搭建个人博客</title>
    <link href="https://linvaux.github.io/posts/a7b6bddb/"/>
    <id>https://linvaux.github.io/posts/a7b6bddb/</id>
    <published>2024-08-24T13:59:39.000Z</published>
    <updated>2024-09-21T00:59:08.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我的个人博客之前是托管在 <strong><a href="https://geeknote.net/wick">https://geeknote.net/wick</a></strong> 上，但是因为一些体验问题，我决定迁移到Github Pages上。Github Pages是Github提供的一个静态网站托管服务，可以用来搭建个人博客、项目文档等。Hexo是一个基于Node.js的静态博客框架，可以快速生成静态网页，并且支持Markdown语法。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>Hexo是基于Node.js的，所以我们需要先安装Node.js。可以从<a href="https://nodejs.org/zh-cn">Node.js官网</a>下载安装包，然后按照提示进行安装。</p><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>Git是一个分布式版本控制系统，可以用来管理代码。可以从<a href="https://git-scm.com/downloads">Git官网</a>下载安装包，然后按照提示进行安装。</p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>打开命令行工具，输入以下命令安装Hexo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h2 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h2><p>在命令行中输入以下命令，初始化Hexo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br></pre></td></tr></table></figure><p>其中，<code>&lt;folder&gt;</code>是你想要创建的博客文件夹的名称。例如，我想要创建一个名为<code>myblog</code>的博客文件夹，那么就输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init myblog</span><br></pre></td></tr></table></figure><p>然后进入该文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> myblog</span><br></pre></td></tr></table></figure><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>在命令行中输入以下命令，安装Hexo的依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><h2 id="Github创建博客仓库"><a href="#Github创建博客仓库" class="headerlink" title="Github创建博客仓库"></a>Github创建博客仓库</h2><p>在Github上创建一个仓库，用于存放Hexo生成的静态网页，在创建仓库时要注意：</p><ol><li>仓库名称必须为<code>&lt;username&gt;.github.io</code>，其中<code>&lt;username&gt;</code>是你的Github用户名。例如，我的Github用户名是<code>linvaux</code>，那么我就创建了一个名为<code>linvaux.github.io</code>的仓库。</li><li>仓库类型必须为<code>Public</code>。</li><li><a href="https://github.com/settings/keys">Github Profiles</a>中配置好sshKey。</li></ol><h1 id="安装主题-插件"><a href="#安装主题-插件" class="headerlink" title="安装主题&amp;插件"></a>安装主题&amp;插件</h1><p>Hexo支持很多主题，你可以根据自己的喜好选择。我选择的是Pure主题，也可以在<a href="https://hexo.io/themes/">Hexo官网</a>找到很多主题，安装Pure主题的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/cofess/hexo-theme-pure.git themes/pure</span><br></pre></td></tr></table></figure><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>Hexo支持很多插件，你可以根据自己的需求选择。我安装了以下几个插件：</p><ol><li><a href="https://github.com/willin/hexo-wordcount">hexo-wordcount</a>: 支持文章字数统计，阅读时长预估。</li><li><a href="https://github.com/rozbo/hexo-neat">hexo-neat</a>: 用于压缩HTML、CSS、JS文件，优化网站加载速度。</li><li><a href="https://github.com/ohroy/hexo-abbrlink">hexo-abbrlink</a>: 生成文章短链，不然默认是根据文章创建时间和标题生成的，不但长，而且如果文件名为中文，复制的URL是URL编码后的URL，不方便分享。</li><li><a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>: 用于将Hexo生成的静态网页部署到Github Pages上。</li></ol><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>在博客根目录下找到Hexo的配置文件<code>_config.yml</code>中，可以配置主题，例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此处主题名称要填写 themes文件夹下的主题名称，刚才安装主题的时候我们已经把主题名称改为了pure，所以这里要填写pure</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">pure</span></span><br></pre></td></tr></table></figure><h2 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h2><h3 id="hexo-deployer-git"><a href="#hexo-deployer-git" class="headerlink" title="hexo-deployer-git"></a>hexo-deployer-git</h3><p>在博客根目录下找到Hexo的配置文件<code>_config.yml</code>中，可以配置hexo-deployer-git插件，下面直接给出我的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其中，`repo`是你的Github仓库地址，`branch`是你的Github仓库分支。</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/linvaux/linvaux.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><h3 id="hexo-abbrlink"><a href="#hexo-abbrlink" class="headerlink" title="hexo-abbrlink"></a>hexo-abbrlink</h3><p>在博客根目录下找到Hexo的配置文件<code>_config.yml</code>中，可以配置hexo-abbrlink插件，下面直接给出我的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># permalink 是hexo的一个配置项，用于设置文章的永久链接格式，默认是 :year/:month/:day/:title/，这里我们使用 :abbrlink/，这样生成的链接会更短，更易于分享。</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink/</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>   </span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>     </span><br><span class="line">  <span class="attr">drafts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">auto_category:</span></span><br><span class="line">     <span class="attr">enable:</span> <span class="literal">true</span> </span><br><span class="line">     <span class="attr">depth:</span>         </span><br><span class="line">     <span class="attr">over_write:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">auto_title:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">auto_date:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">force:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="hexo-neat"><a href="#hexo-neat" class="headerlink" title="hexo-neat"></a>hexo-neat</h3><p>在博客根目录下找到Hexo的配置文件<code>_config.yml</code>中，可以配置hexo-neat插件，下面直接给出我的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hexo-neat</span></span><br><span class="line"><span class="attr">neat_enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">neat_html:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude:</span>  </span><br><span class="line"><span class="attr">neat_css:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;*.min.css&#x27;</span></span><br><span class="line"><span class="attr">neat_js:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mangle:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">output:</span></span><br><span class="line">  <span class="attr">compress:</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;*.min.js&#x27;</span> </span><br></pre></td></tr></table></figure><h3 id="hexo-wordcount"><a href="#hexo-wordcount" class="headerlink" title="hexo-wordcount"></a>hexo-wordcount</h3><p>hexo-wordcount插件配置在 themes&#x2F;pure&#x2F;_config.yml 中，pure默认带了这个配置，直接启用即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wordcount</span></span><br><span class="line"><span class="attr">postCount:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">wordcount:</span> <span class="literal">true</span>  <span class="comment"># 文章字数统计</span></span><br><span class="line">  <span class="attr">min2read:</span> <span class="literal">true</span>  <span class="comment"># 阅读时长预计 </span></span><br></pre></td></tr></table></figure><h1 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h1><ol><li>在博客根目录下输入以下命令，生成静态网页：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 也可以使用 hexo g 命令</span></span><br><span class="line">hexo generate</span><br></pre></td></tr></table></figure><ol start="2"><li>在博客根目录下输入以下命令，将生成的静态网页部署到Github Pages上：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 也可以使用 hexo d 命令</span></span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><ol start="3"><li><p>进入刚才创建的Github仓库，点击<code>Settings</code>，找到<code>GitHub Pages</code>，选择<code>main</code>分支，点击<code>Save</code>。可以参考下图：<br><img src="/../images/20240824223721.png"></p></li><li><p>打开浏览器，输入<code>https://&lt;username&gt;.github.io</code>，就可以看到你的博客了。</p></li></ol><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="使用pure主题，点击左边”about”-“tags”-等发现404"><a href="#使用pure主题，点击左边”about”-“tags”-等发现404" class="headerlink" title="使用pure主题，点击左边”about”, “tags” 等发现404"></a>使用pure主题，点击左边”about”, “tags” 等发现404</h2><p>直接使用如下命令生成静态网页：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其他页面类似</span></span><br><span class="line">hexo new page <span class="string">&quot;about&quot;</span></span><br></pre></td></tr></table></figure><h2 id="如何在本地预览"><a href="#如何在本地预览" class="headerlink" title="如何在本地预览"></a>如何在本地预览</h2><p>在博客根目录下输入以下命令，启动本地服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 也可以使用 hexo s 命令</span></span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>然后在浏览器中输入<code>http://localhost:4000</code>，就可以看到你的博客了。</p><h2 id="如何更新博客"><a href="#如何更新博客" class="headerlink" title="如何更新博客"></a>如何更新博客</h2><p>在博客根目录下输入以下命令，更新博客：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 也可以使用 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 命令</span></span><br><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><h2 id="如何备份博客"><a href="#如何备份博客" class="headerlink" title="如何备份博客"></a>如何备份博客</h2><p>hexo博客的备份其实很简单，只需要在博客目录下直接执行 <code>git init</code> 命令，然后添加远程仓库地址，最后执行 <code>git push</code> 命令即可。但是要注意，我们使用了 <code>git clone</code> 来安装主题，使用 <code>git add</code> 时可能会提示包含git子仓库，直接把主题下的 <code>.git</code> 文件夹删除即可。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://hexo.io/zh-cn/docs/">Hexo文档</a></li><li><a href="https://hexo.io/themes/">Hexo主题</a></li><li><a href="https://hexo.io/plugins/">Hexo插件</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我的个人博客之前是托管在 &lt;strong&gt;&lt;a href=&quot;https://geeknote.net/wick&quot;&gt;https://geekn</summary>
      
    
    
    
    
    <category term="随笔" scheme="https://linvaux.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Jmeter源码系列(5)-JmeterEngine-Jmeter的执行引擎</title>
    <link href="https://linvaux.github.io/posts/fbd833ae/"/>
    <id>https://linvaux.github.io/posts/fbd833ae/</id>
    <published>2024-08-04T04:41:26.000Z</published>
    <updated>2024-09-21T01:53:16.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h1><p>在前面的几篇文章中，笔者主要分析了Jmeter在Non-Gui模式下的启动过程，知道了jmeter在启动过程中会根据启动参数做各种初始化动作，最后通过以下代码来开始测试: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!remoteStart) &#123;</span><br><span class="line">    <span class="type">JMeterEngine</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardJMeterEngine</span>();</span><br><span class="line">    clonedTree.add(clonedTree.getArray()[<span class="number">0</span>], <span class="keyword">new</span> <span class="title class_">ListenToTest</span>(org.apache.jmeter.JMeter.ListenToTest.RunMode.LOCAL, <span class="literal">false</span>, reportGenerator));</span><br><span class="line">    engine.configure(clonedTree);</span><br><span class="line">    <span class="type">Instant</span> <span class="variable">now</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">    println(<span class="string">&quot;Starting standalone test @ &quot;</span> + formatLikeDate(now) + <span class="string">&quot; (&quot;</span> + now.toEpochMilli() + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    engines.add(engine);</span><br><span class="line">    engine.runTest();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    java.util.<span class="type">StringTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.StringTokenizer(remoteHostsString.trim(), <span class="string">&quot;,&quot;</span>);<span class="comment">//$NON-NLS-1$</span></span><br><span class="line">    List&lt;String&gt; hosts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (st.hasMoreElements()) &#123;</span><br><span class="line">        hosts.add(((String) st.nextElement()).trim());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListenToTest</span> <span class="variable">testListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListenToTest</span>(org.apache.jmeter.JMeter.ListenToTest.RunMode.REMOTE, remoteStop, reportGenerator);</span><br><span class="line">    clonedTree.add(clonedTree.getArray()[<span class="number">0</span>], testListener);</span><br><span class="line">    <span class="type">DistributedRunner</span> <span class="variable">distributedRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DistributedRunner</span>(<span class="built_in">this</span>.remoteProps);</span><br><span class="line">    distributedRunner.setStdout(System.out); <span class="comment">// NOSONAR</span></span><br><span class="line">    distributedRunner.setStdErr(System.err); <span class="comment">// NOSONAR</span></span><br><span class="line">    distributedRunner.init(hosts, clonedTree);</span><br><span class="line">    engines.addAll(distributedRunner.getEngines());</span><br><span class="line">    testListener.setStartedRemoteEngines(engines);</span><br><span class="line">    distributedRunner.start();</span><br><span class="line">&#125;</span><br><span class="line">startUdpDdaemon(engines);</span><br></pre></td></tr></table></figure><p>在上面的代码中可以看到，如果是本地执行，则创建一个 StandardJMeterEngine 实例，并调用其 configure 和 runTest 方法来执行测试计划。如果是远程执行，则创建一个 DistributedRunner 实例，并调用其 init 和 start 方法来启动远程引擎并执行测试计划。</p><h1 id="JMeterEngine"><a href="#JMeterEngine" class="headerlink" title="JMeterEngine"></a>JMeterEngine</h1><p>JMeterEngine是Jmeter的执行引擎，它负责执行测试计划，并管理测试计划中的各种组件，如线程组、采样器、监听器等。</p><p>JMeterEngine接口定义了以下方法：</p><ul><li><code>void configure(HashTree testPlan)</code>：配置测试计划，将测试计划中的各种组件添加到执行引擎中。</li><li><code>void runTest() throws JMeterEngineException</code>：运行测试计划。</li><li><code>default void stopTest() &#123;stopTest(true);&#125;</code>：立即停止测试计划。</li><li><code>void stopTest(boolean now)</code>: 停止测试计划，如果now为true，则立即停止测试计划，否则等待测试计划完成。</li><li><code>void reset()</code>：重置执行引擎，清除所有测试计划中的组件。</li><li><code>void setProperties(Properties p)</code>: 设置执行引擎的属性。</li><li><code>void exit()</code>: 退出执行引擎。</li><li><code>boolean isActive()</code>: 判断执行引擎是否正在运行。</li></ul><p><code>JMeterEngine</code>接口的实现类有<code>StandardJMeterEngine</code>和<code>ClientJMeterEngine</code>，其实大家在看Jmeter源代码时，可能会发现还有一个<code>EmulatorEngine</code>类实现了<code>JMeterEngine</code>, 这个类其实位于<code>org.apache.jmeter.engine.DistributedRunnerTest.EmulatorEngine</code> 是一个用于测试的类，并非是Jmeter的正式实现。</p><h2 id="StandardJMeterEngine"><a href="#StandardJMeterEngine" class="headerlink" title="StandardJMeterEngine"></a>StandardJMeterEngine</h2><p>StandardJMeterEngine 是 JMeter 的标准引擎实现，主要用于在单独的 JMeter 服务器或本地机器上执行性能测试。类定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StandardJMeterEngine</span> <span class="keyword">implements</span> <span class="title class_">JMeterEngine</span>, Runnable</span><br></pre></td></tr></table></figure><p>StandardJMeterEngine 除了实现 JmeterEngine 接口外，还实现了 Runnable 接口，因此它可以被提交到一个线程池中执行。接下来，我们可以从<code>engine.configure(clonedTree)</code> 和 <code>engine.runTest()</code> 为入口来分析 StandardJMeterEngine 的执行过程。</p><h3 id="configure"><a href="#configure" class="headerlink" title="configure"></a>configure</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HashTree testTree)</span> &#123;</span><br><span class="line">    <span class="comment">// Is testplan serialised?</span></span><br><span class="line">    SearchByClass&lt;TestPlan&gt; testPlan = <span class="keyword">new</span> <span class="title class_">SearchByClass</span>&lt;&gt;(TestPlan.class);</span><br><span class="line">    testTree.traverse(testPlan);</span><br><span class="line">    Object[] plan = testPlan.getSearchResults().toArray();</span><br><span class="line">    <span class="keyword">if</span> (plan.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Could not find the TestPlan class!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TestPlan</span> <span class="variable">tp</span> <span class="operator">=</span> (TestPlan) plan[<span class="number">0</span>];</span><br><span class="line">    serialized = tp.isSerialized();</span><br><span class="line">    tearDownOnShutdown = tp.isTearDownOnShutdown();</span><br><span class="line">    active = <span class="literal">true</span>;</span><br><span class="line">    test = testTree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>configure方法执行过程如下：</p><ol><li>从testTree中查找TestPlan对象，如果找不到，则抛出异常。<code>testTree.traverse(testPlan)</code> 的作用是遍历 HashTree 对象中的内容，并根据提供的 SearchByClass 对象对每个节点进行检查或搜索。其实<code>HashTree#traverse</code>使用了访问者模式，<code>SearchByClass</code>类实现了<code>HashTreeTraverser</code>接口，通过实现此接口，类可以轻松遍历 HashTree 对象，并通过某些事件的回调获得通知。</li><li>获取TestPlan对象的serialized和tearDownOnShutdown属性，并设置到StandardJMeterEngine对象中。</li><li>设置StandardJMeterEngine对象的active属性为true，表示引擎已经准备好执行测试计划。</li><li>将testTree赋值给StandardJMeterEngine对象的test属性，以便在执行测试计划时使用。</li></ol><h3 id="runTest"><a href="#runTest" class="headerlink" title="runTest"></a>runTest</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runTest</span><span class="params">()</span> <span class="keyword">throws</span> JMeterEngineException &#123;</span><br><span class="line">    <span class="keyword">if</span> (host != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">Instant</span> <span class="variable">now</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">        <span class="type">String</span> <span class="variable">nowAsString</span> <span class="operator">=</span> formatLikeDate(now);</span><br><span class="line">        System.out.println(<span class="string">&quot;Starting the test on host &quot;</span>  <span class="comment">// NOSONAR Intentional</span></span><br><span class="line">                + host + <span class="string">&quot; @ &quot;</span> + nowAsString + <span class="string">&quot; (&quot;</span> + now.toEpochMilli() + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        runningTest = EXECUTOR_SERVICE.submit(<span class="built_in">this</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception err) &#123;</span><br><span class="line">        stopTest();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JMeterEngineException</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>runTest方法执行过程如下：</p><ol><li>如果StandardJMeterEngine对象的host属性不为null，则打印一条日志，记录测试开始的时间和主机信息。</li><li>调用EXECUTOR_SERVICE.submit(this)方法将StandardJMeterEngine对象提交到一个线程池中执行。EXECUTOR_SERVICE是一个线程池，用于执行StandardJMeterEngine对象的run方法。线程池定义如下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程安全的计数器，用于在创建线程时生成唯一的线程名</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">THREAD_COUNTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行器服务，用于执行“启动测试”、“停止测试”等管理任务。使用 ExecutorService 允许从线程传播异常。线程保持alive时间设置为 1 秒，因此线程会提前释放，因此应用程序可以更快地关闭。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">EXECUTOR_SERVICE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        Integer.MAX_VALUE,</span><br><span class="line">        <span class="number">1L</span>,</span><br><span class="line">        TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">java</span>.util.concurrent.SynchronousQueue&lt;&gt;(),</span><br><span class="line">        (runnable) -&gt; <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable, <span class="string">&quot;StandardJMeterEngine-&quot;</span> + THREAD_COUNTER.incrementAndGet()));</span><br></pre></td></tr></table></figure><ol start="3"><li>如果提交线程池失败，则调用stopTest方法停止测试，并抛出JMeterEngineException异常。</li></ol><p>至此，StandardJMeterEngine对象的runTest方法执行完毕，测试计划开始执行。那接下来我们就需要看下StandardJMeterEngine对象的run方法了。</p><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>先贴一个完整方法定义，然后再逐步分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;Running the test!&quot;</span>);</span><br><span class="line">    running = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that the sample variables are correctly initialised for each run.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SampleEvent.initSampleVariables();</span><br><span class="line">    JMeterContextService.startTest();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">PreCompiler</span> <span class="variable">compiler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PreCompiler</span>();</span><br><span class="line">        test.traverse(compiler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Error occurred compiling the tree:&quot;</span>, e);</span><br><span class="line">        JMeterUtils.reportErrorToUser(<span class="string">&quot;Error occurred compiling the tree: - see log file&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// no point continuing</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Notification of test listeners needs to happen after function</span></span><br><span class="line"><span class="comment">     * replacement, but before setting RunningVersion to true.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SearchByClass&lt;TestStateListener&gt; testListeners = <span class="keyword">new</span> <span class="title class_">SearchByClass</span>&lt;&gt;(TestStateListener.class); <span class="comment">// TL - S&amp;E</span></span><br><span class="line">    test.traverse(testListeners);</span><br><span class="line">    <span class="comment">// Merge in any additional test listeners</span></span><br><span class="line">    <span class="comment">// currently only used by the function parser</span></span><br><span class="line">    testListeners.getSearchResults().addAll(testList);</span><br><span class="line">    testList.clear(); <span class="comment">// no longer needed</span></span><br><span class="line">    test.traverse(<span class="keyword">new</span> <span class="title class_">TurnElementsOn</span>());</span><br><span class="line">    notifyTestListenersOfStart(testListeners);</span><br><span class="line">    List&lt;?&gt; testLevelElements = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(test.list(test.getArray()[<span class="number">0</span>]));</span><br><span class="line">    removeThreadGroups(testLevelElements);</span><br><span class="line">    SearchByClass&lt;SetupThreadGroup&gt; setupSearcher = <span class="keyword">new</span> <span class="title class_">SearchByClass</span>&lt;&gt;(SetupThreadGroup.class);</span><br><span class="line">    SearchByClass&lt;AbstractThreadGroup&gt; searcher = <span class="keyword">new</span> <span class="title class_">SearchByClass</span>&lt;&gt;(AbstractThreadGroup.class);</span><br><span class="line">    SearchByClass&lt;PostThreadGroup&gt; postSearcher = <span class="keyword">new</span> <span class="title class_">SearchByClass</span>&lt;&gt;(PostThreadGroup.class);</span><br><span class="line">    test.traverse(setupSearcher);</span><br><span class="line">    test.traverse(searcher);</span><br><span class="line">    test.traverse(postSearcher);</span><br><span class="line">    TestCompiler.initialize();</span><br><span class="line">    <span class="comment">// for each thread group, generate threads</span></span><br><span class="line">    <span class="comment">// hand each thread the sampler controller</span></span><br><span class="line">    <span class="comment">// and the listeners, and the timer</span></span><br><span class="line">    Iterator&lt;SetupThreadGroup&gt; setupIter = setupSearcher.getSearchResults().iterator();</span><br><span class="line">    Iterator&lt;AbstractThreadGroup&gt; iter = searcher.getSearchResults().iterator();</span><br><span class="line">    Iterator&lt;PostThreadGroup&gt; postIter = postSearcher.getSearchResults().iterator();</span><br><span class="line">    <span class="type">ListenerNotifier</span> <span class="variable">notifier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListenerNotifier</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">groupCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    JMeterContextService.clearTotalThreads();</span><br><span class="line">    <span class="keyword">if</span> (setupIter.hasNext()) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Starting setUp thread groups&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (running &amp;&amp; setupIter.hasNext()) &#123;<span class="comment">//for each setup thread group</span></span><br><span class="line">            <span class="type">AbstractThreadGroup</span> <span class="variable">group</span> <span class="operator">=</span> setupIter.next();</span><br><span class="line">            groupCount++;</span><br><span class="line">            <span class="type">String</span> <span class="variable">groupName</span> <span class="operator">=</span> group.getName();</span><br><span class="line">            log.info(<span class="string">&quot;Starting setUp ThreadGroup: &#123;&#125; : &#123;&#125; &quot;</span>, groupCount, groupName);</span><br><span class="line">            startThreadGroup(group, groupCount, setupSearcher, testLevelElements, notifier);</span><br><span class="line">            <span class="keyword">if</span> (serialized &amp;&amp; setupIter.hasNext()) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;Waiting for setup thread group: &#123;&#125; to finish before starting next setup group&quot;</span>,</span><br><span class="line">                        groupName);</span><br><span class="line">                group.waitThreadsStopped();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;Waiting for all setup thread groups to exit&quot;</span>);</span><br><span class="line">        <span class="comment">//wait for all Setup Threads To Exit</span></span><br><span class="line">        waitThreadsStopped();</span><br><span class="line">        log.info(<span class="string">&quot;All Setup Threads have ended&quot;</span>);</span><br><span class="line">        groupCount = <span class="number">0</span>;</span><br><span class="line">        JMeterContextService.clearTotalThreads();</span><br><span class="line">    &#125;</span><br><span class="line">    groups.clear(); <span class="comment">// The groups have all completed now</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Here&#x27;s where the test really starts. Run a Full GC now: it&#x27;s no harm</span></span><br><span class="line"><span class="comment">     * at all (just delays test start by a tiny amount) and hitting one too</span></span><br><span class="line"><span class="comment">     * early in the test can impair results for short tests.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    JMeterUtils.helpGC();</span><br><span class="line">    JMeterContextService.getContext().setSamplingStarted(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">mainGroups</span> <span class="operator">=</span> running; <span class="comment">// still running at this point, i.e. setUp was not cancelled</span></span><br><span class="line">    <span class="keyword">while</span> (running &amp;&amp; iter.hasNext()) &#123;<span class="comment">// for each thread group</span></span><br><span class="line">        <span class="type">AbstractThreadGroup</span> <span class="variable">group</span> <span class="operator">=</span> iter.next();</span><br><span class="line">        <span class="comment">//ignore Setup and Post here.  We could have filtered the searcher. but then</span></span><br><span class="line">        <span class="comment">//future Thread Group objects wouldn&#x27;t execute.</span></span><br><span class="line">        <span class="keyword">if</span> (group <span class="keyword">instanceof</span> SetupThreadGroup ||</span><br><span class="line">                group <span class="keyword">instanceof</span> PostThreadGroup) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        groupCount++;</span><br><span class="line">        <span class="type">String</span> <span class="variable">groupName</span> <span class="operator">=</span> group.getName();</span><br><span class="line">        log.info(<span class="string">&quot;Starting ThreadGroup: &#123;&#125; : &#123;&#125;&quot;</span>, groupCount, groupName);</span><br><span class="line">        startThreadGroup(group, groupCount, searcher, testLevelElements, notifier);</span><br><span class="line">        <span class="keyword">if</span> (serialized &amp;&amp; iter.hasNext()) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;Waiting for thread group: &#123;&#125; to finish before starting next group&quot;</span>, groupName);</span><br><span class="line">            group.waitThreadsStopped();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// end of thread groups</span></span><br><span class="line">    <span class="keyword">if</span> (groupCount == <span class="number">0</span>) &#123; <span class="comment">// No TGs found</span></span><br><span class="line">        log.info(<span class="string">&quot;No enabled thread groups found&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (running) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;All thread groups have been started&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;Test stopped - no more thread groups will be started&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//wait for all Test Threads To Exit</span></span><br><span class="line">    waitThreadsStopped();</span><br><span class="line">    groups.clear(); <span class="comment">// The groups have all completed now</span></span><br><span class="line">    <span class="keyword">if</span> (postIter.hasNext()) &#123;</span><br><span class="line">        groupCount = <span class="number">0</span>;</span><br><span class="line">        JMeterContextService.clearTotalThreads();</span><br><span class="line">        log.info(<span class="string">&quot;Starting tearDown thread groups&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (mainGroups &amp;&amp; !running) &#123; <span class="comment">// i.e. shutdown/stopped during main thread groups</span></span><br><span class="line">            running = tearDownOnShutdown; <span class="comment">// re-enable for tearDown if necessary</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (running &amp;&amp; postIter.hasNext()) &#123;<span class="comment">//for each setup thread group</span></span><br><span class="line">            <span class="type">AbstractThreadGroup</span> <span class="variable">group</span> <span class="operator">=</span> postIter.next();</span><br><span class="line">            groupCount++;</span><br><span class="line">            <span class="type">String</span> <span class="variable">groupName</span> <span class="operator">=</span> group.getName();</span><br><span class="line">            log.info(<span class="string">&quot;Starting tearDown ThreadGroup: &#123;&#125; : &#123;&#125;&quot;</span>, groupCount, groupName);</span><br><span class="line">            startThreadGroup(group, groupCount, postSearcher, testLevelElements, notifier);</span><br><span class="line">            <span class="keyword">if</span> (serialized &amp;&amp; postIter.hasNext()) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;Waiting for post thread group: &#123;&#125; to finish before starting next post group&quot;</span>, groupName);</span><br><span class="line">                group.waitThreadsStopped();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        waitThreadsStopped(); <span class="comment">// wait for Post threads to stop</span></span><br><span class="line">    &#125;</span><br><span class="line">    notifyTestListenersOfEnd(testListeners);</span><br><span class="line">    JMeterContextService.endTest();</span><br><span class="line">    <span class="keyword">if</span> (JMeter.isNonGUI() &amp;&amp; SYSTEM_EXIT_FORCED) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Forced JVM shutdown requested at end of test&quot;</span>);</span><br><span class="line">        System.exit(<span class="number">0</span>); <span class="comment">// NOSONAR Intentional</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>初始化与日志记录:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;Running the test!&quot;</span>);</span><br><span class="line">running = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>测试开始，并且设置一个标志表明测试正在运行。</p><ol start="2"><li>采样器变量初始化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SampleEvent.initSampleVariables();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initSampleVariables</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">vars</span> <span class="operator">=</span> JMeterUtils.getProperty(SAMPLE_VARIABLES);</span><br><span class="line">    variableNames = vars != <span class="literal">null</span> ? vars.split(<span class="string">&quot;,&quot;</span>) : <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;List of sample_variables: &#123;&#125;&quot;</span>, Arrays.toString(variableNames));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化采样器变量，这些变量将在测试期间用于存储和访问采样数据，</p><ol start="3"><li>JMeterContextService 标记测试开始</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JMeterContextService.startTest();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">startTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (testStart.get() == <span class="number">0</span>) &#123;</span><br><span class="line">        NUMBER_OF_ACTIVE_THREADS.set(<span class="number">0</span>);</span><br><span class="line">        testStart.set(System.currentTimeMillis());</span><br><span class="line">        JMeterUtils.setProperty(<span class="string">&quot;TESTSTART.MS&quot;</span>, Long.toString(testStart.get()));<span class="comment">// $NON-NLS-1$</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个同步的静态方法作用如下：</p><ul><li>检查测试是否已经开始:<br>使用原子变量 testStart（类型为 AtomicLong）来检查测试是否已经开始了。如果 testStart 的值为0，说明测试尚未开始。其实在测试结束后，也会通过调用 JMeterContextService.endTest() 方法将 testStart 的值重置为0。</li><li>设置活跃线程数:<br>将 NUMBER_OF_ACTIVE_THREADS（也是 AtomicInteger 类型）设置为0，这通常用于跟踪活跃的线程数量。在测试开始时将其重置，以便正确地计数参与测试的线程。</li><li>记录测试开始时间:<br>设置 testStart 的值为当前时间戳（毫秒级）。这提供了测试开始的基准时间，对于分析测试结果和监控性能指标非常有用。</li><li>保存测试开始时间到属性:<br>将测试开始的时间戳保存到 JMeter 属性中，键为 “TESTSTART.MS”。这使得测试开始时间可以在测试过程中被其他部分引用，例如在日志记录或结果报告中。</li></ul><p>通过调用 startTest() 方法，JMeter 能够确保每个测试运行都有一个明确的起点，这对于统计和报告测试期间的性能指标非常重要。在多线程环境中，由于该方法被声明为 synchronized，可以保证即使有多个线程同时尝试调用它，也只会有一个线程能够进入方法体，从而避免了并发修改 testStart 或 NUMBER_OF_ACTIVE_THREADS 变量可能引发的问题。</p><ol start="4"><li>HashTree预编译</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">PreCompiler</span> <span class="variable">compiler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PreCompiler</span>();</span><br><span class="line">    test.traverse(compiler);</span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;Error occurred compiling the tree:&quot;</span>, e);</span><br><span class="line">    JMeterUtils.reportErrorToUser(<span class="string">&quot;Error occurred compiling the tree: - see log file&quot;</span>, e);</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// no point continuing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然代码就两三行，但是里面的信息量是非常大的，HashTree 是 JMeter 的核心数据结构，它存储了所有测试组件的配置信息，包括线程组、采样器、监听器等。在测试开始之前，JMeter 会遍历整个 HashTree，对每个组件进行预编译，以便在测试运行时能够快速地访问和执行这些组件。预编译的过程其实就是变量替换的过程，它将配置文件中的变量替换为实际的值，以便在测试运行时能够正确地使用这些变量。预编译是 JMeter 性能优化的关键之一，因为它可以减少测试运行时的计算量，提高测试的执行效率。然而，需要注意的是，某些动态值（如随机数或基于时间的值或参数化的变量等）在预编译时只能计算一次，这意味着如果需要在每次采样时都有不同的值，那么这些函数将不能完全预编译，而是在每次采样时重新计算。预编译会调用<code>org.apache.jmeter.engine.PreCompiler#addNode</code> 方法，其中涉及到一个非常重要的类，叫做 <code>org.apache.jmeter.engine.util.ValueReplacer</code>，变量替换就由它实现。由于篇幅有限，不在此处展开讲变量替换的过程，在后面讲Jmeter核心类的文章中会讲解此类。此处我们只要知道这段代码做什么就行了。</p><ol start="5"><li>通知监听器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Notification of test listeners needs to happen after function</span></span><br><span class="line"><span class="comment"> * replacement, but before setting RunningVersion to true.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SearchByClass&lt;TestStateListener&gt; testListeners = <span class="keyword">new</span> <span class="title class_">SearchByClass</span>&lt;&gt;(TestStateListener.class); <span class="comment">// TL - S&amp;E</span></span><br><span class="line">test.traverse(testListeners);</span><br><span class="line"><span class="comment">// Merge in any additional test listeners</span></span><br><span class="line"><span class="comment">// currently only used by the function parser</span></span><br><span class="line">testListeners.getSearchResults().addAll(testList);</span><br><span class="line">testList.clear(); <span class="comment">// no longer needed</span></span><br><span class="line">test.traverse(<span class="keyword">new</span> <span class="title class_">TurnElementsOn</span>());</span><br><span class="line">notifyTestListenersOfStart(testListeners);</span><br></pre></td></tr></table></figure><p>遍历测试计划树，收集所有的<code>org.apache.jmeter.testelement.TestStateListener</code>实例，并激活所有测试元素，准备它们的运行状态，然后通知这些监听器(实现了TestStateListener接口的类)测试即将开始。TestStateListener 是 JMeter 中用于监听测试状态变化的接口，它定义了在测试开始、结束以及每个采样周期开始和结束时需要执行的方法。通过调用 notifyTestListenersOfStart() 方法，JMeter 可以确保所有注册的 TestStateListener 都能够接收到测试开始的通知，并执行相应的操作。发送测试开始通知的方法是 <code>org.apache.jmeter.engine.StandardJMeterEngine#notifyTestListenersOfStart</code>。</p><ol start="6"><li>准备测试元素</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; testLevelElements = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(test.list(test.getArray()[<span class="number">0</span>]));</span><br><span class="line">removeThreadGroups(testLevelElements);</span><br><span class="line">SearchByClass&lt;SetupThreadGroup&gt; setupSearcher = <span class="keyword">new</span> <span class="title class_">SearchByClass</span>&lt;&gt;(SetupThreadGroup.class);</span><br><span class="line">SearchByClass&lt;AbstractThreadGroup&gt; searcher = <span class="keyword">new</span> <span class="title class_">SearchByClass</span>&lt;&gt;(AbstractThreadGroup.class);</span><br><span class="line">SearchByClass&lt;PostThreadGroup&gt; postSearcher = <span class="keyword">new</span> <span class="title class_">SearchByClass</span>&lt;&gt;(PostThreadGroup.class);</span><br><span class="line">test.traverse(setupSearcher);</span><br><span class="line">test.traverse(searcher);</span><br><span class="line">test.traverse(postSearcher);</span><br><span class="line">TestCompiler.initialize();</span><br></pre></td></tr></table></figure><ul><li>这里首先获取测试计划的顶层元素列表。test 对象代表的是测试计划 (TestPlan)，test.getArray()[0] 获取的是测试计划数组中的第一个元素，通常这是测试计划的根元素。然后通过调用 list() 方法获取与该元素关联的所有子元素，并将这些子元素放入一个 ArrayList 中。由于类型不确定，所以列表的类型声明为 List&lt;?&gt;。</li><li>接下来，调用 removeThreadGroups() 方法从列表中移除所有线程组。线程组是 JMeter 中用于控制测试并发性的组件，它定义了测试中并发线程的数量以及每个线程的行为。在测试计划中，线程组通常位于顶层元素之下，因此需要从顶层元素列表中移除它们，以便后续的遍历操作不会重复处理线程组。</li><li>然后，创建三个 SearchByClass 对象，分别用于搜索 SetupThreadGroup、AbstractThreadGroup 和 PostThreadGroup 类型的元素。这些类都是 JMeter 中用于控制测试设置和清理的组件，它们定义了在测试开始之前和结束之后需要执行的操作。</li><li>接下来，调用 test.traverse() 方法遍历测试计划树，将 SetupThreadGroup 类型的元素添加到 setupSearcher 的结果列表中，将 AbstractThreadGroup 类型的元素添加到 searcher 的结果列表中，将 PostThreadGroup 类型的元素添加到 postSearcher 的结果列表中。</li><li>最后，调用 TestCompiler.initialize() 方法初始化测试编译器。测试编译器是 JMeter 中用于将测试计划转换为可执行代码的组件，它将测试计划中的元素转换为相应的 Java 代码，以便在测试执行期间执行。初始化测试编译器是执行测试之前的必要步骤，它确保测试编译器已经准备好处理测试计划中的元素。<strong>划重点：TestCompiler.initialize() 方法是 JMeter 中用于初始化测试编译器的静态方法，它将测试计划中的元素转换为相应的 Java 代码，以便在测试执行期间执行。初始化测试编译器是执行测试之前的必要步骤，它确保测试编译器已经准备好处理测试计划中的元素。大家如果有兴趣，可以使用文本工具打开一个jmx文件看下，里面<code>ThreadGroup</code>标签有两个属性<code>guiClass</code> 和 <code>testclass</code> 在&lt;jmeter安装路径&gt;&#x2F;bin&#x2F;saveservice.properties 文件中就定义了这些标签名和全限定类名的映射关系，当然，其他组件也是类似。</strong></li></ul><ol start="7"><li>准备线程组，开始预热</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;SetupThreadGroup&gt; setupIter = setupSearcher.getSearchResults().iterator();</span><br><span class="line">Iterator&lt;AbstractThreadGroup&gt; iter = searcher.getSearchResults().iterator();</span><br><span class="line">Iterator&lt;PostThreadGroup&gt; postIter = postSearcher.getSearchResults().iterator();</span><br><span class="line"><span class="type">ListenerNotifier</span> <span class="variable">notifier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListenerNotifier</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">groupCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">JMeterContextService.clearTotalThreads();</span><br><span class="line"><span class="keyword">if</span> (setupIter.hasNext()) &#123;</span><br><span class="line">    log.info(<span class="string">&quot;Starting setUp thread groups&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (running &amp;&amp; setupIter.hasNext()) &#123;<span class="comment">//for each setup thread group</span></span><br><span class="line">        <span class="type">AbstractThreadGroup</span> <span class="variable">group</span> <span class="operator">=</span> setupIter.next();</span><br><span class="line">        groupCount++;</span><br><span class="line">        <span class="type">String</span> <span class="variable">groupName</span> <span class="operator">=</span> group.getName();</span><br><span class="line">        log.info(<span class="string">&quot;Starting setUp ThreadGroup: &#123;&#125; : &#123;&#125; &quot;</span>, groupCount, groupName);</span><br><span class="line">        startThreadGroup(group, groupCount, setupSearcher, testLevelElements, notifier);</span><br><span class="line">        <span class="keyword">if</span> (serialized &amp;&amp; setupIter.hasNext()) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;Waiting for setup thread group: &#123;&#125; to finish before starting next setup group&quot;</span>,</span><br><span class="line">                    groupName);</span><br><span class="line">            group.waitThreadsStopped();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;Waiting for all setup thread groups to exit&quot;</span>);</span><br><span class="line">    <span class="comment">//wait for all Setup Threads To Exit</span></span><br><span class="line">    waitThreadsStopped();</span><br><span class="line">    log.info(<span class="string">&quot;All Setup Threads have ended&quot;</span>);</span><br><span class="line">    groupCount = <span class="number">0</span>;</span><br><span class="line">    JMeterContextService.clearTotalThreads();</span><br><span class="line">&#125;</span><br><span class="line">groups.clear();</span><br></pre></td></tr></table></figure><ul><li>首先，创建三个 Iterator 对象，分别用于遍历 setupSearcher、searcher 和 postSearcher 的结果列表。这些 Iterator 对象用于遍历测试计划树中找到的 SetupThreadGroup、AbstractThreadGroup 和 PostThreadGroup 类型的元素。</li><li>接下来，创建一个 ListenerNotifier 对象，用于通知监听器测试执行的状态。ListenerNotifier 是 JMeter 中用于通知监听器测试执行状态的组件，它将测试执行的状态信息传递给监听器，以便它们可以执行相应的操作。在测试执行期间，ListenerNotifier 对象会不断更新测试执行的状态，并将状态信息传递给监听器。</li><li>然后，获取测试计划树中找到的线程组的数量，并将其存储在 groupCount 变量中。groupCount 变量用于记录测试计划树中找到的线程组的数量，以便在测试执行期间进行计数。</li><li>接下来，调用 JMeterContextService.clearTotalThreads() 方法清除 JMeter 上下文中的总线程数。JMeterContextService 是 JMeter 中用于管理 JMeter 上下文的组件，它提供了许多与 JMeter 上下文相关的操作，例如获取和设置上下文属性、获取和设置上下文中的线程数等。调用 JMeterContextService.clearTotalThreads() 方法可以清除 JMeter 上下文中的总线程数，以便在测试执行期间重新计算总线程数。</li><li>然后，判断是否需要执行 setup 线程组。如果有下一个 setup 线程组，则进入 while 循环，循环执行 setup 线程组的启动操作。SetupThreadGroup 通常用于在测试开始前执行一些预处理任务，如数据库连接、服务器预热等。</li><li>如果没有线程组，或者setup线程组执行完了，则调用<code>groups.clear()</code>清理groups集合。</li></ul><ol start="8"><li>执行前，扫个地</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JMeterUtils.helpGC();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">helpGC</span><span class="params">()</span> &#123;</span><br><span class="line">    System.gc(); <span class="comment">// NOSONAR Intentional</span></span><br><span class="line">    System.runFinalization();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jmeter真正开始执行前，调用<code>System.gc()</code>和<code>System.runFinalization()</code>方法，以帮助 JVM 进行垃圾回收和运行终结器。这些方法可以减少内存泄漏和垃圾堆积的问题，从而提高测试的稳定性和性能。</p><ol start="9"><li>开始执行</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">JMeterContextService.getContext().setSamplingStarted(<span class="literal">true</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">mainGroups</span> <span class="operator">=</span> running; <span class="comment">// still running at this point, i.e. setUp was not cancelled</span></span><br><span class="line"><span class="keyword">while</span> (running &amp;&amp; iter.hasNext()) &#123;<span class="comment">// for each thread group</span></span><br><span class="line">    <span class="type">AbstractThreadGroup</span> <span class="variable">group</span> <span class="operator">=</span> iter.next();</span><br><span class="line">    <span class="comment">//ignore Setup and Post here.  We could have filtered the searcher. but then</span></span><br><span class="line">    <span class="comment">//future Thread Group objects wouldn&#x27;t execute.</span></span><br><span class="line">    <span class="keyword">if</span> (group <span class="keyword">instanceof</span> SetupThreadGroup || group <span class="keyword">instanceof</span> PostThreadGroup) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    groupCount++;</span><br><span class="line">    <span class="type">String</span> <span class="variable">groupName</span> <span class="operator">=</span> group.getName();</span><br><span class="line">    log.info(<span class="string">&quot;Starting ThreadGroup: &#123;&#125; : &#123;&#125;&quot;</span>, groupCount, groupName);</span><br><span class="line">    startThreadGroup(group, groupCount, searcher, testLevelElements, notifier);</span><br><span class="line">    <span class="keyword">if</span> (serialized &amp;&amp; iter.hasNext()) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Waiting for thread group: &#123;&#125; to finish before starting next group&quot;</span>, groupName);</span><br><span class="line">        group.waitThreadsStopped();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// end of thread groups</span></span><br><span class="line"><span class="keyword">if</span> (groupCount == <span class="number">0</span>) &#123; <span class="comment">// No TGs found</span></span><br><span class="line">    log.info(<span class="string">&quot;No enabled thread groups found&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (running) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;All thread groups have been started&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Test stopped - no more thread groups will be started&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//wait for all Test Threads To Exit</span></span><br><span class="line">waitThreadsStopped();</span><br><span class="line">groups.clear(); <span class="comment">// The groups have all completed now</span></span><br></pre></td></tr></table></figure><p>这段代码用于真正的拉起线程组（非 setup&#x2F;post 线程组）执行测试，在测试线程组开始执行前，JMeterContextService 会设置采样器状态为 true，即测试开始了，监听器可以开始收集数据了。 等线程组结束后，继续把线程组清理掉。</p><ol start="10"><li>线程组执行结束，扫地</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (postIter.hasNext()) &#123;</span><br><span class="line">    groupCount = <span class="number">0</span>;</span><br><span class="line">    JMeterContextService.clearTotalThreads();</span><br><span class="line">    log.info(<span class="string">&quot;Starting tearDown thread groups&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (mainGroups &amp;&amp; !running) &#123; <span class="comment">// i.e. shutdown/stopped during main thread groups</span></span><br><span class="line">        running = tearDownOnShutdown; <span class="comment">// re-enable for tearDown if necessary</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (running &amp;&amp; postIter.hasNext()) &#123;<span class="comment">//for each setup thread group</span></span><br><span class="line">        <span class="type">AbstractThreadGroup</span> <span class="variable">group</span> <span class="operator">=</span> postIter.next();</span><br><span class="line">        groupCount++;</span><br><span class="line">        <span class="type">String</span> <span class="variable">groupName</span> <span class="operator">=</span> group.getName();</span><br><span class="line">        log.info(<span class="string">&quot;Starting tearDown ThreadGroup: &#123;&#125; : &#123;&#125;&quot;</span>, groupCount, groupName);</span><br><span class="line">        startThreadGroup(group, groupCount, postSearcher, testLevelElements, notifier);</span><br><span class="line">        <span class="keyword">if</span> (serialized &amp;&amp; postIter.hasNext()) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;Waiting for post thread group: &#123;&#125; to finish before starting next post group&quot;</span>, groupName);</span><br><span class="line">            group.waitThreadsStopped();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    waitThreadsStopped(); <span class="comment">// wait for Post threads to stop</span></span><br><span class="line">&#125;</span><br><span class="line">notifyTestListenersOfEnd(testListeners);</span><br><span class="line">JMeterContextService.endTest();</span><br><span class="line"><span class="keyword">if</span> (JMeter.isNonGUI() &amp;&amp; SYSTEM_EXIT_FORCED) &#123;</span><br><span class="line">    log.info(<span class="string">&quot;Forced JVM shutdown requested at end of test&quot;</span>);</span><br><span class="line">    System.exit(<span class="number">0</span>); <span class="comment">// NOSONAR Intentional</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>post线程组类似于我们写ut时的teardown，在测试结束后，执行一些清理工作，比如关闭文件、关闭数据库连接等。PostThreadGroup 执行结束后，又会通知监听器，测试结束了，然后重置线程数为0。最后再根据配置来看在Non-Gui模式下是否需要终止进程。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，StandardJMeterEngine 的执行流程就分析完了。整个执行过程可以简短概括为：</p><ol><li>初始化测试</li><li>执行setup线程组</li><li>执行测试线程组</li><li>执行post线程组</li><li>执行结束</li></ol><h2 id="ClientJMeterEngine"><a href="#ClientJMeterEngine" class="headerlink" title="ClientJMeterEngine"></a>ClientJMeterEngine</h2><p>ClientJMeterEngine 是 JMeter 的客户端执行引擎，它主要负责在远程模式下，执行远程服务器上的测试计划。在执行远程测试时，ClientJMeterEngine#runTest 被非像本地测试一样被直接调用，而是通过<code>org.apache.jmeter.engine.DistributedRunner#start(java.util.List&lt;java.lang.String&gt;)</code>来被调用。此处我们只分析ClientJMeterEngine 的 runTest 方法。先不关注 DistributedRunner 是如何分发测试任务的。接下来我们还是从 <code>configure</code> 和 <code>runTest</code> 两个方法来入手分析</p><h3 id="configure-1"><a href="#configure-1" class="headerlink" title="configure"></a>configure</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HashTree testTree)</span> &#123;</span><br><span class="line">    <span class="type">TreeCloner</span> <span class="variable">cloner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeCloner</span>(<span class="literal">false</span>);</span><br><span class="line">    testTree.traverse(cloner);</span><br><span class="line">    test = cloner.getClonedTree();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ClientJMeterEngine#configure</code> 方法实现很简单，就是克隆一份测试计划，然后赋值给HashTree test，这个test对象会在<code>org.apache.jmeter.engine.ClientJMeterEngine#runTest</code> 方法中被使用。</p><h3 id="runTest-1"><a href="#runTest-1" class="headerlink" title="runTest"></a>runTest</h3><p><code>ClientJmeterEngine#runTest</code> 方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runTest</span><span class="params">()</span> <span class="keyword">throws</span> JMeterEngineException &#123;</span><br><span class="line">    log.info(<span class="string">&quot;running clientengine run method&quot;</span>);</span><br><span class="line">    <span class="comment">// See https://bz.apache.org/bugzilla/show_bug.cgi?id=55510</span></span><br><span class="line">    JMeterContextService.clearTotalThreads();</span><br><span class="line">    <span class="type">HashTree</span> <span class="variable">testTree</span> <span class="operator">=</span> test;</span><br><span class="line">    <span class="keyword">synchronized</span>(testTree) &#123;</span><br><span class="line">        <span class="type">PreCompiler</span> <span class="variable">compiler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PreCompiler</span>(<span class="literal">true</span>);</span><br><span class="line">        testTree.traverse(compiler);  <span class="comment">// limit the changes to client only test elements</span></span><br><span class="line">        JMeterContextService.initClientSideVariables(compiler.getClientSideVariables());</span><br><span class="line">        testTree.traverse(<span class="keyword">new</span> <span class="title class_">TurnElementsOn</span>());</span><br><span class="line">        testTree.traverse(<span class="keyword">new</span> <span class="title class_">ConvertListeners</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    String methodName=<span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        JMeterContextService.startTest();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Add fix for Deadlocks, see:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * See https://bz.apache.org/bugzilla/show_bug.cgi?id=48350</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">baseDirRelative</span> <span class="operator">=</span> FileServer.getFileServer().getBaseDirRelative();</span><br><span class="line">        <span class="type">String</span> <span class="variable">scriptName</span> <span class="operator">=</span> FileServer.getFileServer().getScriptName();</span><br><span class="line">        <span class="keyword">synchronized</span>(LOCK)</span><br><span class="line">        &#123;</span><br><span class="line">            methodName=<span class="string">&quot;rconfigure()&quot;</span>; <span class="comment">// NOSONAR Used for tracing</span></span><br><span class="line">            remote.rconfigure(testTree, hostAndPort, baseDirRelative, scriptName);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;sent test to &#123;&#125; basedir=&#x27;&#123;&#125;&#x27;&quot;</span>, hostAndPort, baseDirRelative); <span class="comment">// $NON-NLS-1$</span></span><br><span class="line">        <span class="keyword">if</span>(savep == <span class="literal">null</span>) &#123;</span><br><span class="line">            savep = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;Sending properties &#123;&#125;&quot;</span>, savep);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            methodName=<span class="string">&quot;rsetProperties()&quot;</span>;<span class="comment">// NOSONAR Used for tracing</span></span><br><span class="line">            remote.rsetProperties(toHashMapOfString(savep));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Could not set properties: &#123;&#125;, error:&#123;&#125;&quot;</span>, savep, e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        methodName=<span class="string">&quot;rrunTest()&quot;</span>;</span><br><span class="line">        remote.rrunTest();</span><br><span class="line">        log.info(<span class="string">&quot;sent run command to &#123;&#125;&quot;</span>, hostAndPort);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Error in &#123;&#125; method &quot;</span>, methodName, ex); <span class="comment">// $NON-NLS-1$ $NON-NLS-2$</span></span><br><span class="line">        tidyRMI(log);</span><br><span class="line">        <span class="keyword">throw</span> ex; <span class="comment">// Don&#x27;t wrap this error - display it as is</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Error in &#123;&#125; method&quot;</span>, methodName, ex); <span class="comment">// $NON-NLS-1$ $NON-NLS-2$</span></span><br><span class="line">        tidyRMI(log);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JMeterEngineException</span>(<span class="string">&quot;Error in &quot;</span> + ethodName + <span class="string">&quot; method &quot;</span> + ex, ex); <span class="comment">// $NON-NLS-1$ $NON-NLS-2$</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法执行过程如下：</p><ol><li>初始化 JMeterContextService，将JMeterContextService中的线程信息清空，调用的方法为<code>JMeterContextService#clearTotalThreads</code>。</li><li>通过<code>ClientJmeterEngine#configure</code>方法克隆一份测试计划，赋值给一个新的HashTree对象testTree。</li><li>testTree对象被同步，然后通过<code>PreCompiler</code>对测试计划进行预编译，将测试计划中的变量进行替换，并获取客户端变量。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(testTree) &#123;</span><br><span class="line">    <span class="type">PreCompiler</span> <span class="variable">compiler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PreCompiler</span>(<span class="literal">true</span>);</span><br><span class="line">    testTree.traverse(compiler);  <span class="comment">// limit the changes to client only test elements</span></span><br><span class="line">    JMeterContextService.initClientSideVariables(compiler.getClientSideVariables());</span><br><span class="line">    testTree.traverse(<span class="keyword">new</span> <span class="title class_">TurnElementsOn</span>());</span><br><span class="line">    testTree.traverse(<span class="keyword">new</span> <span class="title class_">ConvertListeners</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>PreCompiler</code>类是JMeter的预编译器，用于替换测试计划中的变量。在上面讲StandardJMeterEngine的时候，我们提到过，JMeter的变量替换是在测试计划执行之前进行的，而<code>PreCompiler</code>就是负责这个工作的。</li><li><code>JMeterContextService.initClientSideVariables(compiler.getClientSideVariables());</code>这行代码的作用是将预编译器中获取到的客户端变量初始化到JMeterContextService中。初始化变量的过程是<code>org.apache.jmeter.engine.PreCompiler#addNode</code>方法解析这个testTree，然后对HashTree中的每个元素进行判断，如果元素类型是<code>org.apache.jmeter.testelement.TestPlan</code>，则去解析用户自定义的变量，然后放到<code>org.apache.jmeter.threads.JMeterVariables</code>中，如果元素类型是<code>org.apache.jmeter.config.Arguments</code>, 则直接获取参数列表，然后放到<code>org.apache.jmeter.threads.JMeterVariables</code>中。</li><li><code>testTree.traverse(new TurnElementsOn());</code>这行代码的作用是将测试计划中的所有元素都设置为运行状态，在 JMeter 中，一个测试元素可以有两个不同的状态：编辑状态和运行时状态，当测试计划在 JMeter 中被载入和显示时，它处于“编辑状态”；当测试计划被执行时，测试元素被转换到“运行状态”。</li><li><code>testTree.traverse(new ConvertListeners());</code>这行代码的作用是将测试计划中的监听器转换为远程监听器，远程监听器是 JMeter 的一种特殊类型的监听器，它可以在远程服务器上运行，并将结果发送回客户端。</li></ul><ol start="4"><li><p>接下来就是通过RMI将测试计划发送到远程服务器，然后执行测试计划。RMI是Java远程方法调用（Remote Method Invocation）的简称，它是一种允许一个Java虚拟机上的对象调用另一个Java虚拟机上的对象的方法的技术。在JMeter中，RMI被用来在远程服务器上执行测试计划，并将结果发送回客户端。在<code>org.apache.jmeter.engine.ClientJMeterEngine</code>中，有一个<code>private RemoteJMeterEngine remote</code>  对象，这个对象就是用来执行远程测试计划的。在<code>org.apache.jmeter.engine.RemoteJMeterEngine</code>中也同样定义了与<code>org.apache.jmeter.engine.JMeterEngine</code>接口中类似的方法，只不过这些方法前面都多了一个<code>r</code>表示远程调用。如：<code>rrunTest()</code>、<code>rconfigure()</code>、<code>rsetProperties()</code>等。</p></li><li><p>如果在执行过程中发生异常，则停止远程服务器上的测试计划，并打印相关日志。</p></li></ol><p>总结：</p><p><code>org.apache.jmeter.engine.ClientJMeterEngine</code>类是JMeter的客户端执行引擎，它负责将测试计划发送到远程服务器，并在远程服务器上执行测试计划。整个执行过程跟<code>org.apache.jmeter.engine.StandardJMeterEngine</code>类似，只不过<code>org.apache.jmeter.engine.ClientJMeterEngine</code>是通过RMI将测试计划发送到远程服务器，并在远程服务器上执行测试计划，然后由远程服务器将结果发送回客户端。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h1&gt;&lt;p&gt;在前面的几篇文章中，笔者主要分析了Jmeter在Non-Gui模式下的启动过程，知道了jmeter在启动过程中会根据启动参数做各种初始化动作</summary>
      
    
    
    
    
    <category term="Jmeter源码系列" scheme="https://linvaux.github.io/tags/Jmeter%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>【Jmeter扩展开发】自定义Java请求</title>
    <link href="https://linvaux.github.io/posts/75270eba/"/>
    <id>https://linvaux.github.io/posts/75270eba/</id>
    <published>2024-08-03T01:36:37.000Z</published>
    <updated>2024-09-21T00:59:08.940Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自定义Java请求"><a href="#自定义Java请求" class="headerlink" title="自定义Java请求"></a>自定义Java请求</h1><h2 id="1-Java请求"><a href="#1-Java请求" class="headerlink" title="1. Java请求"></a>1. Java请求</h2><h3 id="1-1-Java请求简介"><a href="#1-1-Java请求简介" class="headerlink" title="1.1 Java请求简介"></a>1.1 Java请求简介</h3><p>JMeter 内置支持了一系列的常用协议，例如 HTTP&#x2F;HTTPS、FTP、JDBC、JMS、SOAP 和 TCP 等，可以直接通过编写脚本来支持相关协议的测试场景。除了这些协议之外，用户也可能需要进行一些其他标准协议的测试，或者某些情况下在标准协议基础上增加了定制化的内容，需要对定制后的协议进行测试。本文中介绍的 Java Sampler 扩展机制就是 JMeter 提供的一种可以轻松实现对新协议支持的方式。</p><h3 id="1-2-Java请求的使用场景"><a href="#1-2-Java请求的使用场景" class="headerlink" title="1.2 Java请求的使用场景"></a>1.2 Java请求的使用场景</h3><p>Java请求可以用于以下场景：</p><ul><li>需要在JMeter中实现复杂的请求逻辑，例如需要调用多个Java类或方法，或者需要处理复杂的返回值。</li><li>需要在JMeter中实现自定义的协议，或者Jmeter原生尚未支持的协议，例如需要调用自定义的协议或协议扩展。</li><li>需要在JMeter中实现一些特殊的测试需求，例如需要调用第三方API或服务，或者需要处理一些特殊的返回值。</li><li>不想写beanshell脚本，或者beanshell脚本无法满足需求。</li></ul><h2 id="2-Java请求的实现"><a href="#2-Java请求的实现" class="headerlink" title="2. Java请求的实现"></a>2. Java请求的实现</h2><h3 id="2-1-工程创建"><a href="#2-1-工程创建" class="headerlink" title="2.1 工程创建"></a>2.1 工程创建</h3><ol><li>使用Maven的quickstart模板创建一个Maven项目</li><li>在pom.xml文件中添加以下依赖：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.wick.jmeter.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmeter-java-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jmeter.version</span>&gt;</span>5.4.1<span class="tag">&lt;/<span class="name">jmeter.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.jmeter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ApacheJMeter_java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jmeter.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h3><ol><li>创建一个Java类，该类需要实现<code>org.apache.jmeter.protocol.java.sampler.JavaSamplerClient</code>接口，或者继承 <code>org.apache.jmeter.protocol.java.sampler.AbstractJavaSamplerClient</code>。</li><li>在Java类中，实现&#x2F;重写以下4个方法:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wick.jmeter.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.jmeter.config.Arguments;</span><br><span class="line"><span class="keyword">import</span> org.apache.jmeter.protocol.java.sampler.AbstractJavaSamplerClient;</span><br><span class="line"><span class="keyword">import</span> org.apache.jmeter.protocol.java.sampler.JavaSamplerContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.jmeter.samplers.SampleResult;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wick</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/8/3 09:58</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: jmeter自定义java请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomJavaRequestTest</span> <span class="keyword">extends</span> <span class="title class_">AbstractJavaSamplerClient</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取参数，此方法中配置的参数会在Jmeter的Java请求页面展示，</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 请求参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Arguments <span class="title function_">getDefaultParameters</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDefaultParameters();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试开始前做初始化，只会执行一次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context Jmeter采样器上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setupTest</span><span class="params">(JavaSamplerContext context)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setupTest(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试结束后做清理，只会执行一次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context Jmeter采样器上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teardownTest</span><span class="params">(JavaSamplerContext context)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.teardownTest(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 采样器执行，执行多次，具体执行次数取决于此采样器所在的线程组配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context Jmeter采样器上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 采样器结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> SampleResult <span class="title function_">runTest</span><span class="params">(JavaSamplerContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-3-打包测试"><a href="#2-3-打包测试" class="headerlink" title="2.3 打包测试"></a>2.3 打包测试</h3><ol><li>打包jar，注意：需要将带有完整依赖的jar打包出来，否则运行时可能会报错<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -T 4C -DskipTests</span><br></pre></td></tr></table></figure></li><li>将jar放到 <code>&lt;jmeter安装路径&gt;/lib/ext/</code> 目录下</li><li>重启Jmeter，在Jmeter中添加Java请求，并配置参数，运行测试</li></ol><h2 id="3-Java请求的配置"><a href="#3-Java请求的配置" class="headerlink" title="3. Java请求的配置"></a>3. Java请求的配置</h2><p>在JMeter中，可以通过以下步骤打开Java请求的配置界面：</p><ol><li>在JMeter的测试计划中，右键单击要添加Java请求的线程组。</li><li>选择“添加” -&gt; “采样器” -&gt; “Java请求”。</li><li>在Java请求的配置界面中，可以设置以下参数：</li></ol><ul><li><strong>名称</strong>：Java请求的名称。</li><li><strong>类名</strong>：Java请求的类名。</li><li><strong>请求参数</strong>：Java请求中设置的参数。</li></ul><h2 id="4-Java请求完整代码"><a href="#4-Java请求完整代码" class="headerlink" title="4. Java请求完整代码"></a>4. Java请求完整代码</h2><blockquote><p>假设我们需要实现以下需求：请求一个http接口，但是需要对其中某个字段做Base64编码，然后将编码后的字段作为请求参数传递给http接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wick.jmeter.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.thoughtworks.xstream.core.util.Base64Encoder;</span><br><span class="line"><span class="keyword">import</span> kong.unirest.Cookie;</span><br><span class="line"><span class="keyword">import</span> kong.unirest.HttpResponse;</span><br><span class="line"><span class="keyword">import</span> kong.unirest.JsonNode;</span><br><span class="line"><span class="keyword">import</span> kong.unirest.Unirest;</span><br><span class="line"><span class="keyword">import</span> org.apache.jmeter.config.Arguments;</span><br><span class="line"><span class="keyword">import</span> org.apache.jmeter.protocol.java.sampler.AbstractJavaSamplerClient;</span><br><span class="line"><span class="keyword">import</span> org.apache.jmeter.protocol.java.sampler.JavaSamplerContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.jmeter.samplers.SampleResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wick</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/8/3 09:58</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: jmeter自定义java请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomJavaRequestTest</span> <span class="keyword">extends</span> <span class="title class_">AbstractJavaSamplerClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PARAM_USERNAME</span> <span class="operator">=</span> <span class="string">&quot;username&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PARAM_PASSWORD</span> <span class="operator">=</span> <span class="string">&quot;password&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取参数，此方法中配置的参数会在Jmeter的Java请求页面展示，</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 请求参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Arguments <span class="title function_">getDefaultParameters</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Arguments</span> <span class="variable">arguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arguments</span>();</span><br><span class="line">        arguments.addArgument(PARAM_USERNAME, <span class="string">&quot;zhang_san&quot;</span>);</span><br><span class="line">        arguments.addArgument(PARAM_PASSWORD, <span class="string">&quot;1234&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> arguments;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试开始前做初始化，只会执行一次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context Jmeter采样器上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setupTest</span><span class="params">(JavaSamplerContext context)</span> &#123;</span><br><span class="line">        Unirest.config()</span><br><span class="line">                .defaultBaseUrl(<span class="string">&quot;https://httpbin.org/&quot;</span>)</span><br><span class="line">                .connectTimeout(<span class="number">60000</span>)</span><br><span class="line">                .addDefaultCookie(<span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;timestamp&quot;</span>,String.valueOf(System.currentTimeMillis())));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 采样器执行，执行多次，具体执行次数取决于此采样器所在的线程组配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context Jmeter采样器上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 采样器结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> SampleResult <span class="title function_">runTest</span><span class="params">(JavaSamplerContext context)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> context.getParameter(PARAM_USERNAME);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> context.getParameter(PARAM_PASSWORD);</span><br><span class="line">        <span class="type">SampleResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SampleResult</span>();</span><br><span class="line">        result.sampleStart();</span><br><span class="line">        HttpResponse&lt;JsonNode&gt; response;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response = Unirest.get(<span class="string">&quot;/get&quot;</span>)</span><br><span class="line">                    .queryString(<span class="string">&quot;username&quot;</span>, username)</span><br><span class="line">                    .queryString(<span class="string">&quot;password&quot;</span>, <span class="keyword">new</span> <span class="title class_">Base64Encoder</span>().encode(password.getBytes()))</span><br><span class="line">                    .asJson();</span><br><span class="line">            result.setSuccessful(response.isSuccess());</span><br><span class="line">            result.setSamplerData(response.getRequestSummary().getUrl());</span><br><span class="line">            result.setResponseCode(response.getStatusText());</span><br><span class="line">            result.setResponseHeaders(response.getHeaders().toString());</span><br><span class="line">            result.setResponseData(response.getBody().toString(), StandardCharsets.UTF_8.name());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            result.setSuccessful(<span class="literal">false</span>);</span><br><span class="line">            result.setResponseData(e.getMessage(), StandardCharsets.UTF_8.name());</span><br><span class="line">        &#125;</span><br><span class="line">        result.sampleEnd();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试结束后做清理，只会执行一次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context Jmeter采样器上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teardownTest</span><span class="params">(JavaSamplerContext context)</span> &#123;</span><br><span class="line">        Unirest.shutDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后，在jmeter中添加Java请求，选中自己开发的请求类 <code>com.wick.jmeter.demo.CustomJavaRequestTest</code> 并配置参数，即可运行。</p><p><img src="/../images/20240803095440.jpg"><br><img src="/../images/iShot_2024-08-03_11.25.43.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;自定义Java请求&quot;&gt;&lt;a href=&quot;#自定义Java请求&quot; class=&quot;headerlink&quot; title=&quot;自定义Java请求&quot;&gt;&lt;/a&gt;自定义Java请求&lt;/h1&gt;&lt;h2 id=&quot;1-Java请求&quot;&gt;&lt;a href=&quot;#1-Java请求&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="Jmeter扩展开发" scheme="https://linvaux.github.io/tags/Jmeter%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>IDEA插件整理(二)</title>
    <link href="https://linvaux.github.io/posts/67f865da/"/>
    <id>https://linvaux.github.io/posts/67f865da/</id>
    <published>2024-07-31T14:02:28.000Z</published>
    <updated>2024-09-21T00:59:08.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mario-Progress-Bar"><a href="#Mario-Progress-Bar" class="headerlink" title="Mario Progress Bar"></a>Mario Progress Bar</h1><blockquote><p>马里奥进度条，非常可爱</p></blockquote><p><img src="/../images/20240731220524.png"><br><img src="/../images/20240731220640.png"></p><h1 id="Cool-Request"><a href="#Cool-Request" class="headerlink" title="Cool Request"></a>Cool Request</h1><blockquote><p>IDEA里面非常好用的httpClient，支持发现项目中的接口，并且能自动填充请求报文</p></blockquote><p><img src="/../images/20240731221742.png"></p><h1 id="arthas-idea"><a href="#arthas-idea" class="headerlink" title="arthas idea"></a>arthas idea</h1><blockquote><p>基于IntelliJ IDEA开发的<a href="https://arthas.aliyun.com/doc/quick-start.html">Arthas</a>命令生成插件，支持阿里巴巴Arthas官方常用命令。</p></blockquote><p><img src="/../images/20240731224353.png"></p><h1 id="jclasslib-Bytecode-Viewer"><a href="#jclasslib-Bytecode-Viewer" class="headerlink" title="jclasslib Bytecode Viewer"></a>jclasslib Bytecode Viewer</h1><blockquote><p>字节码反编译插件，对于想学习字节码和jvm的同学比较有用，功能强大。选中字节码文件 -&gt; 点击菜单栏View -&gt; 点击 Show Bytecode With Jclasslib 即可</p></blockquote><p><img src="/../images/20240731225122.png"></p><h1 id="Github-Copilot"><a href="#Github-Copilot" class="headerlink" title="Github Copilot"></a>Github Copilot</h1><blockquote><p>Github出的神级代码提示插件，没有之一，不过要收费，可以自己去某宝上买账号</p></blockquote><p><img src="/../images/screenshot_72dd36c5-4db8-4f8a-9c65-8994b537df95.gif"></p><h1 id="HighlightBracketPair"><a href="#HighlightBracketPair" class="headerlink" title="HighlightBracketPair"></a>HighlightBracketPair</h1><blockquote><p>专注显示当前光标所在的括号范围，配合彩虹括号插件(Rainbow Brackets)使用更佳</p></blockquote><p><img src="/../images/20240731230349.png"></p><h1 id="Smart-Input"><a href="#Smart-Input" class="headerlink" title="Smart Input"></a>Smart Input</h1><blockquote><p>智能切换输入法，该插件核心功能可以根据输入位置的上下文智能分析当前处于什么场景应该使用哪种输入法并自动切换，而且还可以&gt; 通过光标的颜色来提醒当前是什么输入法以及大小写状态。以下列举其中几个场景:</p><ul><li>识别到注释场景时，自动切换为中文输入法。</li><li>识别到IdeaVim命令模式时，自动切换为英文输入法。</li><li>识别到Commit Message场景时，自动切换为中文输入法。</li><li>识别到Terminal窗口获得焦点时，自动切换为英文输入法。</li><li>用户输入字符串字面量时记录主动切换输入法习惯，下次自动切换到对应的输入法，越用越智能</li></ul></blockquote><p>我试了下，确实好用！</p><p><img src="/../images/20240731230935.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mario-Progress-Bar&quot;&gt;&lt;a href=&quot;#Mario-Progress-Bar&quot; class=&quot;headerlink&quot; title=&quot;Mario Progress Bar&quot;&gt;&lt;/a&gt;Mario Progress Bar&lt;/h1&gt;&lt;blockquo</summary>
      
    
    
    
    
    <category term="IDEA" scheme="https://linvaux.github.io/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Jmeter源码系列(4) - Jmeter 类详解-runNonGui()，无界面模式下的脚本执行过程</title>
    <link href="https://linvaux.github.io/posts/7d6bf7a5/"/>
    <id>https://linvaux.github.io/posts/7d6bf7a5/</id>
    <published>2024-07-28T14:03:54.000Z</published>
    <updated>2024-09-21T00:59:08.935Z</updated>
    
    <content type="html"><![CDATA[<p>在前面几篇文章中，我们已经知道了 Jmeter 的启动过程，接下来我们一起看下，在 NON-GUI 模式下，Jmeter 是如何开始执行我们的 jmx 脚本的</p><h2 id="startNonGui"><a href="#startNonGui" class="headerlink" title="startNonGui"></a>startNonGui</h2><p>以下是 startNonGui 源代码，其实也没几行，简单过一下即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startNonGui</span><span class="params">(String testFile, String logFile, CLOption remoteStart, <span class="type">boolean</span> generateReportDashboard)</span></span><br><span class="line">            <span class="keyword">throws</span> IllegalUserActionException, ConfigurationException &#123;</span><br><span class="line">        <span class="comment">// add a system property so samplers can check to see if JMeter</span></span><br><span class="line">        <span class="comment">// is running in NonGui mode</span></span><br><span class="line">        System.setProperty(JMETER_NON_GUI, <span class="string">&quot;true&quot;</span>);<span class="comment">// $NON-NLS-1$</span></span><br><span class="line">        <span class="type">JMeter</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JMeter</span>();<span class="comment">// TODO - why does it create a new instance?</span></span><br><span class="line">        driver.remoteProps = <span class="built_in">this</span>.remoteProps;</span><br><span class="line">        driver.remoteStop = <span class="built_in">this</span>.remoteStop;</span><br><span class="line">        driver.deleteResultFile = <span class="built_in">this</span>.deleteResultFile;</span><br><span class="line">        PluginManager.install(<span class="built_in">this</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">remoteHostsString</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (remoteStart != <span class="literal">null</span>) &#123;</span><br><span class="line">            remoteHostsString = remoteStart.getArgument();</span><br><span class="line">            <span class="keyword">if</span> (remoteHostsString == <span class="literal">null</span>) &#123;</span><br><span class="line">                remoteHostsString = JMeterUtils.getPropDefault(</span><br><span class="line">                        <span class="string">&quot;remote_hosts&quot;</span>, <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">                        <span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//NOSONAR $NON-NLS-1$</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (testFile == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalUserActionException</span>(<span class="string">&quot;Non-GUI runs require a test plan&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        driver.runNonGui(testFile, logFile, remoteStart != <span class="literal">null</span>, remoteHostsString, generateReportDashboard);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li><p>设置了环境变量 JMeter.NonGui&#x3D;true，其实我目前也不知道这个环境变量在哪里被用到了。</p></li><li><p>JMeter driver &#x3D; new JMeter(); 后面的TODO很有意思，为啥要创建一个新实例？其实在 org.apache.jmeter.JMeter 类中，只有此处实例化了Jmeter这个变量，加TODO的这个人估计想用单例模式来获取对象，但是明显是没必要的，因为Jmeter在NonGui模式下执行完jmx文件之后就结束进程了，倒也没必要用单例。</p></li><li><p>设置driver的两个属性，这两个属性一般在分布式压测时才需要</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要发送到远程服务器的配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Properties remoteProps;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试结束后，是否停止远程引擎</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> remoteStop;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试开始前，是否删除 jtl 和 report</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">deleteResultFile</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li><li><p>插件管理器安装插件，一般对于GUI模式来说，需要执行此过程加载不同插件的页面，此处为 false，实际上不会安装<br><img src="/../images/20240729230757.png" alt="image"></p></li><li><p>检查是否是远程启动压测，否则的话配置远程服务器地址为本机ip，然后检查jmx文件是否为null，接下来开始调用 runNonGui 真正的执行测试了。</p></li></ol><h2 id="runNonGui"><a href="#runNonGui" class="headerlink" title="runNonGui"></a>runNonGui</h2><p>先贴个源码，这个方法有点点复杂，但是也是NonGui模式下最核心的方法了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">runNonGui</span><span class="params">(String testFile, String logFile, <span class="type">boolean</span> remoteStart, String remoteHostsString, <span class="type">boolean</span> generateReportDashboard)</span></span><br><span class="line">            <span class="keyword">throws</span> ConfigurationException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(testFile);</span><br><span class="line">            <span class="keyword">if</span> (!f.exists() || !f.isFile()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConfigurationException</span>(<span class="string">&quot;The file &quot;</span> + f.getAbsolutePath() + <span class="string">&quot; doesn&#x27;t exist or can&#x27;t be opened&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            FileServer.getFileServer().setBaseForScript(f);</span><br><span class="line"></span><br><span class="line">            <span class="type">HashTree</span> <span class="variable">tree</span> <span class="operator">=</span> SaveService.loadTree(f);</span><br><span class="line"></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span> <span class="comment">// Deliberate use of deprecated ctor</span></span><br><span class="line">            <span class="type">JMeterTreeModel</span> <span class="variable">treeModel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JMeterTreeModel</span>(<span class="keyword">new</span> <span class="title class_">Object</span>());<span class="comment">// NOSONAR Create non-GUI version to avoid headless problems</span></span><br><span class="line">            <span class="type">JMeterTreeNode</span> <span class="variable">root</span> <span class="operator">=</span> (JMeterTreeNode) treeModel.getRoot();</span><br><span class="line">            treeModel.addSubTree(tree, root);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Hack to resolve ModuleControllers in non GUI mode</span></span><br><span class="line">            SearchByClass&lt;ReplaceableController&gt; replaceableControllers =</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">SearchByClass</span>&lt;&gt;(ReplaceableController.class);</span><br><span class="line">            tree.traverse(replaceableControllers);</span><br><span class="line">            Collection&lt;ReplaceableController&gt; replaceableControllersRes = replaceableControllers.getSearchResults();</span><br><span class="line">            <span class="keyword">for</span> (ReplaceableController replaceableController : replaceableControllersRes) &#123;</span><br><span class="line">                replaceableController.resolveReplacementSubTree(root);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Ensure tree is interpreted (ReplaceableControllers are replaced)</span></span><br><span class="line">            <span class="comment">// For GUI runs this is done in Start.java</span></span><br><span class="line">            <span class="type">HashTree</span> <span class="variable">clonedTree</span> <span class="operator">=</span> convertSubTree(tree, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Summariser</span> <span class="variable">summariser</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">summariserName</span> <span class="operator">=</span> JMeterUtils.getPropDefault(<span class="string">&quot;summariser.name&quot;</span>, <span class="string">&quot;&quot;</span>);<span class="comment">//$NON-NLS-1$</span></span><br><span class="line">            <span class="keyword">if</span> (summariserName.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;Creating summariser &lt;&#123;&#125;&gt;&quot;</span>, summariserName);</span><br><span class="line">                println(<span class="string">&quot;Creating summariser &lt;&quot;</span> + summariserName + <span class="string">&quot;&gt;&quot;</span>);</span><br><span class="line">                summariser = <span class="keyword">new</span> <span class="title class_">Summariser</span>(summariserName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ResultCollector</span> <span class="variable">resultCollector</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (logFile != <span class="literal">null</span>) &#123;</span><br><span class="line">                resultCollector = <span class="keyword">new</span> <span class="title class_">ResultCollector</span>(summariser);</span><br><span class="line">                resultCollector.setFilename(logFile);</span><br><span class="line">                clonedTree.add(clonedTree.getArray()[<span class="number">0</span>], resultCollector);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// only add Summariser if it can not be shared with the ResultCollector</span></span><br><span class="line">                <span class="keyword">if</span> (summariser != <span class="literal">null</span>) &#123;</span><br><span class="line">                    clonedTree.add(clonedTree.getArray()[<span class="number">0</span>], summariser);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (deleteResultFile) &#123;</span><br><span class="line">                SearchByClass&lt;ResultCollector&gt; resultListeners = <span class="keyword">new</span> <span class="title class_">SearchByClass</span>&lt;&gt;(ResultCollector.class);</span><br><span class="line">                clonedTree.traverse(resultListeners);</span><br><span class="line">                <span class="keyword">for</span> (ResultCollector rc : resultListeners.getSearchResults()) &#123;</span><br><span class="line">                    <span class="type">File</span> <span class="variable">resultFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(rc.getFilename());</span><br><span class="line">                    <span class="keyword">if</span> (resultFile.exists() &amp;&amp; !resultFile.delete()) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Could not delete results file &quot;</span> + resultFile.getAbsolutePath()</span><br><span class="line">                                + <span class="string">&quot;(canRead:&quot;</span> + resultFile.canRead() + <span class="string">&quot;, canWrite:&quot;</span> + resultFile.canWrite() + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ReportGenerator</span> <span class="variable">reportGenerator</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (logFile != <span class="literal">null</span> &amp;&amp; generateReportDashboard) &#123;</span><br><span class="line">                reportGenerator = <span class="keyword">new</span> <span class="title class_">ReportGenerator</span>(logFile, resultCollector);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Used for remote notification of threads start/stop,see BUG 54152</span></span><br><span class="line">            <span class="comment">// Summariser uses this feature to compute correctly number of threads</span></span><br><span class="line">            <span class="comment">// when NON GUI mode is used</span></span><br><span class="line">            clonedTree.add(clonedTree.getArray()[<span class="number">0</span>], <span class="keyword">new</span> <span class="title class_">RemoteThreadsListenerTestElement</span>());</span><br><span class="line"></span><br><span class="line">            List&lt;JMeterEngine&gt; engines = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            println(<span class="string">&quot;Created the tree successfully using &quot;</span>+testFile);</span><br><span class="line">            <span class="keyword">if</span> (!remoteStart) &#123;</span><br><span class="line">                <span class="type">JMeterEngine</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardJMeterEngine</span>();</span><br><span class="line">                clonedTree.add(clonedTree.getArray()[<span class="number">0</span>], <span class="keyword">new</span> <span class="title class_">ListenToTest</span>(</span><br><span class="line">                        org.apache.jmeter.JMeter.ListenToTest.RunMode.LOCAL, <span class="literal">false</span>, reportGenerator));</span><br><span class="line">                engine.configure(clonedTree);</span><br><span class="line">                <span class="type">Instant</span> <span class="variable">now</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">                println(<span class="string">&quot;Starting standalone test @ &quot;</span>+ formatLikeDate(now) + <span class="string">&quot; (&quot;</span> + now.toEpochMilli() + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">                engines.add(engine);</span><br><span class="line">                engine.runTest();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                java.util.<span class="type">StringTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.StringTokenizer(remoteHostsString.trim(), <span class="string">&quot;,&quot;</span>);<span class="comment">//$NON-NLS-1$</span></span><br><span class="line">                List&lt;String&gt; hosts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                <span class="keyword">while</span> (st.hasMoreElements()) &#123;</span><br><span class="line">                    hosts.add(((String) st.nextElement()).trim());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">ListenToTest</span> <span class="variable">testListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListenToTest</span>(</span><br><span class="line">                        org.apache.jmeter.JMeter.ListenToTest.RunMode.REMOTE, remoteStop, reportGenerator);</span><br><span class="line">                clonedTree.add(clonedTree.getArray()[<span class="number">0</span>], testListener);</span><br><span class="line">                DistributedRunner distributedRunner=<span class="keyword">new</span> <span class="title class_">DistributedRunner</span>(<span class="built_in">this</span>.remoteProps);</span><br><span class="line">                distributedRunner.setStdout(System.out); <span class="comment">// NOSONAR</span></span><br><span class="line">                distributedRunner.setStdErr(System.err); <span class="comment">// NOSONAR</span></span><br><span class="line">                distributedRunner.init(hosts, clonedTree);</span><br><span class="line">                engines.addAll(distributedRunner.getEngines());</span><br><span class="line">                testListener.setStartedRemoteEngines(engines);</span><br><span class="line">                distributedRunner.start();</span><br><span class="line">            &#125;</span><br><span class="line">            startUdpDdaemon(engines);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ConfigurationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Error in NonGUIDriver &quot;</span> + e.toString());<span class="comment">//NOSONAR</span></span><br><span class="line">            log.error(<span class="string">&quot;Error in NonGUIDriver&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConfigurationException</span>(<span class="string">&quot;Error in NonGUIDriver &quot;</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面对这个方法执行过程进行分析，其中涉及到非常多的Jmeter核心类，以及几个比较重要的方法，这里就不一一展开，只对核心流程进行分析，这些核心类&#x2F;方法会在后面的文章中展开讲解。</p><ol><li>检查测试文件：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(testFile);</span><br><span class="line"><span class="keyword">if</span> (!f.exists() || !f.isFile()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConfigurationException</span>(<span class="string">&quot;The file &quot;</span> + f.getAbsolutePath() + <span class="string">&quot; doesn&#x27;t exist or can&#x27;t be opened&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，通过提供的testFile(由启动参数 -t 指定))字符串创建一个File对象。然后检查这个文件是否存在并且是否是一个文件实体（而不是目录）。如果文件不存在或者无法打开，将抛出一个ConfigurationException。</p><ol start="2"><li>设置文件服务器基目录：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileServer.getFileServer().setBaseForScript(f);</span><br></pre></td></tr></table></figure><p>设置JMeter的基目录，这样JMeter就可以基于这个目录来查找和加载其他依赖的文件，比如图片、CSV数据文件等。</p><ol start="3"><li>加载测试计划：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HashTree</span> <span class="variable">tree</span> <span class="operator">=</span> SaveService.loadTree(f);</span><br></pre></td></tr></table></figure><p>从文件系统中读取测试计划的HashTree结构，这是JMeter内部存储测试元素的方式。</p><ol start="4"><li>构建测试树模型：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span> <span class="comment">// Deliberate use of deprecated ctor</span></span><br><span class="line"><span class="type">JMeterTreeModel</span> <span class="variable">treeModel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JMeterTreeModel</span>(<span class="keyword">new</span> <span class="title class_">Object</span>());<span class="comment">// NOSONAR Create non-GUI version to avoid headless problems</span></span><br><span class="line"><span class="type">JMeterTreeNode</span> <span class="variable">root</span> <span class="operator">=</span> (JMeterTreeNode) treeModel.getRoot();</span><br><span class="line">treeModel.addSubTree(tree, root);</span><br></pre></td></tr></table></figure><p>创建一个JMeterTreeModel，并使用HashTree填充它，以构建完整的测试计划模型。</p><ol start="5"><li>处理模块控制器：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hack to resolve ModuleControllers in non GUI mode</span></span><br><span class="line">SearchByClass&lt;ReplaceableController&gt; replaceableControllers = <span class="keyword">new</span> <span class="title class_">SearchByClass</span>&lt;&gt;(ReplaceableController.class);</span><br><span class="line">tree.traverse(replaceableControllers);</span><br><span class="line">Collection&lt;ReplaceableController&gt; replaceableControllersRes = replaceableControllers.getSearchResults();</span><br><span class="line"><span class="keyword">for</span> (ReplaceableController replaceableController : replaceableControllersRes) &#123;</span><br><span class="line">    replaceableController.resolveReplacementSubTree(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在非GUI模式下，模块控制器需要特殊处理，因为它们可能包含引用其他测试片段的逻辑。这里遍历整个HashTree，找到所有ReplaceableController类的实例，并替换其内部的子树。</p><ol start="6"><li>复制和解析测试树：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HashTree</span> <span class="variable">clonedTree</span> <span class="operator">=</span> convertSubTree(tree, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>调用convertSubTree(tree, true);函数对测试树进行复制，确保所有ReplaceableControllers都被解析和替换。同时，如果有被禁用的元素，在这一步也会被删除。否则即使元素被禁用，也会被Jmeter执行引擎加载执行。</p><ol start="7"><li>结果收集与汇总：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">summariserName</span> <span class="operator">=</span> JMeterUtils.getPropDefault(<span class="string">&quot;summariser.name&quot;</span>, <span class="string">&quot;&quot;</span>);<span class="comment">//$NON-NLS-1$</span></span><br><span class="line"><span class="keyword">if</span> (summariserName.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    log.info(<span class="string">&quot;Creating summariser &lt;&#123;&#125;&gt;&quot;</span>, summariserName);</span><br><span class="line">    println(<span class="string">&quot;Creating summariser &lt;&quot;</span> + summariserName + <span class="string">&quot;&gt;&quot;</span>);</span><br><span class="line">    summariser = <span class="keyword">new</span> <span class="title class_">Summariser</span>(summariserName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个Summariser，用于在测试过程中实时显示摘要信息。其实在jmeter.properties文件中，默认是启用了Summariser的，所以这里会创建一个Summariser。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">summariser.name=summary</span><br></pre></td></tr></table></figure><p>在执行测试时，我们也会在命令行看到类似这样的输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Creating summariser &lt;summary&gt;</span><br><span class="line">Created the tree successfully using test.jmx</span><br><span class="line">Starting standalone test @ Sat Aug 03 16:57:49 CST 2024 (1722675469483)</span><br><span class="line">Waiting for possible Shutdown/StopTestNow/HeapDump/ThreadDump message on port 4445</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ResultCollector</span> <span class="variable">resultCollector</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (logFile != <span class="literal">null</span>) &#123;</span><br><span class="line">    resultCollector = <span class="keyword">new</span> <span class="title class_">ResultCollector</span>(summariser);</span><br><span class="line">    resultCollector.setFilename(logFile);</span><br><span class="line">    clonedTree.add(clonedTree.getArray()[<span class="number">0</span>], resultCollector);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// only add Summariser if it can not be shared with the ResultCollector</span></span><br><span class="line">    <span class="keyword">if</span> (summariser != <span class="literal">null</span>) &#123;</span><br><span class="line">        clonedTree.add(clonedTree.getArray()[<span class="number">0</span>], summariser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果提供了logFile(由启动参数 -l 指定)，则创建一个ResultCollector来收集测试结果到文件中。如果没有指定文件，但有summariser，那么仅添加汇总器。</p><ol start="8"><li>处理结果文件：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (deleteResultFile) &#123;</span><br><span class="line">    SearchByClass&lt;ResultCollector&gt; resultListeners = <span class="keyword">new</span> <span class="title class_">SearchByClass</span>&lt;&gt;(ResultCollector.class);</span><br><span class="line">    clonedTree.traverse(resultListeners);</span><br><span class="line">    <span class="keyword">for</span> (ResultCollector rc : resultListeners.getSearchResults()) &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">resultFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(rc.getFilename());</span><br><span class="line">        <span class="keyword">if</span> (resultFile.exists() &amp;&amp; !resultFile.delete()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Could not delete results file &quot;</span> + resultFile.getAbsolutePath()</span><br><span class="line">                    + <span class="string">&quot;(canRead:&quot;</span> + resultFile.canRead() + <span class="string">&quot;, canWrite:&quot;</span> + resultFile.canWrite() + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果deleteResultFile为true(由启动参数 -f 指定)，则删除任何已存在的结果文件。如果deleteResultFile为false，则跳过这一步。</p><ol start="9"><li>报告生成：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReportGenerator</span> <span class="variable">reportGenerator</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (logFile != <span class="literal">null</span> &amp;&amp; generateReportDashboard) &#123;</span><br><span class="line">    reportGenerator = <span class="keyword">new</span> <span class="title class_">ReportGenerator</span>(logFile, resultCollector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果generateReportDashboard(由启动参数 -e 指定)为true，并且指定了logFile，则创建一个ReportGenerator，用于在测试完成后生成详细的HTML报告。</p><ol start="10"><li>远程通知与线程监听：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clonedTree.add(clonedTree.getArray()[<span class="number">0</span>], <span class="keyword">new</span> <span class="title class_">RemoteThreadsListenerTestElement</span>());</span><br></pre></td></tr></table></figure><p>添加一个RemoteThreadsListenerTestElement到测试树中，用于在非GUI模式下通知线程的开始和停止。</p><ol start="11"><li>启动测试引擎：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!remoteStart) &#123;</span><br><span class="line">    <span class="type">JMeterEngine</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardJMeterEngine</span>();</span><br><span class="line">    clonedTree.add(clonedTree.getArray()[<span class="number">0</span>], <span class="keyword">new</span> <span class="title class_">ListenToTest</span>(</span><br><span class="line">            org.apache.jmeter.JMeter.ListenToTest.RunMode.LOCAL, <span class="literal">false</span>, reportGenerator));</span><br><span class="line">    engine.configure(clonedTree);</span><br><span class="line">    <span class="type">Instant</span> <span class="variable">now</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">    println(<span class="string">&quot;Starting standalone test @ &quot;</span>+ formatLikeDate(now) + <span class="string">&quot; (&quot;</span> + now.toEpochMilli() + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    engines.add(engine);</span><br><span class="line">    engine.runTest();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    java.util.<span class="type">StringTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.StringTokenizer(remoteHostsString.trim(), <span class="string">&quot;,&quot;</span>);<span class="comment">//$NON-NLS-1$</span></span><br><span class="line">    List&lt;String&gt; hosts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (st.hasMoreElements()) &#123;</span><br><span class="line">        hosts.add(((String) st.nextElement()).trim());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListenToTest</span> <span class="variable">testListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListenToTest</span>(</span><br><span class="line">            org.apache.jmeter.JMeter.ListenToTest.RunMode.REMOTE, remoteStop, reportGenerator);</span><br><span class="line">    clonedTree.add(clonedTree.getArray()[<span class="number">0</span>], testListener);</span><br><span class="line">    DistributedRunner distributedRunner=<span class="keyword">new</span> <span class="title class_">DistributedRunner</span>(<span class="built_in">this</span>.remoteProps);</span><br><span class="line">    distributedRunner.setStdout(System.out); <span class="comment">// NOSONAR</span></span><br><span class="line">    distributedRunner.setStdErr(System.err); <span class="comment">// NOSONAR</span></span><br><span class="line">    distributedRunner.init(hosts, clonedTree);</span><br><span class="line">    engines.addAll(distributedRunner.getEngines());</span><br><span class="line">    testListener.setStartedRemoteEngines(engines);</span><br><span class="line">    distributedRunner.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果remoteStart(由启动参数 -R 指定)为false，则在本地运行测试。创建一个StandardJMeterEngine实例，配置测试树并运行。<br>如果remoteStart(由启动参数 -R 指定)为true，则执行分布式测试。解析remoteHostsString以获取远程主机列表，创建ListenToTest监听器和DistributedRunner实例，初始化并开始分布式测试。</p><ol start="12"><li>启动UDP守护进程：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startUdpDdaemon(engines);</span><br></pre></td></tr></table></figure><p>启动UDP守护进程，用于在分布式测试中接收来自远程节点的信号。此方法执行过程如下：</p><ul><li>获取端口号：<br>从JMeter的属性中读取默认的UDP端口号（jmeterengine.nongui.port），如果没有设置则使用常量UDP_PORT_DEFAULT作为默认值。<br>同样，也读取最大端口号（jmeterengine.nongui.maxport），默认为4455，用于当指定端口被占用时寻找下一个可用端口。</li><li>检查端口号的有效性：<br>如果端口号大于1000（通常操作系统保留了小于1024的端口给系统服务），则继续尝试创建DatagramSocket；否则，代码将不会尝试创建。</li><li>创建DatagramSocket：<br>调用getSocket方法尝试在指定端口创建一个UDP套接字，如果该端口被占用，会尝试下一个直到达到最大端口号maxPort。</li><li>创建线程：<br>如果成功创建了DatagramSocket，则创建一个新的线程waiter，并将其命名为”UDP Listener”。<br>线程的run方法中调用waitForSignals方法，传入JMeter引擎列表和DatagramSocket，这表明线程的主要任务是等待并处理来自这些引擎的信号。</li><li>设置线程为守护线程：<br>将waiter线程设置为守护线程（setDaemon(true)），这意味着当所有非守护线程结束时，JVM也会终止，即使守护线程还在运行。</li><li>启动线程：<br>使用waiter.start();启动线程，使它开始执行run方法中的逻辑。</li><li>错误处理：<br>如果没有成功创建DatagramSocket，则输出一条错误信息“Failed to create UDP port”，表明未能创建UDP端口。</li></ul><p>整个过程是为了在JMeter非GUI模式下支持分布式测试，守护进程会监听特定的UDP端口，以便从远程节点接收控制信号，如测试的开始、停止或状态更新。这使得JMeter能够协调多个远程节点上的测试执行，实现分布式压力测试。</p><h4>总结来说，这个方法的核心功能是在非GUI模式下加载和运行一个JMeter测试计划，无论是本地还是分布式，同时管理结果的收集、汇总和报告生成。这在自动化测试和持续集成环境中非常有用，因为它可以避免图形界面带来的资源开销，提高测试效率。</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在前面几篇文章中，我们已经知道了 Jmeter 的启动过程，接下来我们一起看下，在 NON-GUI 模式下，Jmeter 是如何开始执行我们的 jmx 脚本的&lt;/p&gt;
&lt;h2 id=&quot;startNonGui&quot;&gt;&lt;a href=&quot;#startNonGui&quot; class=&quot;he</summary>
      
    
    
    
    
    <category term="Jmeter源码系列" scheme="https://linvaux.github.io/tags/Jmeter%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Java集成GradleToolingAPI编译Gradle项目</title>
    <link href="https://linvaux.github.io/posts/a60e7042/"/>
    <id>https://linvaux.github.io/posts/a60e7042/</id>
    <published>2024-07-13T15:15:50.000Z</published>
    <updated>2024-09-21T00:59:08.930Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>使用Java代码控制Gradle编译与Maven Embedder编译有所不同，需要额外安装Gradle工具到本地，MavenEmbedder则是直接通过集成jar的方式实现。所以在编译Gradle项目之前，需要先在本地安装对应版本的Gradle，无需配置环境变量。</p><h2 id="安装Gradle"><a href="#安装Gradle" class="headerlink" title="安装Gradle"></a>安装Gradle</h2><p>下载Gradle：<a href="https://gradle.org/releases/">https://gradle.org/releases/</a> 选择需要的版本安装即可<br><img src="/../images/PeXhunzHMXmdZNRk9kQrwe22.png" alt="image.png"></p><ul><li>binary-only: 只有二进制文件</li><li>complete: 在二进制包基础上增加了 文档 , 源码</li></ul><p>建议选择binary-only版本，我们只需要实现代码编译即可，无需引入其他内容。</p><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- gradle版本查询：https://mvnrepository.com/artifact/org.netbeans.external/gradle-tooling-api --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.netbeans.external<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gradle-tooling-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;gradle-tooling-api.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>笔者使用的版本为：RELEASE170</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="GradleCommand"><a href="#GradleCommand" class="headerlink" title="GradleCommand"></a>GradleCommand</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wick</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/6/19 21:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: gradle编译相关命令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GradleCommand</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * gradle命令</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">GRADLE</span> <span class="operator">=</span> <span class="string">&quot;gradle&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清理构建产物</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CLEAN</span> <span class="operator">=</span> <span class="string">&quot;clean&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TEST</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排除某个任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCLUDE</span> <span class="operator">=</span> <span class="string">&quot;-x&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编译 class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CLASSES</span> <span class="operator">=</span> <span class="string">&quot;classes&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; COMMAND = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;() &#123;&#123;</span><br><span class="line">        add(CLEAN);</span><br><span class="line">        add(CLASSES);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Constant"><a href="#Constant" class="headerlink" title="Constant"></a>Constant</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JAVA_HOME</span> <span class="operator">=</span> <span class="string">&quot;java.home&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">File</span> <span class="variable">DEFAULT_GRADLE_USER_HOME</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;~/.gradle&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="GradleManager"><a href="#GradleManager" class="headerlink" title="GradleManager"></a>GradleManager</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wick</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/6/19 21:06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: gradle编译接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GradleBuildManager</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码编译</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dto dto</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">compiler</span><span class="params">(CompileDTO dto)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取模块列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jdkPath jdk安装路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> gradlePath gradle 安装路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> codePath   代码路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 模块列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;String&gt; <span class="title function_">modules</span><span class="params">(String jdkPath,String gradlePath, String codePath)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GradleBuildManagerImpl"><a href="#GradleBuildManagerImpl" class="headerlink" title="GradleBuildManagerImpl"></a>GradleBuildManagerImpl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GradleBuildManagerImpl</span> <span class="keyword">implements</span> <span class="title class_">GradleBuildManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compiler</span><span class="params">(CompileDTO dto)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始编译Gradle项目，编译工具路径: &#123;&#125;，代码路径: &#123;&#125;, 编译参数: &#123;&#125;&quot;</span>, dto.getBuildToolPath(), dto.getCodePath(), dto.getCommands());</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 重定向标准错误输出流</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">errorStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">originalErrStream</span> <span class="operator">=</span> System.err;</span><br><span class="line">        <span class="comment">// 重定向标准输出流</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">originalOutStream</span> <span class="operator">=</span> System.out;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ProjectConnection</span> <span class="variable">connection</span> <span class="operator">=</span> GradleConnector.newConnector()</span><br><span class="line">                .forProjectDirectory(<span class="keyword">new</span> <span class="title class_">File</span>(dto.getCodePath()))</span><br><span class="line">                .useGradleUserHomeDir(CoverageConstant.DEFAULT_GRADLE_USER_HOME)</span><br><span class="line">                .useInstallation(<span class="keyword">new</span> <span class="title class_">File</span>(dto.getBuildToolPath()))</span><br><span class="line">                .connect()) &#123;</span><br><span class="line">            <span class="type">BuildLauncher</span> <span class="variable">build</span> <span class="operator">=</span> connection.newBuild();</span><br><span class="line">            build.setJavaHome(<span class="keyword">new</span> <span class="title class_">File</span>(dto.getJdkPath()));</span><br><span class="line">            System.setErr(<span class="keyword">new</span> <span class="title class_">PrintStream</span>(errorStream));</span><br><span class="line">            System.setOut(<span class="keyword">new</span> <span class="title class_">PrintStream</span>(outputStream));</span><br><span class="line">            build.forTasks(dto.getCommands().toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]))</span><br><span class="line">                    .setStandardOutput(System.out)</span><br><span class="line">                    .setStandardError(System.err)</span><br><span class="line">                    <span class="comment">// 跳过单测，多线程编译</span></span><br><span class="line">                    .withArguments(GradleCommand.EXCLUDE, GradleCommand.TEST)</span><br><span class="line">                    <span class="comment">// 不使用彩色日志，否则会导致日志中的颜色代码被打印出来，导致日志不易阅读</span></span><br><span class="line">                    .setColorOutput(<span class="literal">false</span>)</span><br><span class="line">                    <span class="comment">// 限制 gradle 内存，防止编译过程中内存溢出，具体配置视服务器内存而定</span></span><br><span class="line">                    .setJvmArguments(<span class="string">&quot;-Xmx512m&quot;</span>);</span><br><span class="line">            build.run();</span><br><span class="line">            log.info(<span class="string">&quot;编译日志:\n &#123;&#125;&quot;</span>, outputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;代码: &#123;&#125; 编译失败, 异常详情: &#123;&#125;&quot;</span>, dto.getCodePath(), ExceptionUtils.getRootCauseMessage(e));</span><br><span class="line">            log.error(<span class="string">&quot;编译异常日志:\n &#123;&#125;&quot;</span>, errorStream);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(<span class="string">&quot;编译失败&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.setErr(originalErrStream);</span><br><span class="line">            System.setOut(originalOutStream);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;结束编译Gradle项目，编译耗时: &#123;&#125; s&quot;</span>, (System.currentTimeMillis() - startTime) / <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">modules</span><span class="params">(String jdkPath, String gradlePath, String codePath)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">originJavaHome</span> <span class="operator">=</span> System.getProperty(SystemPropertiesConstant.JAVA_HOME);</span><br><span class="line">        System.setProperty(SystemPropertiesConstant.JAVA_HOME, jdkPath);</span><br><span class="line">        log.info(<span class="string">&quot;开始扫描Gradle项目模块，编译工具路径: &#123;&#125;，代码路径: &#123;&#125;&quot;</span>, gradlePath, codePath);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ProjectConnection</span> <span class="variable">connection</span> <span class="operator">=</span> GradleConnector.newConnector()</span><br><span class="line">                .forProjectDirectory(<span class="keyword">new</span> <span class="title class_">File</span>(codePath))</span><br><span class="line">                .useInstallation(<span class="keyword">new</span> <span class="title class_">File</span>(gradlePath))</span><br><span class="line">                .connect()) &#123;</span><br><span class="line">            <span class="type">GradleProject</span> <span class="variable">model</span> <span class="operator">=</span> connection.getModel(GradleProject.class);</span><br><span class="line">            <span class="keyword">return</span> model.getChildren().stream().map(GradleProject::getName).collect(Collectors.toList());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;代码: &#123;&#125; 模块扫描失败, 异常详情: &#123;&#125;&quot;</span>, codePath, ExceptionUtils.getRootCauseMessage(e));</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(<span class="string">&quot;模块扫描失败&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.setProperty(SystemPropertiesConstant.JAVA_HOME, originJavaHome);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h2&gt;&lt;p&gt;使用Java代码控制Gradle编译与Maven Embedder编译有所不同，需要额外安装Gradle工具到本地，Mave</summary>
      
    
    
    
    
    <category term="Java" scheme="https://linvaux.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM 命令/工具使用介绍</title>
    <link href="https://linvaux.github.io/posts/f1ffc212/"/>
    <id>https://linvaux.github.io/posts/f1ffc212/</id>
    <published>2024-05-04T04:55:16.000Z</published>
    <updated>2024-09-21T00:59:08.927Z</updated>
    
    <content type="html"><![CDATA[<p>JDK 自带了非常多的工具用于管理和监控 Java 应用程序状态，对于 Java 开发者来说，了解这些工具如何使用是非常有必要的，尤其是在排查线上问题，或者使用内部网络的情况下，可能无法或不允许使用三方工具，如 <a href="https://github.com/alibaba/arthas">arthas</a>，<a href="https://github.com/aragozin/jvm-tools">jvm-tools</a> 等，这个时候熟练使用 JDK 自带的 jvm 工具就非常有助于我们分析和解决 jvm 的问题。接下来我将对 JDK 中自带的比较常用的工具进行介绍，同时也会穿插部分其他 jvm 分析工具的讲解。</p><p><strong>注意：以下内容均基于 JDK-11.0.12 版本讲解，不同版本的 JDK 中，命令或许有所不同。</strong></p><h2 id="jps-虚拟机进程状况工具"><a href="#jps-虚拟机进程状况工具" class="headerlink" title="jps:虚拟机进程状况工具"></a>jps:虚拟机进程状况工具</h2><p>JPS（Java Virtual Machine Process Status Tool）是Java自带的命令行工具，用于列出当前运行的Java虚拟机（JVM）进程的信息。它提供了一种简单的方法来查看正在运行的Java进程的PID（Process ID）和主类名称。<br>以下是JPS命令的一般语法和选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [ options ]</span><br></pre></td></tr></table></figure><p>常见的选项包括：</p><ul><li>-q：只输出PID，不显示主类的名称。</li><li>-l：输出PID和主类的全名，即全限定类名。</li><li>-m：输出PID和主类的名称，并显示传递给main()方法的参数。</li><li>-v: 输出传递给 JVM 的参数</li></ul><p>使用JPS命令可以获得以下信息：</p><ul><li>运行的Java进程的PID（Process ID）：JPS可以列出当前正在运行的Java进程的PID，可以方便地使用其他工具（如jstack、jmap）进行进程诊断和分析。</li><li>主类的名称：JPS可以显示启动Java进程的主类的名称，这对于排查运行中的Java进程非常有用。</li><li>主类的参数：如果使用 -m 选项，JPS也可以显示传递给启动Java进程的主类的参数。这对于诊断和分析特定Java进程的配置和行为非常有用。</li></ul><p>请注意，JPS只能检测与当前用户相关的Java进程。如果您想查看其他用户的Java进程，您可能需要使用root权限或使用适当的权限来运行JPS命令。</p><p>使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure><p><img src="/../images/wr6DKUsoZudzSDsLHGgZgok8.png" alt="image.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps -q</span><br></pre></td></tr></table></figure><p><img src="/../images/L6dNSBJw8enibUuqx7yk3xJB.png" alt="image.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps -l</span><br></pre></td></tr></table></figure><p><img src="/../images/nNadrW1Km8rEFMwxR9CDBEow.png" alt="image.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps -m</span><br></pre></td></tr></table></figure><p><img src="/../images/BpxCjUXPa8avH9fU6Q4moL7y.png" alt="image.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps -v</span><br></pre></td></tr></table></figure><p><img src="/../images/Neu1BwvGRvg4MNCTT2ppLjfB.png" alt="image.png"></p><h2 id="jstack-堆栈跟踪工具"><a href="#jstack-堆栈跟踪工具" class="headerlink" title="jstack: 堆栈跟踪工具"></a>jstack: 堆栈跟踪工具</h2><p>jstack 用于生成Java进程的线程转储（Thread Dump），以便分析和诊断Java应用程序的线程状态和问题。线程转储是指记录了Java进程中各个线程的堆栈信息，可以用来分析线程的运行状态、死锁、死循环等问题。</p><p>jstack 的一般语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack [-l][-e] &lt;pid&gt;</span><br></pre></td></tr></table></figure><p>常见的选项包括：</p><ul><li>-l: 以长格式输出线程转储信息。此参数可以显示关于每个线程的附加信息，如锁信息、监视器信息等</li><li>-e: 生成线程转储时输出扩展信息。它会显示更详细的线程堆栈信息，包括与线程关联的本地方法（Native Method）的符号信息</li></ul><p>使用 jstack 命令可以获得以下信息：</p><ul><li>线程堆栈信息：jstack 会打印出Java进程中每个线程的堆栈跟踪信息（包括正在运行的线程和等待中的线程），其中包含了线程调用栈的方法、行号和类信息。</li><li>死锁信息：通过查看线程转储，可以检测并诊断可能存在的死锁情况。死锁是指多个线程互相持有对方需要的资源而导致的相互等待的情况。</li><li>监控线程状态：线程转储还可以帮助监控线程状态，例如查找长时间运行的线程、查找线程的等待和阻塞情况等。</li></ul><p>jstack 命令可以用于在线上或开发环境中定位和分析Java程序中的线程问题，如死锁、CPU高占用等。通常结合其他工具，如jps、jconsole、VisualVM等一起使用，以获取更全面的线程和性能信息，从而进行诊断和分析。</p><p>使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用刚才 springboot-demo-0.0.1-SNAPSHOT.jar 的进程来分析堆栈</span></span><br><span class="line">jps | grep demo | awk &#x27;&#123;print $1&#125;&#x27; | xargs -n 1 jstack -l &gt; jstack.log</span><br></pre></td></tr></table></figure><p><img src="/../images/kd9YTtnkkaYtqrg57bWJW5Vf.png" alt="image.png"></p><p>我们从 jstack.log 中截取一段内容，来看下这段内容表示什么意思</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;Reference Handler&quot; #2 daemon prio=10 os_prio=31 cpu=1.92ms elapsed=1359.35s tid=0x00007ff67900b800 nid=0x4403 waiting on condition  [0x000070000e0a5000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">at java.lang.ref.Reference.waitForReferencePendingList(java.base@11.0.12/Native Method)</span><br><span class="line">at java.lang.ref.Reference.processPendingReferences(java.base@11.0.12/Reference.java:241)</span><br><span class="line">at java.lang.ref.Reference$ReferenceHandler.run(java.base@11.0.12/Reference.java:213)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">- None</span><br></pre></td></tr></table></figure><blockquote><p>“Reference Handler” #2 daemon prio&#x3D;10 os_prio&#x3D;31 cpu&#x3D;1.92ms elapsed&#x3D;1359.35s tid&#x3D;0x00007ff67900b800 nid&#x3D;0x4403 waiting on condition [0x000070000e0a5000]：</p></blockquote><ul><li>“Reference Handler” 是线程的名称。</li><li>#2 表示该线程的序号。</li><li>daemon 表示该线程是一个守护线程。</li><li>prio&#x3D;10 表示该线程的调度优先级。</li><li>os_prio&#x3D;31 是操作系统对该线程的优先级。</li><li>cpu&#x3D;1.92ms 表示该线程占用 CPU 的时间。</li><li>elapsed&#x3D;1359.35s 表示该线程的运行时间。</li><li>tid&#x3D;0x00007ff67900b800 是线程的十六进制表示的线程 ID。</li><li>nid&#x3D;0x4403 是线程的十六进制表示的线程 ID，nid 也就是 Native ID。</li><li>waiting on condition 表示该线程当前正在等待某个条件。</li><li>[0x000070000e0a5000] 是线程的十六进制表示的栈地址。</li></ul><blockquote><p>java.lang.Thread.State: RUNNABLE：</p></blockquote><ul><li>java.lang.Thread.State 表示线程的状态。</li><li>RUNNABLE 表示线程正在运行。</li></ul><p>jstack 命令获取到的线程状态主要有以下几种：</p><ul><li>NEW：线程已创建但尚未启动。</li><li>RUNNABLE：线程正在执行或准备执行，可以在操作系统的可执行队列中运行。</li><li>BLOCKED：线程正在等待获得一个监视器锁（synchronized关键字）以进入同步代码块。</li><li>WAITING：线程正在无限期地等待另一个线程采取某些操作，直到被中断或唤醒。</li><li>TIMED_WAITING：线程正在等待另一个线程采取某些操作，但等待的时间有限，可以是超时等待或等待指定的条件。</li><li>TERMINATED：线程已完成执行，结束了它的生命周期。</li></ul><blockquote><p>at java.lang.ref.Reference.waitForReferencePendingList(<a href="mailto:&#x6a;&#x61;&#118;&#x61;&#46;&#98;&#97;&#115;&#x65;&#x40;&#x31;&#x31;&#46;&#48;&#x2e;&#x31;&#x32;">&#x6a;&#x61;&#118;&#x61;&#46;&#98;&#97;&#115;&#x65;&#x40;&#x31;&#x31;&#46;&#48;&#x2e;&#x31;&#x32;</a>&#x2F;Native Method)：</p></blockquote><ul><li>这是线程调用栈的一部分，显示了线程正在执行的方法。</li><li>at 后面是方法的完整名称。</li></ul><blockquote><p>Locked ownable synchronizers:：</p></blockquote><ul><li>这是线程拥有的独占锁的列表。</li></ul><blockquote><p>-None：</p></blockquote><ul><li>表示线程当前未拥有任何独占锁。</li></ul><p>除了直接查看 jstack 生成的原始文件外，也可以借助其他工具来辅助我们分析，以下是几种常用的分析工具：</p><ul><li><p><a href="http://spotify.github.io/threaddump-analyzer/">在线分析</a><br><img src="/../images/MjBDhei4b4KTVJw15Dm2dKd9.png" alt="image.png"></p></li><li><p><a href="https://www.ibm.com/support/pages/ibm-thread-and-monitor-dump-analyzer-java-tmda">离线分析 TMDA</a><br><img src="/../images/UrEcdCRUmmqikKR6MMsWY4Nw.png" alt="image.png"></p></li></ul><p>———————— 昏割线，太困了，先睡了 ————————</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JDK 自带了非常多的工具用于管理和监控 Java 应用程序状态，对于 Java 开发者来说，了解这些工具如何使用是非常有必要的，尤其是在排查线上问题，或者使用内部网络的情况下，可能无法或不允许使用三方工具，如 &lt;a href=&quot;https://github.com/ali</summary>
      
    
    
    
    
    <category term="Java" scheme="https://linvaux.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Jacocoagent 改造-服务端覆盖率数据上报</title>
    <link href="https://linvaux.github.io/posts/1cd2eecd/"/>
    <id>https://linvaux.github.io/posts/1cd2eecd/</id>
    <published>2023-10-26T15:14:25.000Z</published>
    <updated>2024-09-21T00:59:08.927Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>代码覆盖率服务已经上线一段时间了，用户也反馈了不少问题，大家反馈比较集中的问题就是：<br>测试忘记在服务器重启前生成覆盖率报告了，导致某段时间内覆盖率数据丢失。<br>解决这个问题的思路比较简单，就是改造 javaagent，在 jvm 停止时，上报覆盖率数据到我们的代码覆盖率服务，等待生成报告时，将上报的数据和实时的覆盖率数据做合并即可。</p><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><p>具体实现方案涉及到两部分：</p><ul><li>jacoco 源码改造</li><li>代码覆盖率服务(以下简称 cov 服务)改造</li></ul><h3 id="jacoco改造"><a href="#jacoco改造" class="headerlink" title="jacoco改造"></a>jacoco改造</h3><blockquote><p>jacoco 改造主要涉及到以下几个类：</p><ul><li>org.jacoco.agent.rt.internal.Agent</li><li>org.jacoco.core.runtime.AgentOptions</li></ul></blockquote><p>在 jacocoagent 的 org.jacoco.agent.rt.internal.Agent 类中，官方已经添加了一个 shutdownHook，只需要在此方法中实现我们的上报逻辑即可。为了方便测试，我们还需要对<br>org.jacoco.core.runtime.AgentOptions 做改造，增加两个参数 debug 和 host。</p><ul><li>debug：是否启用 debug 模式，如果是 debug 模式，则不会上报覆盖率数据，否则根据 host 配置推送覆盖率数据到代码覆盖率服务器。此参数默认为 false，表示会推送数据，也可以将 debug&#x3D;true，表示无需推送数据到覆盖率服务。</li><li>host: 测试平台的域名，用来发送覆盖率数据，可以根据 host 的配置，将数据发送到不同的环境。</li></ul><p>改造前，需要在 org.jacoco.agent.rt 的 pom.xml 中加入以下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.konghq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>unirest-java-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>AgentOptions 实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处省略 getter 和 setter 方法</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否启用 debug 模式，如果是 debug 模式，则不会上报覆盖率数据，否则根据 host 配置推送覆盖率数据到 cov 服务器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEBUG</span> <span class="operator">=</span> <span class="string">&quot;debug&quot;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试平台域名，用来发送覆盖率数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HOST</span> <span class="operator">=</span> <span class="string">&quot;host&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加完参数后，需要将这两个参数加到 VALID_OPTIONS 中，否则会提示 “未知参数”</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Collection&lt;String&gt; VALID_OPTIONS = Arrays.asList(</span><br><span class="line">DESTFILE, APPEND, INCLUDES, EXCLUDES, EXCLCLASSLOADER,</span><br><span class="line">INCLBOOTSTRAPCLASSES, INCLNOLOCATIONCLASSES, SESSIONID, DUMPONEXIT,</span><br><span class="line">OUTPUT, ADDRESS, PORT, CLASSDUMPDIR, JMX, HOST, DEBUG);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Agent 实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Agent <span class="title function_">getInstance</span><span class="params">(<span class="keyword">final</span> AgentOptions options)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Agent</span> <span class="variable">agent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Agent</span>(options, IExceptionLogger.SYSTEM_ERR);</span><br><span class="line">            agent.startup();</span><br><span class="line">            Runtime.getRuntime().addShutdownHook(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;Jacocoagent Shutdown hook thread.&quot;</span>) &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                            AgentLogger.info(<span class="string">&quot;Jacocoagent Shutdown hook running.&quot;</span>);</span><br><span class="line">                            <span class="comment">// 非 debug 模式，直接上报数据到 cov 服务</span></span><br><span class="line">                            <span class="keyword">if</span> (!options.getDebug()) &#123;</span><br><span class="line">                                AgentLogger.info(<span class="string">&quot;Not in debug mode, push RuntimeData to OTS server.&quot;</span>);</span><br><span class="line">                                <span class="comment">// 直接在本地生成 exec 文件</span></span><br><span class="line">                                <span class="type">File</span> <span class="variable">execFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;output.exec&quot;</span>);</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(execFile);</span><br><span class="line">                                    <span class="type">ExecutionDataWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExecutionDataWriter</span>(fos);</span><br><span class="line">                                    <span class="type">RuntimeData</span> <span class="variable">runtimeData</span> <span class="operator">=</span> singleton.getData();</span><br><span class="line">                                    runtimeData.collect(writer, writer, <span class="literal">false</span>);</span><br><span class="line">                                    fos.flush();</span><br><span class="line">                                    AgentLogger.info(<span class="string">&quot;Generate exec file success, exec file path is : &quot;</span> + execFile.getAbsolutePath());</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                    AgentLogger.severe(<span class="string">&quot;Failed to generate exec file: &quot;</span> + e.getMessage());</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    AgentLogger.info(<span class="string">&quot;OTS server host is: &quot;</span> + options.getHost());</span><br><span class="line">                                    <span class="comment">// 调用 cov 服务接口，上传数据</span></span><br><span class="line">                                    <span class="type">String</span> <span class="variable">reportApiPath</span> <span class="operator">=</span> <span class="string">&quot;/coverage/rpc/jacocoagent/report&quot;</span>;</span><br><span class="line">                                    HttpResponse&lt;String&gt; response = Unirest.post(options.getHost() + reportApiPath)</span><br><span class="line">                                            .field(<span class="string">&quot;ip&quot;</span>, InetAddress.getLocalHost().getHostAddress())</span><br><span class="line">                                            .field(<span class="string">&quot;file&quot;</span>, execFile)</span><br><span class="line">                                            .asString();</span><br><span class="line">                                    <span class="keyword">if</span> (response.getStatus() == <span class="number">200</span>) &#123;</span><br><span class="line">                                        AgentLogger.info(<span class="string">&quot;Push data to OTS server success, request url is : &quot;</span> + options.getHost() + reportApiPath</span><br><span class="line">                                                + <span class="string">&quot;, request body is :&quot;</span> + <span class="string">&quot; &#123;ip:&quot;</span> + InetAddress.getLocalHost().getHostAddress() + <span class="string">&quot;, file:&quot;</span> + execFile.getAbsolutePath() + <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">                                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        AgentLogger.severe(<span class="string">&quot;Failed to push data to OTS server, request url is : &quot;</span> + options.getHost() + reportApiPath</span><br><span class="line">                                                + <span class="string">&quot;, request body is :&quot;</span> + <span class="string">&quot; &#123;ip:&quot;</span> + InetAddress.getLocalHost().getHostAddress() + <span class="string">&quot;, file:&quot;</span> + execFile.getAbsolutePath() + <span class="string">&quot;&#125;&quot;</span></span><br><span class="line">                                                + <span class="string">&quot;, response status is &quot;</span> + response.getStatus()</span><br><span class="line">                                                + <span class="string">&quot;, response body is : &quot;</span> + response.getBody());</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                    AgentLogger.severe(<span class="string">&quot;Failed to push data to OTS server, on exception: &quot;</span> + e.getMessage());</span><br><span class="line">                                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                    <span class="comment">// 删除 exec 文件</span></span><br><span class="line">                                    <span class="keyword">if</span> (execFile.exists()) &#123;</span><br><span class="line">                                        execFile.delete();</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                AgentLogger.info(<span class="string">&quot;In debug mode, skip pushing data to OTS server.&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            agent.shutdown();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            singleton = agent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以下是日志工具类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.jacoco.agent.rt.internal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.FileHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wick</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/1/25 17:46</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: agent日志工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgentLogger</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">defaultLogFileName</span> <span class="operator">=</span> <span class="string">&quot;javaagent.log&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">File</span> <span class="variable">LOG_LOCK_FILE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;javaagent.log.lck&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态初始化块配置 Logger 和 FileHandler</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="comment">// 移除日志锁文件</span></span><br><span class="line"><span class="keyword">if</span> (LOG_LOCK_FILE.exists()) &#123;</span><br><span class="line">LOG_LOCK_FILE.delete();</span><br><span class="line">&#125;</span><br><span class="line">       logger = Logger.getLogger(<span class="string">&quot;AgentLogger&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">FileHandler</span> <span class="variable">fileHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileHandler</span>(defaultLogFileName, <span class="literal">true</span>);</span><br><span class="line">            fileHandler.setFormatter(<span class="keyword">new</span> <span class="title class_">SimpleFormatter</span>());</span><br><span class="line">            logger.addHandler(fileHandler);</span><br><span class="line">            logger.setUseParentHandlers(<span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">          logger.warning(<span class="string">&quot;An error occurred initializing th AgentLogger: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    logger.info(msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 其他日志级别如法添加即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="cov服务改造"><a href="#cov服务改造" class="headerlink" title="cov服务改造"></a>cov服务改造</h3><p>cov 服务改造很简单，添加一个 post 接口用来接受上传的文件即可，接口定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/rpc/jacocoagent&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JacocoagentReportController</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AgentService agentServie;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/report&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">report</span><span class="params">(<span class="meta">@RequestParam(&quot;ip&quot;)</span> String ip, <span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file)</span>&#123;</span><br><span class="line">        agentService.report(ip, file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，jacocoagent 就实现了在 jvm 停止时，自动上报数据的功能。编译出来的 jacocoagent.jar 位于 org.jacoco.agent&#x2F;target&#x2F;classes 目录下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;代码覆盖率服务已经上线一段时间了，用户也反馈了不少问题，大家反馈比较集中的问题就是：&lt;br&gt;测试忘记在服务器重启前生成覆盖率报告了，导致某段</summary>
      
    
    
    
    
    <category term="代码覆盖率" scheme="https://linvaux.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>基于Jmeter和Selenium的WebUI自动化测试服务实现思路</title>
    <link href="https://linvaux.github.io/posts/4599864a/"/>
    <id>https://linvaux.github.io/posts/4599864a/</id>
    <published>2023-10-01T15:12:26.000Z</published>
    <updated>2024-09-21T00:59:08.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>快到年底了，没啥东西要做了，搞一把 WebUI 自动化测试作为 2023 年收官之战，以下仅介绍技术实现思路，也欢迎大家有更好的想法在评论区交流。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>实现一个面向普通用户的 WebUI 自动化测试服务，实现效果可以参考MeterSphere的 UI 自动化测试功能，当然这玩意儿是要收费才能用，可以申请个账号去体验下。注意：不是在给 MeterSPhere 打广告，只是懒得写需求而已。</p><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>虽然现在也有一些开源的 WebUI 自动化测试平台，但是调研了之后发现并不好用，比如 LuckyFrame，代码都是写死的，没啥扩展性，不是说这个项目不好，而是不满足我们的需求。所以最后选择了半天，使用如下技术栈来实现：<br>Jmeter, <a href="https://github.com/undera/jmeter-plugins-webdriver">Jmeter-plugins-webdriver</a>, Springboot</p><ol><li>以 Jmeter为底层用例的执行引擎，配合 Jmeter 丰富的组件，可以实现复杂的用例步骤。</li><li>Jmeter-plugins-webdriver是一个开源的 Jmeter 插件，底层基于 Selenium 开发，支持 Jmeter 实现 UI 自动化测试。</li><li>简单易上手的 web 框架自然是 Springboot 了。</li></ol><h2 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h2><p><img src="/../images/4UuwExWdg5VJ2Qfvp6cv7srb.png" alt="image.png"></p><p>以上是大概的实现流程，整体思路为：</p><ol><li>前端将用户操作封装为后端接口能处理的 json。</li><li>解析 json，将用户操作识别出来，然后生成代码，原理类似于 <a href="https://github.com/SeleniumHQ/selenium-ide/blob/trunk/packages/code-export-java-junit/src/command.ts">Selenium-IDE</a> 中代码生成的逻辑。</li><li>生成一个空的 HashTree，默认填充 TestPlan 和 ThreadGroup 组件，并设置好属性。</li><li>按照用户的每一步的操作，分别生成一个 WebDriverSampler 组件，这个组件就是Jmeter-plugins-webdriver提供的采样器组件。</li><li>将第2步生成好的代码，填充到 WebDriverSampler 组件的 script 属性中。</li><li>拼装完整的 HashTree，并添加一个自己开发的后台监听器组件(继承AbstractBackendListenerClient即可，不知道的可以自己百度)。</li><li>将最后生成的 HashTree，交给 Jmeter 执行，注意，为了保证不同测试用例能够独立执行，每次执行新用例，必须要重新 new 一个 StandardJmeterEngine。</li></ol><h2 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h2><ul><li><p>Jmeter-plugins-webdriver 插件有个 bug，就是在执行<a href="https://github.com/undera/jmeter-plugins-webdriver/blob/master/src/main/java/com/googlecode/jmeter/plugins/webdriver/sampler/WebDriverSampler.java">WebDriverSampler.sample</a>方法时，如果用例中有主动关闭浏览器的步骤，就会导致采样器报错，原因是：在脚本执行结束后，需要对采样器结果进行封装，会将页面源码封装为 SampleResult 对象的 ResposeData，将当前页面的 URL 设置为 SampleResult 对象的 URL，但是因为浏览器已经被主动关闭了，这个时候再也无法获取到页面源码和 url，就会导致采样器结果标记为异常。<br><img src="/../images/wF7zTMvpUn2xzZRwHDZvdYdR.png" alt="image.png"></p></li><li><p>WebDriverSampler的 sample方法中，并未设置采样器开始和结束时间，导致自己开发的后台监听器中，无法取到用例的执行时长。<br><img src="/../images/gvfUyGFrLj9PYEMLrvb8kHWt.png" alt="image.png"></p></li><li><p>我用的 Jmeter 版本是 5.4.1，其中 beanshell 版本是 Jmeter 自带的 2.0b6 版本，在这个版本中，使用 Java 编写代码时，会将 null 转为 void，详情可见这几个bug：<a href="https://github.com/apache/jmeter/issues/3411">https://github.com/apache/jmeter/issues/3411</a><br><a href="https://github.com/apache/jmeter/issues/6110">https://github.com/apache/jmeter/issues/6110</a><br>解决方案就是把 beanshell 升级到 2.1.1</p></li><li><p>在服务器上部署时，需要安装浏览器运行环境，我这边用的 chrome，但是在测试时发现打开的页面要么中文是方框，要么页面默认是英语。记得安装中文语言包，并设置服务器默认语言为中文，不知道怎么设置就去问 gpt 吧，懒得写了。</p></li><li><p>服务器上运行 chrome 可能会出现 chrome 启动失败，记得增加如下配置到 ChromeOptions 中：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wick</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2023/12/24 20:09</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: chrome options</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChromeOptionConstant</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 允许跨域资源共享（CORS）请求。*表示接受所有来源的请求。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REMOTE_ALLOW_ORIGINS</span> <span class="operator">=</span> <span class="string">&quot;--remote-allow-origins=*&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无痕模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">INCOGNITO</span> <span class="operator">=</span> <span class="string">&quot;--incognito&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 禁用沙箱</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NO_SANDBOX</span> <span class="operator">=</span> <span class="string">&quot;--no-sandbox&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 禁用 GPU，服务器上没有 GPU</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DISABLE_GPU</span> <span class="operator">=</span> <span class="string">&quot;--disable-gpu&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 禁用共享内存，解央 DevToolsActivePort file doesn&#x27;t exist 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DISABLE_DEV_SHM_USAGE</span> <span class="operator">=</span> <span class="string">&quot;--disable-dev-shm-usage&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 浏览器语言-中文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LANG_ZH_CN</span> <span class="operator">=</span> <span class="string">&quot;--accept-lang=zh-CN&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">OPTIONS</span> <span class="operator">=</span> String.join(<span class="string">&quot; &quot;</span>, REMOTE_ALLOW_ORIGINS, INCOGNITO, NO_SANDBOX, DISABLE_GPU, DISABLE_DEV_SHM_USAGE, LANG_ZH_CN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>无法并行执行用例，这个坑爹的问题困扰了我很久，最后发现是我在 ChromeOptions 中加了一个配置 “–remote-debugging-port&#x3D;9222”，这个配置会让 WebDriver 在指定端口启动，多个用例执行时会创建多个 session，但是 9222 端口被占用了，导致其他 session 创建失败，或者出现session 串掉的情况，千万别加这个配置，尤其是你需要并行执行用例的时候。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个 WebUI 自动化技术实现上没啥难度，难的地方在于如何做技术选型，因为绝大多数人做 UI 自动化都是想着用框架写代码实现，但是很少有人会去挑战通过代码生成的方式来做，只要把实现思路理清楚，其实写代码也就那么回事了。对了，我fork 了这个Jmeter-plugins-webdriver插件到 gitee 了，把上面两个问题处理了一下，有兴趣的可以直接用我改过的代码：<a href="https://gitee.com/linvaux/jmeter-plugins-webdriver">https://gitee.com/linvaux/jmeter-plugins-webdriver</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;快到年底了，没啥东西要做了，搞一把 WebUI 自动化测试作为 2023 年收官之战，以下仅介绍技术实现思路，也欢迎大家有更好的想法在评论区</summary>
      
    
    
    
    
    <category term="自动化测试" scheme="https://linvaux.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java 集成Maven Embedder 编译 Maven 项目</title>
    <link href="https://linvaux.github.io/posts/5b7c369d/"/>
    <id>https://linvaux.github.io/posts/5b7c369d/</id>
    <published>2023-09-07T15:01:56.000Z</published>
    <updated>2024-09-21T00:59:08.928Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在开发代码覆盖率的平台，涉及到对 java 项目编译后使用 jacococli 来生成报告，需要指定 java 项目 class 文件路径和源码路径。因此，需要对用户配置的 java 项目在服务器上进行编译，Java 项目构建工具有很多种，比如 Ant，Maven，Gradle 等，本文只针对 Maven 构建的项目如何编译进行讲解。以下用于演示编译的项目是 <a href="https://gitee.com/apolloconfig/apollo">apolloconfig&#x2F;apollo</a></p><h2 id="编译方案"><a href="#编译方案" class="headerlink" title="编译方案"></a>编译方案</h2><p>Maven 项目编译其实很简单，常用的命令就是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package</span><br></pre></td></tr></table></figure><p>但是我在上面说了，我是要在部署了代码覆盖率服务(以下简称 cov 服务，使用 springboot 开发)的服务器上进行编译，这个 cov 服务本身就是使用 Maven 构建，然后使用 Dockerfile 打包成镜像，在 k8s 上部署的，在这个镜像里面只有必要的 JDK 依赖 。因此，如果要在 cov 服务上进行 Maven 项目的构建，则需要先配置 Maven 环境，因为这个镜像是由运维统一提供，所以再往镜像里面打包 Maven 这个事情推动起来比较困难(不要问我哪里困难，问就是他们不愿意)，因此，需要使用其他方式来创建 Maven 项目的编译环境。</p><h3 id="使用-Maven-工具编译"><a href="#使用-Maven-工具编译" class="headerlink" title="使用 Maven 工具编译"></a>使用 Maven 工具编译</h3><p>使用 Maven 工具编译应该是绝大多数人的第一反应，直接在项目启动时从 Maven 官方下载一个<a href="https://dlcdn.apache.org/maven/maven-3/3.8.8/binaries/apache-maven-3.8.8-bin.zip">apache-maven-3.8.8-bin.zip</a>安装包，解压到指定目录，然后通过 Java Runtime 来执行命令即可。道理确实如此，所以可以使用如下脚本进行安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://dlcdn.apache.org/maven/maven-3/3.8.8/binaries/apache-maven-3.8.8-bin.zip &amp;&amp; unzip apache-maven-3.8.8-bin.zip -d /opt</span><br></pre></td></tr></table></figure><p>项目编译可以使用如下 Java 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">runtime.exec(<span class="string">&quot;cd /Users/wick/Downloads/repo/apollo &amp;&amp; mvn -T 4C clean install -Dmaven.test.skip=true&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="使用-Maven-Embedder-编译"><a href="#使用-Maven-Embedder-编译" class="headerlink" title="使用 Maven Embedder 编译"></a>使用 Maven Embedder 编译</h3><p>除了上面的方式之外，还有一种方法，就是使用 Maven Embedder 来编译 Maven 项目，这样只需要在我们 cov 服务中集成相关的依赖，就可以直接使用 Java 代码来编译 Maven 项目，无需在服务器上安装 Maven 工具。具体做法如下</p><ul><li>在 cov 服务中配置 Maven 依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 省略了其他依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.networknt<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-logback<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-embedder<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.resolver<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resolver-connector-basic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.resolver<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resolver-transport-http<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 拉取代码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jgit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>org.eclipse.jgit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.6.0.202305301015-r<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>代码实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.maven.cli.MavenCli;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wick</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2023/8/19 21:39</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Maven编译服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MavenCompilerService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compiler</span><span class="params">(String codePath, String... commands)</span> &#123;</span><br><span class="line">        <span class="type">MavenCli</span> <span class="variable">cli</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MavenCli</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">mvnHome</span> <span class="operator">=</span> MavenCli.USER_MAVEN_CONFIGURATION_HOME.getAbsolutePath();</span><br><span class="line">        System.getProperties().setProperty(<span class="string">&quot;maven.multiModuleProjectDirectory&quot;</span>, mvnHome);</span><br><span class="line">        <span class="type">int</span> <span class="variable">statusCode</span> <span class="operator">=</span> cli.doMain(commands, codePath, System.out, System.err);</span><br><span class="line">        <span class="keyword">if</span> (statusCode != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;编译失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MavenCompilerService</span> <span class="variable">mavenCompilerService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MavenCompilerService</span>();</span><br><span class="line">        String[] commands = &#123;<span class="string">&quot;-T 4C&quot;</span>,<span class="string">&quot;clean&quot;</span>, <span class="string">&quot;install&quot;</span>, <span class="string">&quot;-Dmaven.test.skip=true&quot;</span>&#125;;</span><br><span class="line">        mavenCompilerService.compiler(<span class="string">&quot;/Users/wick/Downloads/repo/apollo&quot;</span>, commands);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的 Maven 命令中，使用了一个参数 <em><strong>-T 4C</strong></em> ，作用是：使用 4 核编译，加快编译速度。</p><p>执行 main 方法之后，看一下控制台输出：</p><p><img src="/../images/g2V4kNBeWAYwy89d7uSyf4LC.jpg" alt="iShot_2023-08-19_21.44.50.jpg"></p><p>可以发现这个跟我们正常执行编译命令的输出没有区别，再看一下是不是真的编译完了</p><p>编译前<br><img src="/../images/iq4Zx4Cz9GCJjkw9kiJs3WaU.jpg" alt="iShot_2023-08-19_21.42.33.jpg"></p><p>编译后<br><img src="/../images/bByVX8VYf8mEKjfMp25Qudpr.jpg" alt="iShot_2023-08-19_21.44.04.jpg"></p><p>可以看到，这个项目的 target 目录已经生成，说明项目编译完成。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面两种编译方案各有优势，直接使用 Maven 工具正常情况下来说是非常方便的，但是缺点是在我现在的场景下不太适用。第二种使用 Maven Embedder 虽然解决了安装工具的问题，但是对于需要执行一些特殊命令，如 deploy 时，就需要开发者去了解这个依赖相关的配置，要知道怎么在 MavenCli 中配置 Maven 仓库推送依赖的账号和密码，以及怎么指定仓库等等问题。所幸，cov 服务只是涉及代码拉取和编译，并不涉及到上述复杂场景，cov 拉取的代码也是公司内部的项目，均是在 pom.xml 中配置好公司内部仓库地址的。等后续遇到其他问题时，再来继续补充此文章内容吧，碎觉！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在开发代码覆盖率的平台，涉及到对 java 项目编译后使用 jacococli 来生成报告，需要指定 java 项目 class 文件路</summary>
      
    
    
    
    
    <category term="Java" scheme="https://linvaux.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>基于 Jacoco 的 java 代码覆盖率收集服务设计</title>
    <link href="https://linvaux.github.io/posts/d7156345/"/>
    <id>https://linvaux.github.io/posts/d7156345/</id>
    <published>2023-08-26T15:04:46.000Z</published>
    <updated>2024-09-21T00:59:08.941Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>下半年开始搞精准测试了，先搞一波代码覆盖率，因为公司绝大多数项目都是基于 Java 开发的，所以就先搞 Java 的了，主流的代码覆盖率工具是 Jacoco(其实我也只知道这一个)，所以就直接基于 springboot 搞一个吧。</p><h2 id="代码覆盖率知识"><a href="#代码覆盖率知识" class="headerlink" title="代码覆盖率知识"></a>代码覆盖率知识</h2><h3 id="什么是代码覆盖率"><a href="#什么是代码覆盖率" class="headerlink" title="什么是代码覆盖率"></a>什么是代码覆盖率</h3><p>代码覆盖率(Code Coverage)是软件测试中一种衡量测试质量的指标，用于评估测试用例对源代码的覆盖程度。它衡量了在执行测试用例时源代码中有多少行、分支、类、方法等被执行到。<br>无论是单元测试、API测试还是功能性测试，最终都是调用了产品的代码；如何评价这些测试的效率?这些测试是否真正全部或者大部分覆盖了产品的代码？这个时候，代码覆盖率就是一个比较有价值的参考指标了。<br>不同的代码覆盖率工具衡量指标可能不同。对于java语言，主流的代码覆盖率工具为Jacoco。当然，Jacoco其实是支持收集运行在JVM上的应用程序的覆盖率的。</p><h3 id="代码覆盖率的意义"><a href="#代码覆盖率的意义" class="headerlink" title="代码覆盖率的意义"></a>代码覆盖率的意义</h3><ol><li>测试视角：分析未覆盖部分的代码，从而反推在前期测试设计是否充分?没有覆盖到的代码是否是测试设计的盲点，为什么没有考虑到？是需求&#x2F;设计不够清晰，测试设计的理解有误？还是工程方法应用后造成的策略性放弃等等，方便之后进行测试用例设计补充。</li><li>开发视角：检测出程序中的废代码，可以逆向反推在代码设计中思维混乱点，提醒设计&#x2F;开发人员理清代码逻辑关系，提升代码质量。</li><li>其他视角：代码覆盖率高不能说明代码质量高，但是反过来看，代码覆盖率低，代码质量不会高到哪里去，可以作为测试&#x2F;开发自我审视的重要工具之一。<br>以上是代码覆盖率正面的意义，但是要注意一点：从质量的角度来说，肯定是希望用例能够对代码全部进行覆盖的，但是从实际出发，进行全覆盖也是不现实的，并且把测试覆盖率作为质量目标没有任何意义，而我们应该把它作为一种发现未被测试覆盖的代码的手段。从现有的覆盖率检测工具来看，即使覆盖率到达了100%，也不能保证用户场景完全被覆盖到或者不会出现漏测，因为从原理上来讲，代码覆盖率只能表示开发写的代码都执行了，但是不表示代码没有逻辑问题，如漏写异常处理，没有完全覆盖用户场景等。</li></ol><h3 id="代码覆盖率生成原理"><a href="#代码覆盖率生成原理" class="headerlink" title="代码覆盖率生成原理"></a>代码覆盖率生成原理</h3><p>Jacoco代码覆盖率生成主要由以下几个过程组成：</p><h4 id="1-代码插桩"><a href="#1-代码插桩" class="headerlink" title="1.代码插桩"></a>1.代码插桩</h4><p>插桩分为编译期插桩和运行期插桩，两者区别如下：</p><ul><li>编译期插桩（Offline模式）：在java源文件编译时，直接将桩插入代码行，编译后的class中已经包含了插桩代码，比如使用jacoco-maven-plugin插件即可实现编译期插桩。在Offline模式下，覆盖率数据是通过在编译期对字节码进行插桩生成的文件进行收集和分析。在编译阶段，Jacoco通过在Java字节码中插入代码来记录覆盖率信息。然后，在运行测试或应用程序之后，Jacoco使用已生成的覆盖率数据文件进行分析，生成相应的报告。由于覆盖率数据是在编译期收集并存储在文件中，这种模式可以在任何时候进行分析并生成报告，无需实时地收集覆盖率数据。这对于持续集成和定期报告生成非常有用。</li><li>运行期插桩（On-the-fly模式）：在应用程序运行期间，通过java agent技术，动态的对class文件做插桩，此类技术使用ASM框架实现，动态的修改了字节码文件。在On-the-fly模式下，覆盖率数据是在运行时实时收集并分析的。在应用程序运行时，Jacoco通过Java Agent技术加载到JVM中，并使用字节码插桩机制动态修改正在执行的字节码，以记录覆盖率信息。在应用程序运行期间，Jacoco会实时收集覆盖率数据并保存在内存中。一旦测试执行完成，覆盖率数据可以立即进行分析和报告。这种模式对于需要实时监控和反馈的场景非常有用，例如在开发过程中查看代码覆盖率。</li></ul><p>编译期插桩的优点是不需要在运行时进行字节码的修改，可以更方便地与构建工具（如Maven或Ant）集成，并且不会对运行时性能产生显著的影响。缺点是需要重新编译代码，并且生成的插桩后的字节码会增加项目的大小。</p><p>运行期插桩的优点是可以对已经编译的字节码进行插桩，无需重新编译代码。缺点是在每次运行应用程序时都需要加载Jacoco Agent，可能会对应用程序的运行时性能产生一定的影响。</p><h4 id="2-覆盖率数据收集"><a href="#2-覆盖率数据收集" class="headerlink" title="2.覆盖率数据收集"></a>2.覆盖率数据收集</h4><p>在On-the-fly模式下，覆盖率数据使用jacocoagent.jar来收集，此agent会伴随被测服务一起启动。</p><p>jacoco生成的覆盖率数据文件默认为exec格式，覆盖率数据输出方式有以下几种：</p><ul><li>file：JVM 终止时，执行数据将写入属性中指定的文件中destfile。</li><li>tcpserver：代理侦听由address和 port属性指定的 TCP 端口上的传入连接。执行数据写入此 TCP 连接。</li><li>tcpclient：启动时，代理连接到address和port 属性指定的 TCP 端口。执行数据写入此 TCP 连接。</li><li>none：不产生任何输出。</li></ul><p>一般对于服务端覆盖率数据收集，我们使用tcpserver模式，即jacocoagent跟着被测服务启动时，同时启动一个tcp端口(默认是6300)，后续可以通过jacococli或者其他工具访问6300端口来下载覆盖率数据。</p><h4 id="3-覆盖率报告生成"><a href="#3-覆盖率报告生成" class="headerlink" title="3.覆盖率报告生成"></a>3.覆盖率报告生成</h4><p>覆盖率数据报告生成需要借助jacococli.jar，先通过cli的dump命令获取覆盖率数据文件(即exec文件)，然后通过cli的report命令来生成覆盖率数据报告。</p><h3 id="全量覆盖率"><a href="#全量覆盖率" class="headerlink" title="全量覆盖率"></a>全量覆盖率</h3><p>适用场景：</p><ul><li>初次测试：当开始进行测试时，全量代码覆盖率非常有用。它可以确保测试用例覆盖了整个代码库，从而验证代码在各种场景下的正确性和稳定性。</li><li>重构和优化：在进行重构或性能优化时，全量代码覆盖率可以帮助发现可能引入的新问题，并确保代码的质量和性能未受到不良影响。</li><li>稳定版本验证：在发布稳定版本之前，全量代码覆盖率可用于验证所有已经修改或新增的功能的测试覆盖程度，以确保发布的版本是经过全面测试的。</li><li>其他需要全量回归的场景，如：机房迁移，新环境部署…</li></ul><h3 id="增量覆盖率"><a href="#增量覆盖率" class="headerlink" title="增量覆盖率"></a>增量覆盖率</h3><p>jacoco本身是不支持增量代码覆盖率的，但是可以通过二开或者使用其他的开源工具实现增量覆盖率报告生成。<br>适用场景：</p><ul><li>快速迭代测试：在项目快速迭代的情况下，仅针对新增或修改的代码进行增量代码覆盖率分析能够快速确定这些变动的测试覆盖程度，以便加快迭代速度。</li><li>高频更新验证：对于经常更新的代码库，每次都进行全量代码覆盖率分析可能会产生高昂的计算和执行成本。使用增量代码覆盖率可以更快地了解测试覆盖的变化情况，以便快速验证新增功能的正确性和稳定性。</li><li>增量测试补充：当时间有限而需求变动时，增量代码覆盖率可用于快速确定需求变动对现有测试覆盖的影响，并有针对性地补充和调整测试用例，以覆盖新增或修改的代码。</li></ul><h2 id="建设思路"><a href="#建设思路" class="headerlink" title="建设思路"></a>建设思路</h2><ul><li>目标：为整个中心不同部门&#x2F;项目组提供统一的Java 代码覆盖率收集能力</li><li>前期准备：</li></ul><ol><li>收集试点项目的技术栈，包括：开发框架，部署架构。</li><li>了解不同项目组对代码覆盖率的使用场景，比如 TL 关心开发提交的代码是否夹带私货，是否存在 dead code。测试人员或者产品经理关心是否测试全面，想通过代码的变更点推导出业务上的影响面。开发人员关心自己本个迭代提交的代码是否都测试完全等。</li></ol><ul><li>技术选型：</li></ul><ol><li>后端开发技术栈：Springboot，JacocoCli，Jgit，MavenCli，GradleToolingApi，MySQL，MyBatis</li><li>前端开发技术栈：vue2</li></ol><h2 id="应用架构设计-业务视角"><a href="#应用架构设计-业务视角" class="headerlink" title="应用架构设计(业务视角)"></a>应用架构设计(业务视角)</h2><p>业务架构图不方便贴，就说下基本流程：</p><ol><li>配置凭据，即Git 账号和密码，此处使用类似 Jenkins 凭据的方式来管理。</li><li>配置服务信息，如服务名称，git 仓库地址，环境类型，dump 端口(jacocoagent启动端口)，ip 列表(同一个服务在不同环境有不同 ip，而且可能是多实例部署)，选择凭据。</li><li>配置覆盖率采集任务，选择环境自动带出此环境下面的服务列表，填写任务名称，迭代信息，在选择服务的时候要选择分支，如果是增量覆盖率，则需要选择采集分支和基准分支，如果是全量覆盖率，则选择采集分支即可。</li><li>执行采集任务，生成执行记录和覆盖率报告。</li></ol><h2 id="应用架构设计-技术视角"><a href="#应用架构设计-技术视角" class="headerlink" title="应用架构设计(技术视角)"></a>应用架构设计(技术视角)</h2><p>代码覆盖率只是整个测试平台的一个服务，测试平台使用 SBA 架构(服务导向的架构)，整个平台架构图如下所示：</p><p><img src="/../images/2iKFxtHv2H7AFD1wybrWrGG9.jpg" alt="image.png"></p><p>代码覆盖率量子中只包含一个代码覆盖率容器，配合插件层的 jacocoagent 插件来协同工作。</p><h2 id="安全方案"><a href="#安全方案" class="headerlink" title="安全方案"></a>安全方案</h2><p>代码覆盖率收集服务，主要业务是：根据用户配置的代码库地址和GIT账密来收集 Java 应用服务在某个时间段内的代码覆盖情况。其中会涉及到用户在平台上填写以下数据：</p><ul><li>代码库地址(以下简称 代码库)</li><li>GIT账号和密码(以下简称 凭据)</li></ul><p>同时生成的覆盖率报告会包含部分&#x2F;所有的代码信息，因此需要对覆盖率报告也做数据权限的管控。<br>因为测试平台使用多租户模式，所以不同的租户下面数据是完全隔离的，不存在跨租户访问数据的情况，只需要解决水平越权和垂直越权的安全问题即可。</p><p>因为安全方案涉及到公司内部数据，所以只给出以下思路：</p><ol><li>菜单权限&#x2F;api权限：可以基于 Spring Security实现，或者其他安全框架实现</li><li>数据权限：对接口中的入参 by 租户进行校验，不允许访问未授权的测试库数据</li><li>数据安全：对 GIT 密码进行加密保存，可以选择 DES 或者 RSA 非对称加密</li></ol><h2 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h2><p><img src="/../images/yLm9v8FXQubNswNKX75cxkcu.jpg" alt="image.png"></p><h2 id="代码覆盖率收集过程"><a href="#代码覆盖率收集过程" class="headerlink" title="代码覆盖率收集过程"></a>代码覆盖率收集过程</h2><h3 id="Step-1：代码插桩"><a href="#Step-1：代码插桩" class="headerlink" title="Step-1：代码插桩"></a>Step-1：代码插桩</h3><p>代码覆盖率收集过程基于 jacoco 的插桩来实现，jacoco 支持 2 中插桩方式：</p><h4 id="On-the-fly-模式（即时模式）："><a href="#On-the-fly-模式（即时模式）：" class="headerlink" title="On-the-fly 模式（即时模式）："></a>On-the-fly 模式（即时模式）：</h4><p>插桩时机：在应用程序运行时，通过 Java 代理（Java Agent）将 JaCoCo 注入到 JVM 中。<br>数据收集方式：实时地收集代码覆盖率数据，即时生成运行时的覆盖率报告。</p><p>优点：</p><ul><li>可以实时地监测应用程序的执行和覆盖率情况。</li><li>不需要对代码进行重新编译，使得在现有项目中使用更为方便。</li></ul><p>缺点：</p><ul><li>在运行时对字节码进行修改，可能会对应用程序的性能产生一定影响。</li><li>数据收集和报告生成过程会占用一些 CPU 和内存资源。</li></ul><h4 id="Offline-模式（离线模式）："><a href="#Offline-模式（离线模式）：" class="headerlink" title="Offline 模式（离线模式）："></a>Offline 模式（离线模式）：</h4><p>插桩时机：在构建过程中对项目的字节码进行修改，通过构建工具（如 Maven 或 Gradle）进行插桩。<br>数据收集方式：在应用程序运行时，JaCoCo 会收集覆盖率数据并将其保存到执行文件中（通常是一个二进制格式的 .exec 文件）。</p><p>优点：</p><ul><li>不会对应用程序的运行性能造成直接影响。</li><li>可以在构建过程中自动插桩，方便集成到自动化构建和持续集成流程中。</li></ul><p>缺点：</p><ul><li>需要对项目进行重新编译，可能会增加构建过程的时间和开销。</li><li>需要对执行文件进行处理，生成可读性更好的覆盖率报告。</li></ul><h3 id="Step-2：生成-exec-文件"><a href="#Step-2：生成-exec-文件" class="headerlink" title="Step-2：生成 exec 文件"></a>Step-2：生成 exec 文件</h3><p>exec 文件是 jacoco 默认的覆盖率数据文件类型，使用 on-the-fly 模式时，可以通过 Socket连接的方式，从远程服务器(即部署了 jacocoagent 的服务器) 上下载 exec 文件。JaCoCo 生成的 exec 文件是二进制文件，其中包含了代码覆盖率数据。它的结构如下：</p><p>Header（文件头部）：包含了 exec 文件的元数据信息，如版本号和会话标识符。<br>Sessions（会话信息）：存储了测试会话的信息，每个会话都有一个唯一的会话标识符。<br>Probes（探针信息）：存储了所有被覆盖的代码块的信息。每个代码块都有一个唯一的标识符，并且将内联代码的情况进行了处理。<br>Execution Data（执行数据）：实际的代码覆盖率数据。它记录了每个代码块是否被执行过。<br>具体来说，Header 部分包括以下信息：</p><p>Magic Number：一个特殊的标识符，用于识别文件类型。<br>Version：exec 文件的版本号。<br>Session Count：会话数量。<br>Session Infos：会话信息的起始位置。<br>Probe Count：探针数量。<br>Probe Infos：探针信息的起始位置。<br>Sessions 部分包括了每个会话的信息，例如会话标识符和会话名称。</p><p>Probes 部分包括了每个被覆盖的代码块的信息，例如代码块的标识符和分支相关的信息。</p><p>Execution Data 部分包括了实际的代码覆盖率数据，记录了每个代码块是否被执行过。</p><h3 id="Step-3：代码差异比对-增量覆盖率才有此步骤"><a href="#Step-3：代码差异比对-增量覆盖率才有此步骤" class="headerlink" title="Step-3：代码差异比对(增量覆盖率才有此步骤)"></a>Step-3：代码差异比对(增量覆盖率才有此步骤)</h3><p>code-diff 阶段用于比对代码差异，进而分析出代码变更点。代码变更包括以下几种情况：</p><p>新增，修改，删除不会被统计在内，因为文件已经被删除，不会产生覆盖率数据。如果是全量覆盖率报告生成，则会跳过此阶段。code-diff 功能使用 jgit 库和 javaparser 库的 API 实现。code-diff 流程如下：</p><p>下载采集分支代码，即新分支，如 feature，develop 等。<br>下载基准分支代码，即需要与之比较的分支，一般是 master 或者 release 等稳定分支。<br>使用 jgit 获取变更过得文件，即 java 源文件。<br>使用 javaparser 获取变更的类和方法，并记录方法信息(方法名，包名，方法签名等)。<br>生成 code-diff文件，用于后面生成增量报告。</p><h3 id="Step-4：代码编译"><a href="#Step-4：代码编译" class="headerlink" title="Step-4：代码编译"></a>Step-4：代码编译</h3><p>代码编译过程用于将 java 源代码编译成 class 文件，用于生成覆盖率报告，在生成 JaCoCo 报告时，需要使用 class 文件和源码文件主要是为了对覆盖率数据进行解析和展示。</p><p>Class 文件：JaCoCo 通过分析 class 文件来获取代码结构和字节码信息。它包含了类、方法和字段的定义、修饰符以及字节码指令等信息。通过分析 class 文件，JaCoCo 可以确定每个代码块（如行、分支等）的起始和结束位置。</p><p>源码文件：源码文件是编写程序的原始文件，其中包含了开发人员编写的代码。在生成覆盖率报告时，JaCoCo 将覆盖率数据与源码文件进行关联，并进行代码染色，以显示被执行和未执行的代码行。这样，开发人员可以清楚地看到哪些行被覆盖，哪些行未被覆盖。本服务支持 Gradle 项目和 maven 项目编译，编译工具版本如下：</p><ul><li>JDK：jdk11，jdk8</li><li>Gradle：gradle 7, gradle 6, gradle 5</li><li>Maven：maven 3.6.1</li></ul><h3 id="Step-5：报告生成"><a href="#Step-5：报告生成" class="headerlink" title="Step-5：报告生成"></a>Step-5：报告生成</h3><p>支持增量报告和全量报告生成。增量报告用于比较不同版本之间代码差异和覆盖率情况，全量报告直接展示新版本代码覆盖率情况。两种报告使用场景如下：</p><p>增量报告：</p><ul><li>新迭代差异代码覆盖情况，一般用于开发自测，检查变更的代码是否被执行</li></ul><p>全量报告：</p><ul><li>SIT 测试，通过代码覆盖情况间接表示功能覆盖情况</li><li>全量回归测试，比如机房迁移，项目重构等，会统计此分支下所有代码的执行情况</li></ul><h2 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h2><h3 id="代码同步"><a href="#代码同步" class="headerlink" title="代码同步"></a>代码同步</h3><p>直接使用 Jgit 即可，Maven 坐标如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jgit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>org.eclipse.jgit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.5.0.202303070854-r<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>示例代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">clone</span><span class="params">(String repoUrl, String branch, String localPath, String username, String password)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始克隆代码，代码库地址: &#123;&#125;&quot;</span>, repoUrl);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">CredentialsProvider</span> <span class="variable">credentialsProvider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordCredentialsProvider</span>(username, EncryptUtil.decryptByDes(password, desKey));</span><br><span class="line">        <span class="type">String</span> <span class="variable">savePath</span> <span class="operator">=</span> CoverageConstant.GIT_CLONE_TEMP_PATH + localPath;</span><br><span class="line">        log.info(<span class="string">&quot;git clone repoUrl: &#123;&#125;, branch: &#123;&#125;, savePath: &#123;&#125;&quot;</span>, repoUrl, branch, savePath);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Git</span> <span class="variable">ignored</span> <span class="operator">=</span> Git.cloneRepository()</span><br><span class="line">                .setURI(repoUrl)</span><br><span class="line">                .setBranch(branch)</span><br><span class="line">                .setCredentialsProvider(credentialsProvider)</span><br><span class="line">                .setDirectory(<span class="keyword">new</span> <span class="title class_">File</span>(savePath))</span><br><span class="line">                .setDepth(<span class="number">1</span>)</span><br><span class="line">                .setCloneAllBranches(<span class="literal">false</span>)</span><br><span class="line">                .call()) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;git clone success&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Git clone 异常,异常详情: &#123;&#125;&quot;</span>, ExceptionUtil.getErrorMessage(e));</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(<span class="string">&quot;Git clone 异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;代码克隆完成，耗时: &#123;&#125; s, 代码库地址: &#123;&#125;&quot;</span>, (System.currentTimeMillis() - startTime) / <span class="number">1000</span>, repoUrl);</span><br><span class="line">        <span class="keyword">return</span> savePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="代码编译"><a href="#代码编译" class="headerlink" title="代码编译"></a>代码编译</h3><h4 id="Maven-项目编译"><a href="#Maven-项目编译" class="headerlink" title="Maven 项目编译"></a>Maven 项目编译</h4><p>Maven 项目使用 Maven embedder 进行编译<br>Maven 坐标如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-embedder<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsr250-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.resolver<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resolver-connector-basic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.resolver<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resolver-transport-http<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>示例代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MavenBuildManagerImpl</span> <span class="keyword">implements</span> <span class="title class_">MavenBuildManager</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compiler</span><span class="params">(String codePath, List&lt;String&gt; commands)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始编译Maven项目，代码路径: &#123;&#125;, 编译参数: &#123;&#125;&quot;</span>, codePath, commands);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">File</span> <span class="variable">codeFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(codePath);</span><br><span class="line">        <span class="keyword">if</span> (!codeFile.exists()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(<span class="string">&quot;代码路径不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">MavenCli</span> <span class="variable">cli</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MavenCli</span>();</span><br><span class="line">        System.getProperties().setProperty(MavenCli.MULTIMODULE_PROJECT_DIRECTORY, MavenCli.USER_MAVEN_CONFIGURATION_HOME.getAbsolutePath());</span><br><span class="line">        <span class="comment">// 重定向标准错误输出流</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">errorStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">originalErrStream</span> <span class="operator">=</span> System.err;</span><br><span class="line">        System.setErr(<span class="keyword">new</span> <span class="title class_">PrintStream</span>(errorStream));</span><br><span class="line">        <span class="type">int</span> <span class="variable">statusCode</span> <span class="operator">=</span> cli.doMain(commands.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]), codePath, System.out, System.err);</span><br><span class="line">        <span class="comment">// 恢复标准错误输出流</span></span><br><span class="line">        System.setErr(originalErrStream);</span><br><span class="line">        <span class="keyword">if</span> (statusCode != <span class="number">0</span>) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;代码: &#123;&#125; 编译失败, 异常详情: &#123;&#125;&quot;</span>, codePath, errorStream);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(<span class="string">&quot;编译失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;结束编译Maven项目，编译耗时: &#123;&#125; s&quot;</span>, (System.currentTimeMillis() - startTime) / <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多模块代码扫描</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> codePath 代码路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 模块列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">modules</span><span class="params">(String codePath)</span> &#123;</span><br><span class="line">        List&lt;String&gt; modules;</span><br><span class="line">        <span class="type">File</span> <span class="variable">pomFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(codePath, <span class="string">&quot;pom.xml&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MavenXpp3Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MavenXpp3Reader</span>();</span><br><span class="line">            <span class="type">Model</span> <span class="variable">model</span> <span class="operator">=</span> reader.read(<span class="keyword">new</span> <span class="title class_">FileReader</span>(pomFile));</span><br><span class="line">            modules = model.getModules();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;代码: &#123;&#125; 模块扫描失败, 异常详情: &#123;&#125;&quot;</span>, codePath, ExceptionUtil.getErrorMessage(e));</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(<span class="string">&quot;模块扫描失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> modules;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MavenCommand</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * maven命令</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MVN</span> <span class="operator">=</span> <span class="string">&quot;mvn&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清理构建产物</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CLEAN</span> <span class="operator">=</span> <span class="string">&quot;clean&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编译 class 文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">COMPILE</span> <span class="operator">=</span> <span class="string">&quot;compile&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打包</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PACKAGE</span> <span class="operator">=</span> <span class="string">&quot;package&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跳过测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SKIP_TEST</span> <span class="operator">=</span> <span class="string">&quot;-Dmaven.test.skip=true&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BATCH_MODE</span> <span class="operator">=</span> <span class="string">&quot;--batch-mode&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多核编译</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PARALLEL</span> <span class="operator">=</span> <span class="string">&quot;-T 1C&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多线程编译</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FORK</span> <span class="operator">=</span> <span class="string">&quot;-Dmaven.compile.fork=true&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通用编译命令</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; COMMAND = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()&#123;&#123;</span><br><span class="line">        add(CLEAN);</span><br><span class="line">        add(COMPILE);</span><br><span class="line">        add(SKIP_TEST);</span><br><span class="line">        add(BATCH_MODE);</span><br><span class="line">        add(PARALLEL);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Gradle-项目编译"><a href="#Gradle-项目编译" class="headerlink" title="Gradle 项目编译"></a>Gradle 项目编译</h4><p>Gradle 项目使用 gradle tooling api进行编译<br>Maven 坐标如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.netbeans.external<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gradle-tooling-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>RELEASE170<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>示例代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GradleBuildManagerImpl</span> <span class="keyword">implements</span> <span class="title class_">GradleBuildManager</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compiler</span><span class="params">(String gradlePath, String codePath, List&lt;String&gt; commands)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始编译Gradle项目，编译工具路径: &#123;&#125;，代码路径: &#123;&#125;, 编译参数: &#123;&#125;&quot;</span>, gradlePath, codePath, commands);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 重定向标准错误输出流</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">errorStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">originalErrStream</span> <span class="operator">=</span> System.err;</span><br><span class="line">        <span class="comment">// 重定向标准输出流</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">originalOutStream</span> <span class="operator">=</span> System.out;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ProjectConnection</span> <span class="variable">connection</span> <span class="operator">=</span> GradleConnector.newConnector()</span><br><span class="line">                .forProjectDirectory(<span class="keyword">new</span> <span class="title class_">File</span>(codePath))</span><br><span class="line">                .useGradleUserHomeDir(CoverageConstant.DEFAULT_GRADLE_USER_HOME)</span><br><span class="line">                .useInstallation(<span class="keyword">new</span> <span class="title class_">File</span>(gradlePath))</span><br><span class="line">                .connect()) &#123;</span><br><span class="line">            <span class="type">BuildLauncher</span> <span class="variable">build</span> <span class="operator">=</span> connection.newBuild();</span><br><span class="line">            System.setErr(<span class="keyword">new</span> <span class="title class_">PrintStream</span>(errorStream));</span><br><span class="line">            System.setOut(<span class="keyword">new</span> <span class="title class_">PrintStream</span>(outputStream));</span><br><span class="line">            build.forTasks(commands.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]))</span><br><span class="line">                    .setStandardOutput(System.out)</span><br><span class="line">                    .setStandardError(System.err)</span><br><span class="line">                    <span class="comment">// 跳过单测，多线程编译</span></span><br><span class="line">                    .withArguments(GradleCommand.EXCLUDE, GradleCommand.TEST)</span><br><span class="line">                    <span class="comment">// 不使用彩色日志，否则会导致日志中的颜色代码被打印出来，导致日志不易阅读</span></span><br><span class="line">                    .setColorOutput(<span class="literal">false</span>)</span><br><span class="line">                    <span class="comment">// 限制 gradle 内存，防止编译过程中内存溢出</span></span><br><span class="line">                    .setJvmArguments(<span class="string">&quot;-Xmx512m&quot;</span>);</span><br><span class="line">            build.run();</span><br><span class="line">            log.info(<span class="string">&quot;编译日志:\n &#123;&#125;&quot;</span>, outputStream);</span><br><span class="line">            System.setErr(originalErrStream);</span><br><span class="line">            System.setOut(originalOutStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;代码: &#123;&#125; 编译失败, 异常详情: &#123;&#125;&quot;</span>, codePath, ExceptionUtil.getErrorMessage(e));</span><br><span class="line">            log.error(<span class="string">&quot;编译异常日志:\n &#123;&#125;&quot;</span>, errorStream);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(<span class="string">&quot;编译失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;结束编译Gradle项目，编译耗时: &#123;&#125; s&quot;</span>, (System.currentTimeMillis() - startTime) / <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">modules</span><span class="params">(String gradlePath, String codePath)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始扫描Gradle项目模块，编译工具路径: &#123;&#125;，代码路径: &#123;&#125;&quot;</span>, gradlePath, codePath);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ProjectConnection</span> <span class="variable">connection</span> <span class="operator">=</span> GradleConnector.newConnector()</span><br><span class="line">                .forProjectDirectory(<span class="keyword">new</span> <span class="title class_">File</span>(codePath))</span><br><span class="line">                .useInstallation(<span class="keyword">new</span> <span class="title class_">File</span>(gradlePath))</span><br><span class="line">                .connect()) &#123;</span><br><span class="line">            <span class="type">GradleProject</span> <span class="variable">model</span> <span class="operator">=</span> connection.getModel(GradleProject.class);</span><br><span class="line">            <span class="keyword">return</span> model.getChildren().stream().map(GradleProject::getName).collect(Collectors.toList());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;代码: &#123;&#125; 模块扫描失败, 异常详情: &#123;&#125;&quot;</span>, codePath, ExceptionUtil.getErrorMessage(e));</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(<span class="string">&quot;模块扫描失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GradleCommand</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * gradle命令</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">GRADLE</span> <span class="operator">=</span> <span class="string">&quot;gradle&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清理构建产物</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CLEAN</span> <span class="operator">=</span> <span class="string">&quot;clean&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打包</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BUILD</span> <span class="operator">=</span> <span class="string">&quot;build&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排除某个任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCLUDE</span> <span class="operator">=</span> <span class="string">&quot;-x&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TEST</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多线程编译</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PARALLEL</span> <span class="operator">=</span> <span class="string">&quot;-Dorg.gradle.parallel=true&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多进程编译</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FORK</span> <span class="operator">=</span> <span class="string">&quot;-Dorg.gradle.fork=true&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编译class文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CLASSES</span> <span class="operator">=</span> <span class="string">&quot;classes&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通用编译命令</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; COMMAND = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()&#123;&#123;</span><br><span class="line">        add(CLEAN);</span><br><span class="line">        add(CLASSES);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="差异代码比对"><a href="#差异代码比对" class="headerlink" title="差异代码比对"></a>差异代码比对</h3><p>直接参考这个就好：<a href="https://gitee.com/Dray/code-diff/blob/master/src/main/java/com/dr/code/diff/service/impl/CodeDiffServiceImpl.java">https://gitee.com/Dray/code-diff/blob/master/src/main/java/com/dr/code/diff/service/impl/CodeDiffServiceImpl.java</a><br>原理就是直接通过jgit 分析出变更的文件，然后通过 javaparser 来分析代码</p><h3 id="覆盖率报告生成"><a href="#覆盖率报告生成" class="headerlink" title="覆盖率报告生成"></a>覆盖率报告生成</h3><p>生成报告参考这个：<a href="https://gitee.com/Dray/code-diff/blob/master/src/main/java/com/dr/code/diff/jacoco/report/ReportAction.java">https://gitee.com/Dray/code-diff/blob/master/src/main/java/com/dr/code/diff/jacoco/report/ReportAction.java</a><br>但是里面涉及到差异报告生成，就需要使用这个仓库提供的 jar 了</p><h2 id="覆盖率报告解读"><a href="#覆盖率报告解读" class="headerlink" title="覆盖率报告解读"></a>覆盖率报告解读</h2><h3 id="全量覆盖率报告"><a href="#全量覆盖率报告" class="headerlink" title="全量覆盖率报告"></a>全量覆盖率报告</h3><h4 id="报告总览"><a href="#报告总览" class="headerlink" title="报告总览"></a>报告总览</h4><p><img src="/../images/3QSitfQz8xy1rjrZeT1Loxhs.png" alt="image.png"></p><ol><li>Element：被覆盖和测量的代码元素，通常是源代码的各种层级，比如 模块，包，类，方法。其实在jacoco的报告中，也是按照上面的层级逐步深入展示覆盖率报告的。</li><li>Instructions：指令覆盖，Java 字节指令的覆盖率。执行的最小单位，和代码的格式无关。</li><li>Branches：分支覆盖，如if分支，switch分支等。</li><li>Cxty：圈复杂度，Jacoco 会为每一个非抽象方法计算圈复杂度，并为类，包以及组（groups）计算复杂度。圈复杂度简单地说就是为了覆盖所有路径，所需要执行单元测试数量，圈复杂度大说明程序代码可能质量低且难于测试和维护。</li><li>Lines：行覆盖，只要本行有一条指令被执行，则本行则被标记为被执行。</li><li>Methods：方法覆盖，任何非抽象的方法，只要有一条指令被执行，则该方法就会被计为被执行。</li><li>Classes：类覆盖，所有类，包括接口，只要其中有一个方法被执行，则标记为被执行。注意：构造函数和静态初始化块也算作方法。</li><li>覆盖率数据：注意，上图中 1432 of 28186 94% 表示的意思是 一共有28186条指令，其中有1432条指令没有执行，94%≈(28186-1432)&#x2F;28186 * 100%</li></ol><h4 id="背景色及标记"><a href="#背景色及标记" class="headerlink" title="背景色及标记"></a>背景色及标记</h4><p>由于单行通常编译为多个字节代码指令，源代码突出显示为包含源代码的每行显示三种不同的状态</p><p>背景色：</p><ul><li>无覆盖：该行没有指令被执行（红色背景）</li><li>部分覆盖：仅执行了该行的部分指令（黄色背景）</li><li>全覆盖：该行所有指令均已执行（绿色背景）</li></ul><p>菱形标记：</p><ul><li>绿色菱形：这一行的所有分支都被执行</li><li>黄色菱形：这一行的分支中只有一部分被执行</li><li>红色菱形：在这一行中没有分支被执行</li></ul><p><img src="/../images/xKmTQwzgyHGMiDVCzNmwDe2z.png" alt="image.png"></p><p><img src="/../images/hCRXbhQguPR52jrdxQyekrM8.png" alt="image.png"></p><h3 id="增量覆盖率报告"><a href="#增量覆盖率报告" class="headerlink" title="增量覆盖率报告"></a>增量覆盖率报告</h3><p>增量覆盖率报告与全量覆盖率报告大体一致，只有部分标记存在差异。</p><ul><li>蓝色加号：新增的代码</li><li>黄色铅笔：修改过的代码</li></ul><p><img src="/../images/WRMqo5DnDnHg7HgYi9BvcNbD.png" alt="image.png"></p><h2 id="代码覆盖率接入常见问题"><a href="#代码覆盖率接入常见问题" class="headerlink" title="代码覆盖率接入常见问题"></a>代码覆盖率接入常见问题</h2><p>jacoco官方本身提供了FA&amp;Q，绝大多数覆盖率相关的问题都可以在这边找到，只有以下比较特殊的场景需要注意：</p><h3 id="反射导致的服务启动失败或者接口调用失败"><a href="#反射导致的服务启动失败或者接口调用失败" class="headerlink" title="反射导致的服务启动失败或者接口调用失败"></a>反射导致的服务启动失败或者接口调用失败</h3><p>jacoco不管是以何种方式运行，都会在class中插入static boolean[] $jacocoData 和 $jacocoInit() 来记录覆盖率数据。当我们使用反射来获取一个类的属性和方法时，很容易就获取到这两个特殊的Field，比如通过一个类来保存JDBC配置的时候，就会读到$jacocoData，导致jdbc连接失败。为了解决这个问题，需要在使用反射的地方通过如下方法处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ChromeDriver</span> <span class="variable">chromeDriver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChromeDriver</span>();</span><br><span class="line">    Field[] declaredFields = chromeDriver.getClass().getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">        <span class="keyword">if</span> (declaredField.isSynthetic()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前属性: &quot;</span>+ declaredField.getName() +<span class="string">&quot;为合成属性，跳过...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Method[] declaredMethods = chromeDriver.getClass().getDeclaredMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line">        <span class="keyword">if</span> (declaredMethod.isSynthetic()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前方法: &quot;</span>+ declaredMethod.getName() +<span class="string">&quot;为合成方法，跳过...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关于 isSynthetic() 的解释可以参考：<a href="https://learn.microsoft.com/zh-cn/dotnet/api/java.lang.class.issynthetic">Class.IsSynthetic 属性 (Java.Lang)</a></p></blockquote><h2 id="写在最后的话"><a href="#写在最后的话" class="headerlink" title="写在最后的话"></a>写在最后的话</h2><p>准备提桶了，没啥心情写了，就先写这么多吧，希望诸位都能找到合适的工作<br>PS：代码编译比较耗费资源，记得改成 mq，触发任务采集的时候通过 mq 来做任务排队</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li><a href="https://www.jacoco.org/jacoco/trunk/doc/">https://www.jacoco.org/jacoco/trunk/doc/</a></li><li><a href="https://gitee.com/Dray/jacoco">https://gitee.com/Dray/jacoco</a></li><li><a href="https://gitee.com/Dray/code-diff">https://gitee.com/Dray/code-diff</a></li><li><a href="https://blog.csdn.net/Huang1178387848/article/details/114399056">https://blog.csdn.net/Huang1178387848/article/details/114399056</a></li><li><a href="https://maven.apache.org/ref/3-LATEST/maven-embedder/index.html">https://maven.apache.org/ref/3-LATEST/maven-embedder/index.html</a></li><li><a href="https://blog.csdn.net/ByteDanceTech/article/details/123059368">https://blog.csdn.net/ByteDanceTech/article/details/123059368</a></li><li><a href="https://www.jacoco.org/jacoco/trunk/doc/mission.html">https://www.jacoco.org/jacoco/trunk/doc/mission.html</a></li><li><a href="https://www.jacoco.org/jacoco/trunk/doc/counters.html">https://www.jacoco.org/jacoco/trunk/doc/counters.html</a></li><li><a href="https://www.jacoco.org/jacoco/trunk/doc/agent.html">https://www.jacoco.org/jacoco/trunk/doc/agent.html</a></li><li><a href="https://www.jacoco.org/jacoco/trunk/doc/cli.html">https://www.jacoco.org/jacoco/trunk/doc/cli.html</a></li><li><a href="https://www.jacoco.org/jacoco/trunk/doc/faq.html">https://www.jacoco.org/jacoco/trunk/doc/faq.html</a></li><li><a href="https://blog.csdn.net/tushuping/article/details/134347325">https://blog.csdn.net/tushuping/article/details/134347325</a></li><li><a href="https://blog.csdn.net/tushuping/article/details/112613528">https://blog.csdn.net/tushuping/article/details/112613528</a></li><li><a href="https://blog.csdn.net/tushuping/article/details/131640959">https://blog.csdn.net/tushuping/article/details/131640959</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;下半年开始搞精准测试了，先搞一波代码覆盖率，因为公司绝大多数项目都是基于 Java 开发的，所以就先搞 Java 的了，主流的代码覆盖率工具</summary>
      
    
    
    
    
    <category term="代码覆盖率" scheme="https://linvaux.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>Java中的异常处理</title>
    <link href="https://linvaux.github.io/posts/22260569/"/>
    <id>https://linvaux.github.io/posts/22260569/</id>
    <published>2023-08-22T14:37:04.000Z</published>
    <updated>2024-09-21T00:59:08.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Java-中的异常分类"><a href="#1-Java-中的异常分类" class="headerlink" title="1. Java 中的异常分类"></a>1. Java 中的异常分类</h2><p>Java中的异常类均以<code>Throwable</code>为父类，而<code>Throwable</code>又派生出 <code>Error</code> 和 <code>Exception</code> 两类，区别如下</p><h3 id="1-1-Error类及其子类"><a href="#1-1-Error类及其子类" class="headerlink" title="1.1 Error类及其子类"></a>1.1 Error类及其子类</h3><p>代表了JVM自身的异常。这一类异常发生时，无法通过程序来修正。例如系统崩溃、内存溢出等。与异常不同，错误表示程序无法继续执行下去，一般不需要进行捕获或处理。错误通常是由底层系统或环境导致的，它们是不可控的，最可靠的方式就是尽快地停止JVM的运行。</p><h3 id="1-2-Exception类及其子类"><a href="#1-2-Exception类及其子类" class="headerlink" title="1.2 Exception类及其子类"></a>1.2 Exception类及其子类</h3><p>Exception又分为运行时异常(RuntimeException)和非运行时异常， 这两种异常有很大的区别，也称之为非受检异常（Unchecked Exception）和受检异常（Checked Exception），其中Error类及其子类也是非受检异常。</p><ul><li><p>受检异常：也称为“编译时异常”，编译器在编译期间检查的那些异常。由于编译器“检查”这些异常以确保它们得到处理，因此称为“检查异常”。如果抛出检查异常，那么编译器会报错，需要开发人员手动处理该异常，要么捕获，要么重新抛出。除了RuntimeException之外，所有直接继承 Exception 的异常都是检查异常。</p></li><li><p>非受检异常：也称为“运行时异常”，编译器不会检查运行时异常，在抛出运行时异常时编译器不会报错，当运行程序的时候才可能抛出该异常。Error及其子类和RuntimeException 及其子类都是非检查异常。</p></li></ul><p>Java 中异常类的关系可以使用如下 UML 类图表示</p><p><img src="/../images/RSJZr3SoDnMvxRTsYPSYUAbL.jpg" alt="iShot_2023-08-12_22.18.46.jpg"></p><p>受检异常和非受检异常是<strong>针对编译器而言</strong>的，是编译器来检查该异常是否强制开发人员处理该异常：</p><ul><li><p>受检异常导致异常在方法调用链上显式传递，而且一旦底层接口的检查异常声明发生变化，会导致整个调用链代码更改。</p></li><li><p>使用非受检异常不会影响方法签名，而且调用方可以自由决定何时何地捕获和处理异常。</p></li></ul><h3 id="1-3-受检异常举例"><a href="#1-3-受检异常举例" class="headerlink" title="1.3 受检异常举例"></a>1.3 受检异常举例</h3><p><img src="/../images/JUnWSvCKCGJaDAoEHbz7J8Dh.png" alt="image-20230813204926255.png"></p><p>编译器提示需要处理这个异常，这种异常处理有两种方式：</p><ul><li>在方法签名上抛出此异常，由方法调用方处理</li><li>使用try-catch 捕获异常，内部处理</li></ul><p><img src="/../images/4P95pTbDCLK8xM7iB8qFj18y.png" alt="image-20230813205125690.png"></p><h3 id="1-4-非受检异常异常举例"><a href="#1-4-非受检异常异常举例" class="headerlink" title="1.4 非受检异常异常举例"></a>1.4 非受检异常异常举例</h3><p>所有继承 RuntimeException 的异常都是非检查异常，直接抛出非检查异常编译器不会提示错误</p><p><img src="/../images/te9ERq1jwweWzM9thmsDLofA.png" alt="image-20230813205245428.png"></p><p>方法直接抛出 RuntimeException 时，编译器并不会要求捕获或者抛出此异常。</p><h2 id="2-try-catch"><a href="#2-try-catch" class="headerlink" title="2. try-catch"></a>2. try-catch</h2><p><code>try-catch</code> 关键字在Java 中主要用于捕获异常，并进行处理。简单示例如下：</p><p><img src="/../images/jXqNSRgto7wGUhnhMp8y2jtx.png" alt="image-20230813205659417.png"></p><p>在 try{} 代码块中，是<code>可能抛出异常的代码</code>或者<code>调用了签名上会抛出异常的方法</code>。cath{} 代码块中则是捕获异常，并处理异常。注意：catch 可以捕获多种异常，并根据异常种类不同，分开处理，但是要注意异常捕获的顺序。</p><p><img src="/../images/EGpWhJJZ3N4jdHGZP2LF7Ysi.png" alt="image-20230813210343797.png"></p><p>在上面的示例中，先捕获了 IOException，IDE 就会提示下面的 FileNotFoundException 无需再被捕获了，因为 IOException 是 FileNotFoundException 的父类，捕获到 IOException 之后，其所有子类的异常捕获代码都会失效。</p><p>下面演示如何同时捕获多个异常，并用同一个分支处理：</p><p><img src="/../images/KVcDnv2hpWYPuiBc2z7qkThn.png" alt="image-20230813210712437.png"></p><p>当我们需要对多个异常分组处理时，可以使用 catch(Exception1 | Exception2 e) 来捕获多个异常。</p><h2 id="3-try-catch-finally"><a href="#3-try-catch-finally" class="headerlink" title="3. try-catch-finally"></a>3. try-catch-finally</h2><p><code>try-catch-finally</code> 用于在处理异常时，不管是否发生异常，都要执行的操作。示例代码如下：</p><p>try 代码块中发生了异常：</p><p><img src="/../images/dUmSNsByvnVVrsaWWZziaVTg.png" alt="image-20230813211231664.png"></p><p>提问：为什么先打印了 finally 代码块中的内容，后打印了异常信息？</p><p>try 代码块未异常：</p><p><img src="/../images/V74wz11U8VaYzGQn3btdE8DY.png" alt="image-20230813211411419.png"></p><p>finally{} 一般用于资源的关闭，或者数据的清理， 但是也可以在 finally 中执行 return 命令来修改方法返回。示例代码如下：</p><p><img src="/../images/5Gbu8v6JxCjpqJFbhN1NSokh.png" alt="image-20230813211910857.png"></p><p>提问：大家觉得这个cal 方法返回值是多少？为什么？</p><p>正常情况下，finally 代码块中的代码一定是会执行的，但是也有以下几种失效情况：</p><ol><li><p>在执行 try 或 catch 块之前 JVM 被非法终止，比如程序正在运行，但是使用 pkill -9 java 命令强行停止 Java 进程。</p></li><li><p>在 try 或 catch 块中发生了 System.exit() 调用，导致 JVM 直接退出。</p></li></ol><p><img src="/../images/Emqodm5VB2TopcwNG8YeBGYm.png" alt="image-20230813212533105.png"></p><ol start="3"><li><p>在 try 或 catch 块中发生了死循环，导致程序无法继续执行。</p></li><li><p>在 try 或 catch 块中发生了栈溢出异常（StackOverflowError）或虚拟机异常（如 OutOfMemoryError），导致 JVM 崩溃。</p></li><li><p>程序所在的线程被强制中断或程序进程被操作系统杀死。</p></li><li><p>在 try 或 catch 块中使用了 System.halt() 方法，显式终止 JVM。</p></li><li><p>调用了 native 方法，而该方法中不包含 finally 块。</p></li></ol><h2 id="4-try-with-resources-用法"><a href="#4-try-with-resources-用法" class="headerlink" title="4. try-with-resources 用法"></a>4. try-with-resources 用法</h2><p><code>try-with-resources</code> 是 Java 7 引入的一个语法结构，用于更加方便地处理需要关闭的资源。它可以自动关闭实现了 <code>AutoCloseable</code> 或 <code>Closeable</code> 接口的资源，无需手动编写 finally 块来关闭资源。try-with-resources 的语法形式是在 try 关键字之后使用圆括号括起来的资源声明列表。每个资源在括号中声明并初始化。当 try 块结束时，无论是否发生异常，这些资源都将自动关闭，而不需要显式调用 <code>close()</code> 方法。以下是一个读取文件并自动关闭流的示例：</p><p><img src="/../images/si4JckeNWjgACu2Hy2zyE9v3.png" alt="image-20230813213416710.png"></p><p>FileInputStream 之所以可以自动关闭，是因为其继承了 InputStream 类，而InputStream类实现了 Closeable 接口，FileInputStream重写了 close()方法，以下是具体实现：</p><p><img src="/../images/3Jb59oFSKkxxpGfnWtjQjasr.png" alt="image-20230813213712104.png"></p><p>那如何证明使用 try-with-resources 时，close 方法真的被调用了呢？我们可以使用如下命令编译 App.java 文件，并看下生成的字节码文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-g 参数用于生成与调试相关的信息，包括调试符号和源代码行号。它允许在编译后的字节码中插入调试信息，以便在调试过程中可以精确地映射回源代码的行号和变量名</span></span><br><span class="line">javac -g App.java</span><br></pre></td></tr></table></figure><p>生成的 class 文件如下：<br><img src="/../images/evB6PifBF6JpyjircMjg6o3S.png" alt="image-20230813214358657.png"></p><p>从上面的 class 文件中我们可以清楚看到 jvm 帮我们生成了一个 catch 代码块，用来捕获外层 try 代码块可能抛出的异常，并且在 catch 代码块中显式调用了 fis 的 close() 方法进行资源关闭。这就是为什么说 <code>无论是否发生异常，这些资源都将自动关闭</code>。</p><h2 id="5-异常处理规范"><a href="#5-异常处理规范" class="headerlink" title="5. 异常处理规范"></a>5. 异常处理规范</h2><p>异常处理规范参考 《阿里巴巴代码开发规范》 中的约束。</p><p><img src="/../images/mYhf3h8HmbqPChm4u6Dnf3DT.png" alt="image-20230813215452165.png"></p><p><img src="/../images/mpcvecGWeFHyKGwkihq87fkN.png" alt="image-20230813215516364.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-Java-中的异常分类&quot;&gt;&lt;a href=&quot;#1-Java-中的异常分类&quot; class=&quot;headerlink&quot; title=&quot;1. Java 中的异常分类&quot;&gt;&lt;/a&gt;1. Java 中的异常分类&lt;/h2&gt;&lt;p&gt;Java中的异常类均以&lt;code&gt;Throwab</summary>
      
    
    
    
    
    <category term="Java" scheme="https://linvaux.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>线上问题分析案例:一个小括号引发的惨案</title>
    <link href="https://linvaux.github.io/posts/a12172a0/"/>
    <id>https://linvaux.github.io/posts/a12172a0/</id>
    <published>2023-08-17T14:58:02.000Z</published>
    <updated>2024-09-21T00:59:08.946Z</updated>
    
    <content type="html"><![CDATA[<h2 id="悲剧的开始"><a href="#悲剧的开始" class="headerlink" title="悲剧的开始"></a>悲剧的开始</h2><p>2023.8.17 早上 7:30 刚睡醒，都没来得及洗漱，手机上就收到了公司运维平台发的告警<br><img src="/../images/GHdZ2Uo8DmrkHMFUcVDDwTk6.png" alt="image.png"><br>有一台服务器 cpu 使用率超过 95%了，当时没在意，以为上面正在跑任务(这个服务器上面部署的是我们自己开发的自动化测试平台，用例执行引擎是 Jmeter，后端开发框架是 springboot)。等我收拾完准备出门上班的时候，发现手机上又双收到了 2 条告警，cpu 使用率没有下去，当时在想是不是自动化任务跑的时间比较长，再等等。。。然后就骑车出门了。</p><p>8:30 在地铁上打开手机看了下，发下又双叒收到了告警，我擦，怎么没完了，隐隐有种不好的预感。同时在 vx 群里，老板也在艾特我，问我为啥一直在告警，可是我也母鸡啊。。。<br><img src="/../images/yes1YeWxNU16rEu7oXaz8K4b.png" alt="image.png"></p><p>8:50到公司，打开 IM 工具一看，好家伙，又双叒叕多了好几条告警，上运维平台看了下服务器监控，瞬间血压就上来了。。。<br><img src="/../images/YqGnWetR9DJ18YFJhm5ssuUn.png" alt="image.png"></p><h2 id="问题出现"><a href="#问题出现" class="headerlink" title="问题出现"></a>问题出现</h2><p>我次奥啊，这台 8C16GB 服务器的 cpu 使用率从8.14 开始，蹭蹭蹭的往上涨啊，一点回落的迹象都没有。<br><img src="/../images/PtGcdnMzwSVBqHinzLZsztqP.png" alt="image.png"><br>同时看了下最近一周的监控记录，发现 cpu 使用率在 8.10就开始增长了，8.11回落了，然后过了一个周末，从 8.14 开始就跟吃了炫迈一样，根本停不下来。结合这个服务的发版记录，猜测可能是 8.10 发布的那个版本有问题，导致8.11当天出现了 cpu 使用率上涨的问题。因为8.11那天发现 8.10 发布的版本有问题，8.11 晚上又发布了一个 hotfix 版本，而且那天正好是周五，所以周末两天都没人用自动化测试，cpu 使用率就非常低。8.14周一上班了，大家开始做自动化测试了，问题就开始出现了。<br>再看下内存使用率，差点一口气没上来，16GB 的内存用了 14GB，这特喵的是内存泄露了吧，而且 cpu 使用率还高的吓人，但是当时看了下服务器上的日志，并没有几个任务再跑，说明有其他的线程可能在狂占 cpu。<br><img src="/../images/FHWF1yWjJiUisbecqk5G1T47.png" alt="image.png"></p><h2 id="初步定位"><a href="#初步定位" class="headerlink" title="初步定位"></a>初步定位</h2><p>就在我对着这个监控数据抓狂的时候，陆续又收到了其他测试同学的反馈：自动化用例执行了结果出不来，刷新页面偶尔出现了“上游服务器无响应” 等等问题。得！赶紧先上服务器捞一把数据，然后把服务器重启了先，不然等会儿就真的要宕机了。<br>登录服务器之后，首先要看下 cpu 和内存使用率是不是真的高到离谱，用 top 命令一看确实不行了(运维平台的监控偶尔抽风不准)。</p><h3 id="分析-GC-情况"><a href="#分析-GC-情况" class="headerlink" title="分析 GC 情况"></a>分析 GC 情况</h3><p>执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gcutil 339 1000 100 &gt; gc.log</span><br></pre></td></tr></table></figure><p><img src="/../images/2qM2nYvYgmAc2q7FEgQeceLW.png" alt="image.png"><br>好家伙，youngGC 了 20 多万次，fullGC 4万多次，基本每2s 进行一次 GC，这内存不爆才有鬼了。<br>再看下 JVM 配置<br><img src="/../images/kWxmPC9qhv4XrbkCoS4KHkz1.png" alt="image.png"><br>可以，很 6，jvm 直接给了 13GB，哪个天杀的教他们这么配置 heap 的！<br><img src="/../images/LjkMiMikuYMLn4mjKPqWDjhF.png" alt="image.png"></p><h3 id="分析对象直方图"><a href="#分析对象直方图" class="headerlink" title="分析对象直方图"></a>分析对象直方图</h3><p>执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -histo 339 &gt; histo.txt</span><br></pre></td></tr></table></figure><p><img src="/../images/gfubAukZM4MUAHMkJc6WwRkn.png" alt="image.png"></p><p>很秀，光 org.apache.jmeter.samplers.SampleResult 对象都有 1224w+ 了，占用了 3G 内存，熟悉 Jmeter 的同学都知道，这个对象是 Jmeter 用来存储采样器结果的(不知道的可以去百度一下)。TM 什么样的测试用例能跑出来这么多对象，而且还没释放，说明这种用例还在执行，那其实就从侧面印证了 cpu 使用率为啥居高不下。</p><p>光凭这两个数据，还是没法准确分析出问题出在哪里，所以最后只能祭出终极大招：分析内存快照</p><h3 id="分析内存快照"><a href="#分析内存快照" class="headerlink" title="分析内存快照"></a>分析内存快照</h3><p>执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=heapdump.bin 339 &gt; heapdump.bin</span><br></pre></td></tr></table></figure><p>光执行这个命令都用了 5 分钟，生成的原始文件 16GB，然后使用 zip 压缩以下再下载。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip heapdump.bin.zip heapdump.bin</span><br></pre></td></tr></table></figure><p>不要幻想用 tar 去压缩，tar 压缩效率很低，而且压缩完成的文件跟原始文件差不多大。zip压缩完成后得到的 heapdump.bin.zip 有 1.7GB，下载都用了 20min(U1S1，从生产环境的服务器下载东西是真的慢……)</p><p>这个时候是不是该分析这个文件了？错！分析个毛线啊，赶紧重启服务器啊，不然等会彻底宕机了，我们就凉凉了。因为这个服务是双实例部署，所以使用串行重启，网关那边做了负载均衡，对于用户来说基本无法感知到服务被重启了(不排除运气不好的人，请求正在被重启的服务器上执行，则就会出现 504 的问题)。</p><p>服务器重启完成后，再看下 cpu 使用率，发现终于降下来了，内存不用看，13GB 的堆内存还是挺抗打的。但是，如果现在不解决，cpu 和内存飚上去是迟早的事情，可能都等不到我们下次发版本了，估计本周末就能 gg。<br><img src="/../images/dYrkBp4eENTgHUTox5YPJ8Vi.png" alt="image.png"></p><p>服务重启完了，赶紧分析下快照文件吧，我用的工具是 <a href="https://eclipse.dev/mat/">MAT</a>，然后就发现了一个悲剧的事情，这个 bin 文件有 16GB，我电脑内存才 16GB，MAT 默认的内存是 2GB，打开这个文件转圈转了 10min 都没处理完。先把mat 内存改下吧。修改 mat 安装目录下的 &#x2F;Applications&#x2F;mat.app&#x2F;Contents&#x2F;Eclipse&#x2F;MemoryAnalyzer.ini 文件中的 -Xmx 配置为 8g<br><img src="/../images/EgwDJV3oLDVkfChd3aPNEFDr.png" alt="image.png"><br>然后重新打开这个bin 文件，这次转圈转了 5min 才好。</p><h4 id="内存泄露分析"><a href="#内存泄露分析" class="headerlink" title="内存泄露分析"></a>内存泄露分析</h4><p>先看下 mat 生成的 leak suspects 报告，看下是不是有疑似内存泄露的问题。<br><img src="/../images/XKQZRyLRmCZhy91MyGjkvLYN.png" alt="image.png"><br>emm……漏就漏了吧，不漏才见鬼了<br>从上面的报告可以看到，有个疑似内存泄漏的对象：ApiBackendListenerClient<br>这个类是我们服务自己写的类，继承了 Jmeter 的 AbstractBackendListenerClient，是一个监听器类，作用是收集 Jmeter 执行过程中的采样器结果。这个类有三个重写的方法</p><ul><li><p>setupTest: 允许开发者在测试开始之前进行一些初始化操作，例如建立与后端系统的连接、准备发送数据等，此方法只会调用一次。</p></li><li><p>handleSampleResults: 每个线程组的每个请求都会生成一个样本结果，样本结果包含了该请求的响应时间、响应码、响应数据等信息。handleSampleResults方法会接收这些样本结果，并进行处理。可以在这个方法中编写代码来将样本结果存储、发送到数据库、生成报告等。通过重写handleSampleResults方法，可以自定义后端监听器在测试期间如何处理样本结果。这个方法会频繁调用，即 Jmeter 每发送一次请求，此方法都会被调用一次。</p></li><li><p>teardownTest: 测试结束后的操作，一般用于发送数据，清理数据等等，此方法只会调用一次。</p></li></ul><p>既然都找到自己的类了，那就先看下为啥这个类会持有这么多 SampleResult 对象吧。接下来对代码进行分析。<br><img src="/../images/KiJ61zdt17c7XNbpazrLbgSY.png" alt="image.png"><br><img src="/../images/7gj5QosiSxGaHwUKwJKMwVmT.png" alt="image.png"><br>在这个类中，创建了一个 List&lt;SampleResult&gt; results 来存储测试过程中产生的采样器结果，测试完成后，会把这个 list 清空。既然现在出现了这么多对象，那就说明由以下两种情况导致：</p><ul><li>还没有测试完成，testdownTest 方法没有调用</li><li>result.clear()没执行，原因可能是上面的方法执行异常</li></ul><p>没测试完成这个原因有点扯淡，刚才看服务器日志发现都没几个任务在跑，不可能产生 1224w+ 个对象，所以有可能就是 teardownTest 里面的 handlerTeardownTest 方法异常了，导致下面没有清理对象，所以重点是先看下这个方法是不是哪里有问题。但是啊，事实证明我的推测是错误的…</p><p>在对这个handlerTeardownTest方法翻来覆去看了一个多小时，都没发现哪里有问题，该做异常处理的地方都做了，讲道理，应该会执行result.clear()，难道是 jmeter 抽风了，这个 teardownTest 根本就没有被调用？那如果没有被调用，就说明测试没结束，这样就说的通了：还有测试任务在进行，虽然服务器上日志显示没啥任务再跑，但是保不齐 Jmeter 的执行线程还在跑其他任务，而且这个任务是没有被我们服务正常处理掉的，因为我们为了保证用例(对应一个 hashTree，即 jmx 脚本)不能占用太长的时间，所以做了限制，当一条用例执行超过 5min 时，会强行结束，并把用例执行结果标记为超时。</p><p>事已至此，那就只能分析这个 SampleResult 对象为什么会创建这么多，而不进行释放，检查<br>此对象引用关系<br><img src="/../images/UBmhMgZikXbatti8vu6HFpzE.png" alt="image.png"><br><img src="/../images/yqf2QmzCkam7gDXNjwYAbLtw.png" alt="image.png"></p><p>可以看到此时正在执行一个 jdbc 采样器，对采样器 label 进行 unicode 转中文可以看到内容是：</p><p>【SIT】xxxxxxxxx@~@While循环@~@校验调动数据 xxxxx-第113069次循环</p><p>(上面的 xxx 就是用例相关内容，此处做了脱敏)其中，第113069次循环 表示次用例可能是放在了一个 while 控制器中，但是 while 控制器是有固定的退出逻辑，如果到达指定时间没有满足条件，则会自动退出循环，一般来说不可能出现 11w+次的循环。在这里解释下为啥我说是进行了 113069 次循环，这是因为我们在对 Jmeter 做二次开发的时候，在生成报告时需要展示循环控制器下面采样结果，为了区分是哪个循环控制的，所以使用特殊分隔符 @~@ 来标记，后面的 113069 就是循环次数，大家也可以在 Jmeter 中添加一个 查看结果树 组件来看下效果。<br>同时结合一个线上缺陷</p><p><img src="/../images/vBPz7R17kHNaYaAF8kpFYW7p.png" alt="image.png"></p><p>我猜测，这个 bug 根本就没修复好，或者修复了非空判断的问题，但是改出来了另一个 bug。<br>事已至此，无需多言，让改 bug 的人再去检查代码，最后发现确实是在生成 while 循环控制器的条件时，代码错误，导致这个 while 控制器无法退出。虽然有用例执行超时 5min 的限制，那也只是终止了调用 StandardJMeterEngine.run 方法的线程，Jmeter 在实际执行时还会创建子线程来执行采样器，这就导致了虽然用户看到了用例超时，但是这个循环控制器根本就停不下来，然后不停的调用 handleSampleResults方法，往 results里面塞数据，导致这个 list 膨胀的非常大。再加上加了 while 控制器的用例很多，大家都跑用例，导致这种线程停不下来，把服务器累个半死，内存也没法释放。</p><p>最终，这个问题被修复了，修复方法很简单，在生成 while 控制器循环条件的时候加一个小括号就行，上次修复 bug 的时候漏了这个小括号，导致 while-true 了。欸，心累啊。。。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次事故根本原因就是开发在编写代码时没有对自己写代码做充分自测，并且没有评估到这种改动会造成什么样的影响，在我工作这么多年以来，这基本是一个无解的问题，只能说：各安天命吧！</p><h2 id="写在最后的话"><a href="#写在最后的话" class="headerlink" title="写在最后的话"></a>写在最后的话</h2><p>其实整篇文章看完，有些同学可能会嗤之以鼻，说：直接装一个 arthas，看下 dashboard 里面 RUNNERABLE 状态的线程，不就很快找到原因了么，哪有这么麻烦。但是现实情况是：</p><ul><li>生产环境外网隔离，无法安装这类软件。</li><li>arths 在注入 jvm 时，可能会导致 jvm 中的线程出现挂起的情况，导致用户操作失败。</li><li>当时服务器已经非常卡了，我在执行 jstack 命令时都出现了几次失败的情况，更别说这种重量级软件运行了。</li></ul><p>所以啊，还是得学会用 JDK 自带的工具来分析问题，并且写代码的时候长点心吧！</p><p>本文省略了其他分析过程，因为那部分分析内容涉及到敏感代码和数据。</p><p>终。。。<br><img src="/../images/k35CGs3dcA5gZEZhV6vjpMPh.jpg" alt="e5520fe47669b807901294f46254ba08.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;悲剧的开始&quot;&gt;&lt;a href=&quot;#悲剧的开始&quot; class=&quot;headerlink&quot; title=&quot;悲剧的开始&quot;&gt;&lt;/a&gt;悲剧的开始&lt;/h2&gt;&lt;p&gt;2023.8.17 早上 7:30 刚睡醒，都没来得及洗漱，手机上就收到了公司运维平台发的告警&lt;br&gt;&lt;img sr</summary>
      
    
    
    
    
    <category term="Java" scheme="https://linvaux.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java中的序列化和反序列化</title>
    <link href="https://linvaux.github.io/posts/131d41e/"/>
    <id>https://linvaux.github.io/posts/131d41e/</id>
    <published>2023-07-26T14:14:54.000Z</published>
    <updated>2024-09-21T00:59:08.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-技术背景"><a href="#1-技术背景" class="headerlink" title="1. 技术背景"></a>1. 技术背景</h2><p>​互联网的迅猛发展受益于网络通信技术的成熟和稳定。网络通信协议是机器双方共同约定的协议。在应用层看到的是结构体、对象，但是在网络协议里，机器之间传输的都是二进制流。网络编程中，需要定义应用层协议。最原始的应用层协议是字节数组，在 Java 语言里以 byte［］体现，在C语言里以 char［］体现。不管是 Java 语言还是 C 语言，开发人员都需要知道字节数组里每个字节的含义才能保证数据写入和读取的正确性。这对开发人员来说，是非常严苛且低效的。<br>如何将程序中的结构体、对象等结构化内存对象转换为扁平的二进制流？如何将二进制流还原为结构化内存对象？为了解决这些问题，序列化&#x2F;反序列化技术应运而生。</p><p><img src="/../images/1gTCneXGk1gBEGnis6FRtz5M.jpg" alt="image.jpg"></p><p>核心意义：对象状态的保存(序列化)和重建(反序列化)</p><h2 id="2-序列化协议的特性"><a href="#2-序列化协议的特性" class="headerlink" title="2. 序列化协议的特性"></a>2. 序列化协议的特性</h2><ol><li><p>通用性</p><ul><li>技术层面，序列化协议是否支持跨平台、跨语言。如果不支持，在技术层面上的通用性就大大降低了。</li><li>流行程度，社区是否成熟，是否能及时跟进Issue并解决Bug。</li></ul></li><li><p>鲁棒性</p><ul><li>成熟度不够，一个协议从制定到实施，到最后成熟往往是一个漫长的阶段。协议的强健性依赖于大量而全面的测试，对于致力于提供高质量服务的系统，采用处于测试阶段的序列化协议会带来很高的风险。</li><li>语言&#x2F;平台的不公平性。为了支持跨语言、跨平台的功能，序列化协议的制定者需要做大量的工作；但是，当所支持的语言或者平台之间存在难以调和的特性的时候，协议制定者需要做一个艰难的决定–支持更多人使用的语言&#x2F;平台，亦或支持更多的语言&#x2F;平台而放弃某个特性。当协议的制定者决定为某种语言或平台提供更多支持的时候，对于使用者而言，协议的强健性就被牺牲了。</li></ul></li><li><p>可扩展性&#x2F;兼容性</p><ul><li>扩展性表现为随着业务需求变化需要增减字段。字段变化的过程中，不会对现有系统的数据存储、数据访问造成影响，具有向后兼容性。扩展性也是序列化&#x2F;反序列化技术的核心指标之一。</li></ul></li><li><p>性能</p><ul><li>时间开销，复杂的序列化协议会导致较长的解析时间，这可能会使得序列化和反序列化阶段成为整个系统的瓶颈。</li><li>空间开销，如果序列化过程引入的额外开销过高，可能会导致过大的网络，磁盘等各方面的压力。对于海量分布式存储系统，数据量往往以TB为单位，巨大的的额外空间开销意味着高昂的成本。</li></ul></li><li><p>易用性</p><ul><li>易用性决定了开发者是不是需要花很多时间去学习，门槛是不是很高，接口是不是容易理解和使用。</li></ul></li><li><p>安全性</p><ul><li>安全性也是序列化工具选型的重要参考意见，比如广泛使用的fastjson，很多版本都存在RCE漏洞。</li></ul></li></ol><h2 id="3-序列化引擎"><a href="#3-序列化引擎" class="headerlink" title="3. 序列化引擎"></a>3. 序列化引擎</h2><p>​一般来说，序列化&#x2F;反序列化分为IDL（Interface Description Language，接口描述语言）和非IDL两类。非IDL技术方案包含 JSON、XML等，提供构造和解析的工具包即可使用，不需要做代码生成的工作。IDL技术方案包含 Thrift、Protocol Buffer、Avro 等，有比较完整的规约和框架实现。</p><p><img src="/../images/hELYzbRMotrUMeYVsRa5vr9i.jpg" alt="image.jpg"></p><p>IDL 描述文件：比如，Thrift 是以 thrift 为后缀的文件，Protocol Buffer是以 proto 为后缀的文件。<br>IDL 文件编译器：根据 IDL 文件生成具有序列化&#x2F;反序列化功能的代码文件。例如，Thrift 通过 thrift 命令行指定编程语言类型来生成代码文件，Protocol Buffer 根据 protoc 命令行生成代码文件。<br>Stub&#x2F;Skeleton 代码：在客户（Client）端，一般称为 Stub 代码。在服务器（Server）端，一般称为 Skeleton 代码。</p><h2 id="4-Java序列化方式"><a href="#4-Java序列化方式" class="headerlink" title="4. Java序列化方式"></a>4. Java序列化方式</h2><h3 id="4-1-实现Serializable接口"><a href="#4-1-实现Serializable接口" class="headerlink" title="4.1 实现Serializable接口"></a>4.1 实现Serializable接口</h3><h4 id="4-1-1-默认的序列化-反序列化"><a href="#4-1-1-默认的序列化-反序列化" class="headerlink" title="4.1.1 默认的序列化&#x2F;反序列化"></a>4.1.1 默认的序列化&#x2F;反序列化</h4><p>实现 <code>Serializable</code> 接口是最常用的序列化方式，以下是简单示例</p><ul><li>准备一个待序列化的对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wick.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行序列化操作 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wick;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wick.pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;wick&quot;</span>, <span class="number">18</span>, <span class="string">&quot;beijing&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(Files.newOutputStream(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;user.out&quot;</span>).toPath())))&#123;</span><br><span class="line">            os.writeObject(user);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p> 在上面的例子中，我们使用 <code>ObjectOutputStream.writeObject(Object obj )</code> 方法来完成对象的序列化，并保存到本地文件中，我们可以使用二进制文件编辑器打开看下文件内容</p><p><img src="/../images/Y1ECwL99NPQ9CM8ivPzgBVHo.jpg" alt="iShot_2023-05-03_11.08.28.jpg"></p><p>同样的，我们也可以使用 <code>ObjectInputStream.readObject() </code> 方法来将一个对象反序列化出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(Files.newInputStream(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;user.out&quot;</span>).toPath()));</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) ins.readObject();</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// out: User(name=wick, age=18, address=beijing)</span></span><br></pre></td></tr></table></figure><p>除了使用默认的序列化机制外，对于一些特殊的类， 我们需要定制序列化和反序列化方法的时候，可以通过重写以下方法实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObjectNoData</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException;</span><br></pre></td></tr></table></figure><p>上面的三个方法，并不是 <code>Serializable</code> 接口中的方法，而是特殊名称的方法，只要实现了 <code>Serializable</code> 接口，就可以通过重写这几个方法来实现定制的序列化和反序列化需求，jdk 中的很多类都有此操作，有兴趣的可以自行查看各自的实现，此处不做展开。</p><p><img src="/../images/2VNC72QBgSZyBYvENcVCm2bq.jpg" alt="iShot_2023-05-03_11.30.00.jpg"></p><h4 id="4-1-2-自定义序列化-反序列化"><a href="#4-1-2-自定义序列化-反序列化" class="headerlink" title="4.1.2 自定义序列化&#x2F;反序列化"></a>4.1.2 自定义序列化&#x2F;反序列化</h4><ul><li>对于上面的 User 类，我们可以通过重写 <code>writeObject(java.io.ObjectOutputStream out)</code> 方法来实现自定义的序列化，代码如下所示</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wick.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line">        <span class="comment">// 追加 toString() 的内容</span></span><br><span class="line">        s.writeBytes(<span class="string">&quot;name: &quot;</span> + name + <span class="string">&quot;, age: &quot;</span> + age + <span class="string">&quot;, address: &quot;</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>序列化对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSerializer</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;wick&quot;</span>, <span class="number">18</span>, <span class="string">&quot;beijing&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(Files.newOutputStream(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;user1.out&quot;</span>).toPath())))&#123;</span><br><span class="line">        os.writeObject(user);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用工具查看生成的二进制文件内容，可以明显看到后面追加了刚才 <code>toString()</code> 方法的内容，这样就实现了对象的自定义序列化。</p><p><img src="/../images/PyvHnp3XR3K5NXyT1MK4cr6D.png" alt="image-20230503115610143.png"></p></li><li><p>同样的，我们也可以通过重写 <code>readObject(java.io.ObjectInputStream s) </code> 方法来实现自定义的反序列化操作</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span> <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">   s.defaultReadObject();</span><br><span class="line">   <span class="comment">// 读取 toString() 的内容</span></span><br><span class="line">   <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">   <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.read(bytes);</span><br><span class="line">   String[] split = <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len).split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">  <span class="comment">// 此处，将 name 和 address 属性交换读取，不然看不出来区别</span></span><br><span class="line">   <span class="built_in">this</span>.address = split[<span class="number">0</span>].split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>].trim();</span><br><span class="line">   <span class="built_in">this</span>.age = Integer.parseInt(split[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>].trim());</span><br><span class="line">   <span class="built_in">this</span>.name = split[<span class="number">2</span>].split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>].trim();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>反序列化对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(Files.newInputStream(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;user1.out&quot;</span>).toPath()));</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) ins.readObject();</span><br><span class="line">    System.out.println(user.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// out: User(name=beijing, age=18, address=wick)</span></span><br></pre></td></tr></table></figure><h3 id="4-2-实现Externalizable接口"><a href="#4-2-实现Externalizable接口" class="headerlink" title="4.2 实现Externalizable接口"></a>4.2 实现Externalizable接口</h3><p>除了实现 <code>Serializable</code> 接口完成序列化&#x2F;反序列化外，还可以通过实现 <code>Externalizable</code> 接口达到序列化&#x2F;反序列化的目的， 但是如果实现了 <code>Externalizable</code> 接口， 那就必须实现 <code>writeExternal(ObjectOutput out) </code> 和 <code>readExternal(ObjectInput in)</code> 方法。</p><ul><li>以下我们还是以简单的 Person 类来举例。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wick.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Externalizable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInput;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutput;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wick</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2023/5/3 12:09</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span> <span class="comment">// 必须要有无参构造，如果没有重写构造方法，则默认会有无参构造</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Externalizable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        out.writeObject(name);</span><br><span class="line">        out.writeInt(age);</span><br><span class="line">        out.writeObject(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        name = (String) in.readObject();</span><br><span class="line">        age = in.readInt();</span><br><span class="line">        address = (String) in.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>序列化对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;wick&quot;</span>, <span class="number">18</span>, <span class="string">&quot;nanjing&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(Files.newOutputStream(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;person.out&quot;</span>).toPath())))&#123;</span><br><span class="line">        os.writeObject(person);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用工具查看序列化后的内容</li></ul><p> <img src="/../images/ZJ9fqjsXpnfXGsH7i5P1iYw5.png" alt="image-20230503122846877.png"></p><ul><li>反序列化对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(Files.newInputStream(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;person.out&quot;</span>).toPath()));</span><br><span class="line">    <span class="type">Person</span> <span class="variable">user</span> <span class="operator">=</span> (Person) ins.readObject();</span><br><span class="line">    System.out.println(user.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// out: Person(name=wick, age=18, address=nanjing)</span></span><br></pre></td></tr></table></figure><h3 id="4-3-两种序列化方式的比较"><a href="#4-3-两种序列化方式的比较" class="headerlink" title="4.3 两种序列化方式的比较"></a>4.3 两种序列化方式的比较</h3><ul><li><p>实现方式</p><ul><li><p>Serializable 接口：是 Java 语言提供的标记接口，即不需要实现任何方法，只需要在类名加上 <code>implements Serializable</code> 即可。当一个对象被序列化时，Java 的序列化机制会把对象的状态保存到一个字节序列中。而当一个对象被反序列化时，Java 的序列化机制会根据保存的字节序列来创建并初始化一个对象。</p></li><li><p>Externalizable 接口：需要实现 <code>readExternal</code> 和 <code>writeExternal</code> 两个方法，用来表示如何序列化和反序列化一个对象。可以通过这两个方法来控制对象状态的写入和读取。 <code>readExternal</code> 和 <code>writeExternal</code> 方法不是由 Java 序列化机制调用的，而是需要手动调用，因此可以进行一些额外的初始化或特殊操作。</p></li></ul></li><li><p>序列化效率</p><ul><li><p>Serializable 接口：在序列化和反序列化一个对象时，序列化机制会自动地对该对象的所有非静态成员进行序列化和反序列化操作。因为使用的是自动序列化机制，这可能会创建一些不必要的对象和字节数组，从而降低序列化的效率，尤其当某个类的父类也实现了可序列化接口时，更耗费资源。</p></li><li><p>Externalizable 接口：由于对对象的序列化和反序列化过程都是手动控制的，<code>Externalizable</code> 实现的序列化效率比 <code>Serializable</code> 高，特别是在序列化大型对象图时。但是，需要手动调用接口的方法，可能需要更多的代码开销和维护成本。</p></li></ul></li></ul><p>综上所述，<code>Serializable</code> 接口更加简单且容易实现，但是效率相比于 <code>Externalizable</code> 接口会下降；而 <code>Externalizable</code> 接口需要手动编写序列化和反序列化的方法，但是它提供了更好的控制序列化的过程并且具有更高的序列化效率。</p><h2 id="5-Java序列化核心类-接口"><a href="#5-Java序列化核心类-接口" class="headerlink" title="5 Java序列化核心类&#x2F;接口"></a>5 Java序列化核心类&#x2F;接口</h2><h3 id="5-1-Serializable"><a href="#5-1-Serializable" class="headerlink" title="5.1 Serializable"></a>5.1 Serializable</h3><p>Serializable 接口源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Serializable</code> 是一个空接口，表明了实现自该接口的子类具有序列化行为特征，所有要支持序列化的类都应该实现这个接口。在后面介绍 <code>ObjectOutputStream</code> 的<code>writeObject</code> 方法时，会解释为什么必须这么做。</p><h3 id="5-2-Externalizable"><a href="#5-2-Externalizable" class="headerlink" title="5.2 Externalizable"></a>5.2 Externalizable</h3><p><code>Externalizable</code> 接口源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Externalizable</span> <span class="keyword">extends</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此接口有两个必须要重写的方法，在上面我们已经介绍过，<code>writeExternal</code> 的参数是 <code>ObjectOutput</code>，表示输出对象的抽象，它继承自 <code>DataOutput</code>，能支持基本类型、String、数组、对象的输出。实际应用中，会使用它的实现类 <code>ObjectOutputStream</code>。 <code>readExternal</code> 的参数是 <code>ObjectInput</code>，表示输入对象的抽象，它继承自 <code>DataInput</code>，能支持基本类型、String、数组、对象的输入。实际应用中，会使用它的实现类 <code>ObjectInputStream</code>。自定义的类必须包含无参构造函数。</p><h3 id="5-3-ObjectOutputStream"><a href="#5-3-ObjectOutputStream" class="headerlink" title="5.3 ObjectOutputStream"></a>5.3 ObjectOutputStream</h3><p><code>java.io.ObjectOutputStream</code> 是实现序列化的关键类，它可以将一个对象转换成二进制流，然后通过 <code>ObjectInputStream</code> 将二进制流还原成对象。为了能更好地理解 <code>ObjectOutputStream</code>，先简要说明其内部的几个关键类：</p><h4 id="5-3-1-BlockDataOutputStream"><a href="#5-3-1-BlockDataOutputStream" class="headerlink" title="5.3.1 BlockDataOutputStream"></a>5.3.1 BlockDataOutputStream</h4><p><code>BlockDataOutputStream</code> 是Java标准库中的一个类，它是<code>DataOutputStream</code> 的子类，用于提供对数据进行块写入的功能。<code>BlockDataOutputStream </code>类主要用于为<code>ObjectOutputStream</code> 类提供支持。在对象序列化过程中，<code>ObjectOutputStream </code>会使用 <code>BlockDataOutputStream</code> 来处理原始数据的写入。</p><p>以下是<code>BlockDataOutputStream</code>的一些主要特点和功能：</p><ol><li><p>块数据写入：<code>BlockDataOutputStream</code>允许以块的形式，将原始数据按照一组字节进行写入。块数据包含了一些元信息，如块长度、类型等，以便在反序列化时进行正确的解析。</p></li><li><p>压缩：<code>BlockDataOutputStream </code>可以对数据进行压缩，以减小序列化数据的大小，提高传输效率。</p></li><li><p>写入类型：除了基本的数据类型，<code>BlockDataOutputStream</code> 还支持写入字符串、数组、特定类型对象等。</p><p><img src="/../images/qpTtpLL9DYbfFPFkSN5onUmd.jpg" alt="WeChat1fff69b0fbc7927f0b6236408eb494ae.jpg"></p></li><li><p>缓冲区管理：<code>BlockDataOutputStream</code>使用内部缓冲区（Buffer）来提高写操作的性能。缓冲区会在需要时被填满并进行刷出。</p></li></ol><p>简单来说，<code>BlockDataOutputStream</code>是用于支持对象序列化过程中的底层数据写入。它提供了块数据写入的功能，可以进行压缩以减小数据大小，同时也实现了缓冲区管理，以提高写入操作的性能。作为 <code>ObjectOutputStream</code> 内置的具有缓冲作用的输出功能类，包含阻塞和非阻塞两种工作模式。两种模式的工作流程相同，都是先把待写的数据写到缓冲区，直到缓冲区满后再执行真正的写入操作，只是在阻塞模式下，每次将缓冲区数据写入之前会写入一个阻塞标记头部（Block Data Header）。 </p><h4 id="5-3-2-HandleTable"><a href="#5-3-2-HandleTable" class="headerlink" title="5.3.2 HandleTable"></a>5.3.2 HandleTable</h4><p>管理对象引用的处理，在 Java 的序列化机制中，如果一个对象被多次引用，那么在序列化过程中会将对象序列化为多个拷贝，这样会导致序列化结果变得冗长。为了解决这个问题，Java 序列化机制使用了对象引用句柄。<code>HandleTable</code> 类的作用是维护了一张对象引用句柄表，用来管理对象的序列化和反序列化过程中的引用处理。它通过使用句柄来代替重复的对象，从而实现对象的共享和压缩。具体来说，<code>HandleTable</code> 类中的 <code>handles</code> 数组存储了对象的引用句柄，索引值作为句柄值。当序列化一个对象时，<code>ObjectOutputStream </code>会将对象写入输出流，并将其句柄（索引值）写入句柄表中。当序列化过程中遇到同一个对象的引用时，它会使用相同的句柄值来表示该对象，这样就实现了对象的共享。在反序列化过程中，<code>ObjectInputStream</code>会根据句柄值从句柄表中获取对应的对象引用。通过使用句柄表，<code>HandleTable</code> 类可以有效地减少序列化结果的大小，并提高序列化和反序列化的效率。它是Java序列化机制中的一个关键组件，帮助实现了序列化对象的共享和压缩。我们可以通过下面一张图来理解这个过程。</p><p><img src="/../images/eoWEk2V81BTRTxPzzit3BcEw.jpg" alt="HandleTable.jpg"></p><p>在上面这张简单的表示组合关系的类图中，我们可以看到 A 类是由 B 和 C 两个类来组合得到的，而 B，C 类内部都有 T 类，如果没有 <code>HandleTable</code>，那 A类的序列化过程就会变成：</p><ul><li>构造对象 B 和 C</li><li>在 B 中构造对象 T，在 C 中构造对象 T</li></ul><p>从上面这个过程我们发现，T 这个对象会分别在 B 和 C 中被构造一次，如果是更为复杂的对象，那么对于 T 来说，可能会出现非常多的拷贝对象，但是当引入 <code>HandleTable</code> 之后，事情就变得简单了，比先构造对象 B，然后发现用到了 T，则构造一次，并使用一个 <code>Object[]</code> 来缓存这个 T 对象，当构造 C 的时候发现它也用到了对象 T，则直接会从 <code>Object[]</code> 中取到这个对象的引用，避免了二次创建对象，下面是<code>HandleTable</code>类的简化示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HandlesTable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] handles; <span class="comment">// 引用句柄表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setObject</span><span class="params">(<span class="type">int</span> handle, Object obj)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置句柄对应的对象引用</span></span><br><span class="line">        handles[handle] = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">(<span class="type">int</span> handle)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取句柄对应的对象引用</span></span><br><span class="line">        <span class="keyword">return</span> handles[handle];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用数组作为存储结构，<code>HandleTable</code> 能够快速通过句柄值来获取对应的对象引用。通过索引操作，可以直接访问数组的元素，无需进行遍历或搜索操作，因此具有较快的存取速度。当需要序列化和反序列化对象时，<code>HandleTable</code> 会根据需要动态扩展数组的大小，以适应不同数量的对象引用。</p><h4 id="5-3-3-ReplaceTable"><a href="#5-3-3-ReplaceTable" class="headerlink" title="5.3.3 ReplaceTable"></a>5.3.3 ReplaceTable</h4><p><code>ReplaceTable</code>类的主要作用是在序列化过程中，当遇到可以被替换的对象时，将对象替换为其他对象。这样可以更好地控制序列化的结果，实现自定义的序列化逻辑。具体来说，<code>ReplaceTable</code>类维护了一个替换表（Replacement table），它是一个<code>Map</code>数据结构，用于存储对象的替代对应关系。在序列化过程中，当要序列化一个对象时，<code>ObjectOutputStream</code>会检查该对象是否实现了<code>writeReplace()</code>方法。若实现了此方法，<code>ObjectOutputStream</code>会调用该方法获取替代对象，并将替代对象进行序列化。如果替代对象不为<code>null</code>，则将替代对象添加到替换表中。在后续的序列化过程中，如果遇到与替换表中的对象相等的对象时，<code>ObjectOutputStream</code>会将该对象替换为替代对象进行序列化。这样可以在序列化过程中实现对象替换，更好地控制序列化结果。通过使用<code>ReplaceTable</code>类，可以在序列化过程中灵活地替换对象，实现自定义的序列化行为，例如实现对象的版本控制、对象的压缩、对象的安全性检查等。</p><h4 id="5-3-4-ObjectStreamClass"><a href="#5-3-4-ObjectStreamClass" class="headerlink" title="5.3.4 ObjectStreamClass"></a>5.3.4 ObjectStreamClass</h4><p><code>ObjectStreamClass</code> 的主要作用是提供关于类的序列化和反序列化的元数据信息。它存储了与类相关的信息，并在序列化和反序列化时使用这些信息来进行匹配和操作。通过 <code>ObjectStreamClass</code> ，我们可以了解类的版本号、类的字段信息以及类的序列化支持情况等。这使得在进行序列化和反序列化过程时，能够正确地处理对象的属性和版本兼容性。以下是其核心字段及作用：</p><table><thead><tr><th align="left">字段</th><th align="left">字段意义</th></tr></thead><tbody><tr><td align="left">Class&lt;?&gt; cl</td><td align="left">序列化类的 Class 类型</td></tr><tr><td align="left">String name</td><td align="left">序列化类的完整类名</td></tr><tr><td align="left">volatile Long suid</td><td align="left">序列化 ID，使用 volatile 关键字还可以禁止编译器进行某些优化，例如重排序。这是因为在对象序列化和反序列化的过程中，与版本号相关的操作必须按照特定的顺序进行，否则可能导致不正确的结果。</td></tr><tr><td align="left">boolean isProxy</td><td align="left">是否是代理类</td></tr><tr><td align="left">boolean isEnum</td><td align="left">是否是枚举类</td></tr><tr><td align="left">boolean serializable</td><td align="left">是否实现了 Serializable 接口</td></tr><tr><td align="left">boolean externalizable</td><td align="left">是否实现了 Externalizable 接口</td></tr><tr><td align="left">boolean hasWriteObjectData</td><td align="left">是否使用自定义的 writeObject 方法写数据</td></tr><tr><td align="left">boolean hasBlockExternalData</td><td align="left">类是否包含阻塞式外部数据，阻塞式外部数据指的是在进行对象的序列化时，如果存在某些在序列化过程中需要阻塞的外部数据（比如通过网络传输），那么阻塞式外部数据就会设置为<code>true</code>。 当<code>hasBlockExternalData</code>字段为<code>true</code>时，序列化和反序列化过程中的某些步骤可能会被阻塞，直到外部数据就绪或可用。这样可以确保在序列化和反序列化过程中正确地处理外部依赖。通过这个字段，<code>ObjectStreamClass</code>类在序列化和反序列化时可以根据需要采取相应的行动，以确保阻塞式外部数据正常处理。</td></tr><tr><td align="left">ClassNotFoundException resolveEx</td><td align="left">尝试解析类时发生的异常</td></tr><tr><td align="left">ExceptionInfo deserializeEx</td><td align="left">非枚举类反序列化异常，ExceptionInfo 也是 ObjectStreamClass 的一个内部类，表示操作类时产生的异常</td></tr><tr><td align="left">ExceptionInfo serializeEx</td><td align="left">非枚举类序列化异常</td></tr><tr><td align="left">ExceptionInfo defaultSerializeEx</td><td align="left">尝试默认序列化时引发的异常</td></tr><tr><td align="left">ObjectStreamField[] fields</td><td align="left">可序列化字段</td></tr><tr><td align="left">int primDataSize</td><td align="left">基本类型的成员字段个数，不包含被 static 和 transient 修饰的字段</td></tr><tr><td align="left">int numObjFields</td><td align="left">非基本类型的成员字段个数</td></tr><tr><td align="left">FieldReflector fieldRefl</td><td align="left">缓存与类相关联的字段反射信息。它提供了一个快速访问字段的能力，避免了每次进行字段反射访问时的性能开销</td></tr><tr><td align="left">volatile ClassDataSlot[] dataLayout</td><td align="left">类的层次结构：当前类，父类，及其所有子类的类描述</td></tr><tr><td align="left">Constructor&lt;?&gt; cons</td><td align="left">适合序列化的构造函数，如果没有，则为 null</td></tr><tr><td align="left">ProtectionDomain[] domains</td><td align="left">与类相关联的保护域（<code>ProtectionDomain</code>）的数组。这些保护域定义了在序列化和反序列化过程中对类的访问权限。<code>ProtectionDomain</code>是Java安全性机制中的一个概念，它代表了一组相关代码的安全域。每个<code>ProtectionDomain</code>都由一个代码源（code source）和一组权限（permissions）组成。当一个对象被序列化时，其类信息会被存储在序列化数据中。在反序列化过程中，为了确保安全性，Java虚拟机（JVM）必须验证反序列化的类是否具有足够的权限进行访问。这个验证过程使用了类的保护域信息。通过<code>domains</code>属性，<code>ObjectStreamClass</code>可以存储和获取与类相关联的保护域信息。这些保护域将在反序列化过程中被用于验证类的访问权限。</td></tr><tr><td align="left">Method writeObjectMethod</td><td align="left">序列化方法，通过反射获取</td></tr><tr><td align="left">Method readObjectMethod</td><td align="left">反序列化方法，通过反射获取</td></tr><tr><td align="left">Method writeReplaceMethod</td><td align="left">当一个对象被序列化时，如果该对象类中定义了<code>writeReplace()</code>方法，那么在序列化过程中将调用这个方法来确定要序列化的对象。<code>writeReplace()</code>方法负责返回实际要序列化的对象。这样可以灵活地控制对象的序列化过程。</td></tr><tr><td align="left">Method readObjectNoDataMethod</td><td align="left">如果该对象类中定义了<code>readObjectNoData()</code>方法，那么在反序列化过程中将调用这个方法进行对象的初始化。<code>readObjectNoData()</code>方法用于在反序列化之后对反序列化得到的对象进行进一步处理，以确保对象的完整性和一致性</td></tr><tr><td align="left">Method readResolveMethod</td><td align="left">当一个对象被反序列化时，如果该对象类中定义了<code>readResolve()</code>方法，那么在反序列化过程中将调用这个方法来确定实际要返回的对象。<code>readResolve()</code>方法负责返回一个替代的对象，以确保在反序列化后得到的对象与原始对象保持一致。</td></tr><tr><td align="left">ObjectStreamClass localDesc</td><td align="left">当前类描述</td></tr><tr><td align="left">ObjectStreamClass superDesc</td><td align="left">父类描述</td></tr><tr><td align="left">boolean initialized</td><td align="left">对象是否已经初始化完成</td></tr></tbody></table><h3 id="5-4-ObjectInputStream"><a href="#5-4-ObjectInputStream" class="headerlink" title="5.4 ObjectInputStream"></a>5.4 ObjectInputStream</h3><p><code>java.io.ObjectInputStream</code> 是实现Java反序列化的关键类，和 <code>ObjectOutputStream</code> 是对应的，内部包含了 <code>BlockDataInputStream</code>、<code>HandleTable</code>、<code>ReplaceTable</code>、<code>ObjectStreamClass</code> 等，这里不展开描述。</p><h2 id="6-Java-序列化原理"><a href="#6-Java-序列化原理" class="headerlink" title="6. Java 序列化原理"></a>6. Java 序列化原理</h2><p>以上，我们了解到了 java 实现序列化的方式，以及序列化过程中会用到的核心类&#x2F;接口，接下来我们需要知道Java序列化的流程、原理，以及各种类型数据进行Java序列化后的格式和占用空间大小等细节，这也是序列化技术的核心所在。不同序列化方案的技术细节不尽相同，对各种数据类型处理后的格式和大小也不尽相同。</p><h3 id="6-1-基本类型数据序列化流程"><a href="#6-1-基本类型数据序列化流程" class="headerlink" title="6.1 基本类型数据序列化流程"></a>6.1 基本类型数据序列化流程</h3><p>在学习基本类型的序列化流程之前，我们先回顾两个知识点</p><ol><li>Java 中基本数据类型有几种，及其长度</li></ol><table><thead><tr><th>数据类型</th><th>字节长度</th></tr></thead><tbody><tr><td>int</td><td>4字节（-2,147,483,648 到 2,147,483,647）</td></tr><tr><td>long</td><td>8字节（-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807）</td></tr><tr><td>double</td><td>8字节（IEEE 754双精度浮点数）</td></tr><tr><td>char</td><td>2字节（无符号Unicode字符，以UTF-16编码表示，可存储一个unicode字符）</td></tr><tr><td>byte</td><td>1字节（-128 到 127）</td></tr><tr><td>boolean</td><td>1 位，只能是 true 或者 false</td></tr><tr><td>short</td><td>2字节（-32,768 到 32,767）</td></tr><tr><td>float</td><td>4字节（IEEE 754单精度浮点数）</td></tr></tbody></table><ol start="2"><li>字节的高低位</li></ol><p>在计算机中，一个字节由8个位（bit）组成。在一个字节中的每个位都有特定的位置。位可以被编号，从最右边的位（称为最低有效位）开始，往左依次递增编号，最左边的位称为最高有效位，也称为高位。其实这个很好理解，在电视上我们也见过支票，支票的金额就是从左往右写的</p><p><img src="/../images/D4zoDNdPDaHmkVdGgKk2J9Uh.jpg" alt="iShot_2023-07-30_09.06.14.jpg"></p><p>比如上面这张图，在右边的金额栏，从左往右依次是高单位到低单位，所以最左边的就是高位，最右边的就是低位。</p><p>字节的高位和低位术语通常用于表示多字节数据类型（如整数）的个别字节在内存中的存储顺序。在多字节的数据类型中，数据在内存中以连续的字节序列存储，而字节序列的顺序可以是”大端”或”小端”。</p><ul><li>大端字节序：最高有效位存储在起始地址，最低有效位存储在最后地址。</li><li>小端字节序：最低有效位存储在起始地址，最高有效位存储在最后地址。</li></ul><p>举个例子，假设一个整数值0x12345678在内存中按照大端字节序存储。将这个整数值转换为字节序列时，高位字节0x12存储在起始地址，低位字节0x78存储在最后地址。</p><p>地址:  0             1          2          3       </p><p>​     |  0x12 | 0x34 | 0x56 | 0x78 |</p><p>相反，如果按照小端字节序存储，高位字节0x78存储在起始地址，低位字节0x12存储在最后地址。</p><p>地址:  0             1           2         3       </p><p>​     |  0x78 | 0x56 | 0x34 | 0x12 |</p><p>在Java中，默认使用的是采用大端字节序（Big Endian）的内存存储模式。这意味着在多字节数据类型（如int、long、float、double等）存储在内存中时，最高有效字节存储在起始地址，按顺序向后存储。</p><p>回顾完上面两个问题，我们继续看 Java 是如何序列化基本类型数据的，Java序列化对基本类型数据的处理，严格按照其内存占用大小来进行。比如int类型占用4字节，Java 序列化按照高位到低位依次放到字节数组，再写入到序列化输出对象，真正的写入是通过调用 <code>BlockDataOutputStream</code> 的 <code>writeInt</code> 方法实现的。<code>BlockDataOutputStream</code> 内部维护了一个1024字节大小的缓冲区，如果缓冲区还可以容纳待写入的 int 类型数据，则把当前数据放入缓冲区；如果缓冲区不能容纳待写入的int类型数据，则调用 <code>DataOutputStream</code> 的 <code>writeInt</code> 方法，如以下代码所示：</p><p><img src="/../images/4Qb15TfgRvpQVzKXeovi4x6n.jpg" alt="iShot_2023-07-30_08.42.21.jpg"></p><p>接下来我们看下 <code>DataOutputStream</code> 的<code> writeInt()</code> 方法是如何写 int 类型数据的</p><p><img src="/../images/GT5b8caHzuYKzwVp3UELmE1J.jpg" alt="iShot_2023-07-30_08.46.04.jpg"></p><p>我们可以逐步看下这几段代码的含义：</p><ol><li>out.write(): 很明显这是一个写入操作，可以将内容写入文件或者套接字。</li><li>v &gt;&gt;&gt; 24: 这是一个无符号右移操作符，将v向右移动24位（int 长度 4 字节，即 32 位，从第一个字节(8位)开始向右移动24 位即可达到最低位 32 ）。右移操作是将二进制表示中的各位数值向右移动指定的位数，右边的空位用零填充。无符号右移运算符保证移位后左边空出的位总是用零填充。在这个表达式中，我们将整数v的最高8位移动到最低8位，并将其余位数清零，这样就可以提取一个 int 类型变量的最高有效字节的值，而不考虑符号位。</li><li>&amp; 0xFF: 这是一个按位与操作符，将上一步的结果与0xFF（十进制为255）进行按位与操作。0xFF的二进制表示为 00000000 00000000 00000000 11111111。这个操作可以确保结果只保留v最高的8位，将其他位数清零。</li></ol><p>从上面的代码我们可以看出，确实是按照从高到低的顺序来写入的。我们继续看 <code>out.write()</code> 做了什么(在当前流程中，out 是 BlockDataOutputStream 实例)</p><p><img src="/../images/nnhkeZR9xVtXQ4HnDPLJKW8n.jpg" alt="iShot_2023-07-30_09.19.46.jpg"></p><p><img src="/../images/SvQVRsCFmpzJeBTjx6ELCScy.jpg" alt="iShot_2023-07-30_09.21.17.jpg"></p><p>如果缓冲区能容纳当前待写入字节，则把当前字节写入缓冲区；如果缓冲区已满，则会先执行 drain 方法把缓冲区的数据输出，再把当前待写入字节放到缓冲区。通过上述流程，一个 int 类型的数据就写完了，其他类型数据流程类似，此处不做展开。</p><h3 id="6-2-对象类型数据序列化流程"><a href="#6-2-对象类型数据序列化流程" class="headerlink" title="6.2 对象类型数据序列化流程"></a>6.2 对象类型数据序列化流程</h3><p>学习完基本类型的序列化流程，我们来看下对象类型的数据是怎么被序列化的。Java序列化对非基本类型的数据处理比基本类型的数据处理更复杂，这里说的非基本类型包括Object、Enum、Array等。Java序列化对非基本类型数据的序列化操作是通过 <code>ObjectOutputStream</code> 的 <code>writeObject</code> 方法实现的，接下来将介绍其内部工作原理。</p><p>我们先看下 <code>writeObjet</code> 方法定义</p><p><img src="/../images/DPzF8Spr8Y1DeJAGaAyFxfgd.jpg" alt="iShot_2023-07-30_09.25.21.jpg"></p><p>首先检查是否启用了对象写入的重写功能。如果启用了，将调用<code>writeObjectOverride</code>方法，并立即返回。这个条件语句允许自定义的子类重写写入对象的逻辑。obj表示自定义的序列化对象或者Array、Enum类型对象。<code>writeObject0</code> 方法的第2个参数表示一个对象被多个对象共同引用时，在序列化的时候是否要共享写入。如果共享写入，被引用的对象实例只会被序列化一次，其他引用只会写入引用对象句柄。如果不共享写入，被引用的对象实例则会被序列化多次，序列化后的数据大小会增加。在 <code>writeObject</code> 方法里调用 <code>writeObject0</code>，第2个参数默认是false，表示共享写入。</p><p>我们继续看下 <code>writeObject0</code> 里面是如何处理非基本类型数据的。</p><p><img src="/../images/rGryaNJzbY1qfN2fLNPeMoU9.jpg" alt="iShot_2023-07-30_09.36.33.jpg"></p><p>代码比较简单，就是判断 obj 的类型，然后分别调用对应的处理方法，其实如果大家有翻过 String 或者 Enum 的源码，就会发现，这两个类也是实现了 <code>Serializable</code> 接口的，表示这些类都能被正常的序列化。对于Array对象，如果Array的元素是基本类型，则调用基本类型的序列化方式；如果Array的元素是Object类型，则递归调用writeObject0方法来执行序列化，又会执行到上述if分支判断。 如果是自定义的序列化类，则必须实现自Serializable。<br>总之，要能够被 <code>ObjectOutputStream</code> 的 <code>writeObject</code> 方法序列化，对象必须实现自Serializable，否则会抛NotSerializableException异常。 如果是自定义的序列化类，则会执行 <code>writeOrdinaryObject</code> 方法。</p><p>我们看下 <code>writeOrdinaryObject</code> 这个方法是如何处理我们自定义的序列化类的。</p><p><img src="/../images/zit43xT8vvpH2TSrFCk4WaJE.jpg" alt="iShot_2023-07-30_09.47.04.jpg"></p><p>如果自定义的类是 Externalizable 类型并且不是代理类，则调用writeExternalData方法；否则调用writeSerialData方法。Exernalizable继承自Serializable，并增加了writeExternal和readExternal两个接口。我们继续跟进 <code>writeSerialData</code>方法。</p><p><img src="/../images/pHupFXsgkCUmToA3Xn1ZqSaH.jpg" alt="iShot_2023-07-30_09.49.33.jpg"></p><p>首先获取 obj 对象的布局信息，<code>getClassDataLayout()</code> 表示获取当前类及继承链路上所有直接或间接实现了Serializable的祖先类对应的序列化元数据信息，返回值为ClassDataSlot类型数组，数组元素的顺序是从最根部的祖先类到当前类。ClassDataSlot包含了一个ObjectStreamClass类型的desc字段和boolean类型的hasData字段。ObjectStreamClass类前面已经提过，hasData字段表示desc对应的Java对象是否有数据被序列化。对于ClassDataSlot数组的每一个元素，如果该元素对应的类包含writeObject方法，则调用writeObjet方法。通过查看ObjectStreamClass里的invokeWriteObject方法内部实现，可以看出wirteObject方法以反射方式被调用，代码如下所示。</p><p><img src="/../images/Jaou5jiRioCwnQy7rMkzizdY.jpg" alt="iShot_2023-07-30_09.53.31.jpg"></p><p>回到writeSerialData方法内部实现，如果当前待序列化的类没有writeObject方法，则调用defaultWriteFields方法实现序列化，其内部实现如以下代码所示。</p><p><img src="/../images/xk3DXSuHLEZe6h1gWBdsZTao.jpg" alt="iShot_2023-07-30_09.55.58.jpg"></p><p>流程也比较简单，就是分开处理基本类型和对象类型的数据，其实没有 writeObject() 方法的类，但是还需要序列化的，我们很明显就知道是实现了 Serializable 接口的类，这也就是为什么你实现了这个序列化接口，但是无需实现序列化方法的原因。</p><p>回到writeOrdinaryObject方法实现，如果自定义类实现了Externalizable且不是动态代理类，则会调用writeExternalData方法实现序列化，核心代码如下所示。</p><p><img src="/../images/Eqhuh4qAQWUGvqxbxvSAN7um.jpg" alt="iShot_2023-07-30_10.00.30.jpg"></p><p>代码最终调用自定义类对象的writeExternal方法实现写入，看起来比Serializable类更简洁，原因是Externalizable接口中包含了readExternal和writeExternal方法，实现了Externalizable的子类必须覆盖readExternal和writeExternal方法。</p><h2 id="7-Java-序列化高级特性"><a href="#7-Java-序列化高级特性" class="headerlink" title="7. Java 序列化高级特性"></a>7. Java 序列化高级特性</h2><h3 id="7-1-transient-关键字"><a href="#7-1-transient-关键字" class="headerlink" title="7.1 transient 关键字"></a>7.1 transient 关键字</h3><p>Java序列化可以通过transient关键字来控制字段不被序列化。通过跟进ObjectStreamClass的getDefaultSerialFields方法内部实现，可以看到序列化字段不能为static 且不能为 transient，如以下代码所示：</p><p><img src="/../images/7J2xJTK42JMS8aEvQswTH1Ta.jpg" alt="iShot_2023-07-30_10.11.25.jpg"></p><h3 id="7-2-static-关键字"><a href="#7-2-static-关键字" class="headerlink" title="7.2 static 关键字"></a>7.2 static 关键字</h3><p>static字段属于类全局共有，不会被序列化。在反序列化得到的结果里，静态变量的值依赖类对该静态字段的初始化操作以及是否在同一个JVM进程内。比如说静态变量初始值为0，在序列化之前静态变量的值被设置为10，在同一个JVM进程内执行反序列化操作，得到的静态变量的值为10。如果在另外一个JVM进程内执行反序列化操作，得到的静态变量的值为0。这是因为类在JVM进程内只会被加载一次，相同的类在不同的JVM内都会初始化一遍。</p><h3 id="7-3-serialVersionUID"><a href="#7-3-serialVersionUID" class="headerlink" title="7.3 serialVersionUID"></a>7.3 serialVersionUID</h3><p>serialVersionUID用来实现类版本兼容，在实际开发中能满足类字段变化的需求。如果我们有一个 Person 类，实现了 Serializable 接口，但是没有定义serialVersionUID字段，对Person类增加一个double类型的字段height，再读取增加字段之前的序列化数据，反序列化会报<code>InvalidCastException</code> 异常。如果Person类定义了serialVersionUID字段，对Person类增加一个double类型的字段height，再读取增加字段之前的序列化数据，反序列化可以成功。<br> serialVersionUID字段必须是 <code>static+final</code> 类型，否则serialVersionUID字段不会被序列化，通过 <code>ObjectStreamClass</code> 的 <code>getDeclaredSUID</code> 方法实现可以得到验证:</p><p><img src="/../images/fLhYY1UfUXYaYS8Sib2GqewM.jpg" alt="iShot_2023-07-30_10.14.50.jpg"></p><p>如果不定义serialVersionUID字段，Java序列化会根据类字段和其他上下文计算一个默认值。所以，当类字段发生变化时，serialVersionUID值也会跟着变化，就会出现上述因类字段变化导致反序列化失败的问题。在Java编码规范中，应该强制自定义的序列化类包含serialVersionUID字段，各个Java IDE开发工具均能配置针对serialVersionUID的检查告警级别。</p><h3 id="7-4-序列化-反序列化hook"><a href="#7-4-序列化-反序列化hook" class="headerlink" title="7.4 序列化&#x2F;反序列化hook"></a>7.4 序列化&#x2F;反序列化hook</h3><h4 id="7-4-1-writeReplace-方法"><a href="#7-4-1-writeReplace-方法" class="headerlink" title="7.4.1 writeReplace 方法"></a>7.4.1 writeReplace 方法</h4><p>writeReplace方法用于序列化写入时拦截并替换成一个自定义的对象。这个方法也是在 ObjectStreamClass 类中被反射获取的</p><p><img src="/../images/T499tgA9fZSSP5p9PPyYbTxV.jpg" alt="iShot_2023-07-30_10.24.33.jpg"></p><p>由于writeReplace方法调用是基于反射来执行的，所以作用域限定符不受限制，可以是private、default、protected、public中的任意一种。 如果定义了wirteReplace方法，就没必要再定义writeObject方法了。即使定义了writeObject方法，该方法也不会被调用，内部会先调用writeReplace方法将当前序列化对象替换成自定义目标对象。同理，也没必要定义readObject方法，即使定义了也不会被调用。writeReplace方法的生效原理见ObjectOutputStream的writeObject0方法实现，核心代码如下所示。</p><p><img src="/../images/6LkQhoJM6ZDiYWqgZ2Ugg8Yp.jpg" alt="iShot_2023-07-30_10.28.19.jpg"></p><h4 id="7-4-2-readReplace-方法"><a href="#7-4-2-readReplace-方法" class="headerlink" title="7.4.2 readReplace 方法"></a>7.4.2 readReplace 方法</h4><p>readResolve方法用于反序列化拦截并替换成自定义的对象。但和writeReplace方法不同的是，如果定义了readResolve方法，readObject方法是允许出现的。同样的，readResolve 方法也是在 ObjectStreamClass 类中被反射获取的。</p><p>readResolve方法的工作原理为： </p><ul><li>首先调用readObject0方法得到反序列化结果。 </li><li>如果readResolve方法存在，则会调用该方法返回自定义的对象。 </li><li>将自定义的对象作为ObjectInputStream的readObject的返回值。</li></ul><p>readResolve方法用在什么场景呢？常见的一种场景是类实现的枚举类型，枚举对象在反序列化时做恢复性保护。对于类实现的枚举类型，反序列化出来的枚举对象期望是定义的枚举对象，这也体现了枚举的意义。但是从代码执行情况看，反序列化出来的的枚举对象是一个新建出来的枚举对象，虽然值和枚举值定义的一样，但不是同一个对象。因此，需要在反序列化的过程中对枚举对象进行恢复保护，readResolve方法就派上用场了。示例如下：</p><p>未使用 readResolve 方法前：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oppo.serializedemo.pojo.po;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wick</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2023/7/29 22:17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoneType</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">PhoneType</span> <span class="variable">OPPO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhoneType</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">PhoneType</span> <span class="variable">VIVO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhoneType</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;phoneType.out&quot;</span>)));</span><br><span class="line">        os.writeObject(PhoneType.OPPO);</span><br><span class="line">        os.close();</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;phoneType.out&quot;</span>)));</span><br><span class="line">        <span class="type">PhoneType</span> <span class="variable">phoneType</span> <span class="operator">=</span> (PhoneType) is.readObject();</span><br><span class="line">        System.out.println(phoneType == PhoneType.OPPO); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加 readResolve 方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oppo.serializedemo.pojo.po;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wick</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2023/7/29 22:17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoneType</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">PhoneType</span> <span class="variable">OPPO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhoneType</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">PhoneType</span> <span class="variable">VIVO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhoneType</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> OPPO;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> VIVO;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;phoneType.out&quot;</span>)));</span><br><span class="line">        os.writeObject(PhoneType.OPPO);</span><br><span class="line">        os.close();</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;phoneType.out&quot;</span>)));</span><br><span class="line">        <span class="type">PhoneType</span> <span class="variable">phoneType</span> <span class="operator">=</span> (PhoneType) is.readObject();</span><br><span class="line">        System.out.println(phoneType == PhoneType.OPPO); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-5-数据校验"><a href="#7-5-数据校验" class="headerlink" title="7.5 数据校验"></a>7.5 数据校验</h3><p>Java序列化机制在反序列化时支持对数据进行校验。这是因为Java序列化后的数据是明文形式，有可能被修改。在反序列化过程中，为了安全起见，可以对读取到的数据进行校验。默认的Java反序列化是不会校验数据的。 使用数据校验特性，需要让自定义的序列化类实现 <code>java.io.ObjectInputValidation</code> 接口，通过调用回调函数 <code>validateObject</code> 来实现数据验证。此处给出示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oppo.serializedemo.pojo.po;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wick</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2023/7/30 10:45</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>, ObjectInputValidation &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validateObject</span><span class="params">()</span> <span class="keyword">throws</span> InvalidObjectException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(name, <span class="string">&quot;zhangSan&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;用户已经被禁用&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        in.defaultReadObject(); <span class="comment">// 执行默认的反序列化操作</span></span><br><span class="line">        validateObject(); <span class="comment">// 在反序列化完成后进行对象验证</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangSan&quot;</span>);</span><br><span class="line">        os.writeObject(user);</span><br><span class="line">        os.close();</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">        <span class="comment">// 在此处就会抛出异常：java.io.InvalidObjectException: 用户已经被禁用</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> (User) is.readObject();</span><br><span class="line">        is.close();</span><br><span class="line">        System.out.println(user1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-选择-Serializable-还是-Externalizable"><a href="#8-选择-Serializable-还是-Externalizable" class="headerlink" title="8 选择 Serializable 还是 Externalizable"></a>8 选择 Serializable 还是 Externalizable</h2><p>在Java序列化应用方面，读者应该会困惑两种机制应选择哪种。从功能角度看，二者都是Java序列化已经支持的。从易用性方面来考虑，Serializable比Externalizable易用性好。首先，Serializable提供了默认的序列化与反序列化行为，用户不需要关注序列化的实现细节即可拿来使用；而Externalizable必须实现readExternal和writeExternal接口且要提供默认构造函数。其次，在自定义序列化行为方面，Serializable也可以通过readObject和writeObject来支持。 对于初学者或者对自己代码水平没啥自信的同学，可以优先选择Serializable。从很多JDK源码和开源代码中可以看到，序列化接口都实现自Serializable。在继承链路上，如果要终止一个子类的Serializable或者Externaizable特性，则在readObject&#x2F;writeObject方法或readExternal&#x2F;writeExternal方法接口里抛出 <code>UnsupportedOperationException</code> 异常，表示不支持序列化和反序列化功能。</p><h2 id="9-Java序列化安全"><a href="#9-Java序列化安全" class="headerlink" title="9. Java序列化安全"></a>9. Java序列化安全</h2><p>Java序列化后的数据是明文形式，而且数据的组成格式有明确的规律。当这些数据脱离Java安全体系存在磁盘中时，可以通过二进制数编辑工具查看，甚至修改。如果这些数据注入了病毒，应用程序的表现行为将无法预计。为了保障数据的安全性，引入SealedObject和SignedObject对序列化数据进行加密。</p><h3 id="9-1-SealedObject"><a href="#9-1-SealedObject" class="headerlink" title="9.1 SealedObject"></a>9.1 SealedObject</h3><p>以下演示如何使用 SealedObject 来保证序列化&#x2F;反序列化安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oppo.serializedemo.pojo.po;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SealedObject;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wick</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2023/7/30 10:45</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">key</span> <span class="operator">=</span> KeyGenerator.getInstance(<span class="string">&quot;DESede&quot;</span>).generateKey();</span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;DESede&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, key);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangSan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="type">SealedObject</span> <span class="variable">sealedObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SealedObject</span>(user, cipher);</span><br><span class="line">        os.writeObject(sealedObject);</span><br><span class="line">        os.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用二进制工具查看 user 文件，发现跟我们之前未加密的数据不一样，连基本字段和值都看不到了</p><p><img src="/../images/eKGGeVsFyVRtbWwq9U8874nm.jpg" alt="iShot_2023-07-30_11.16.58.jpg"></p><p>我们直接使用 ObjectInputStream 反序列化一下试试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oppo.serializedemo.pojo.po;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SealedObject;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wick</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2023/7/30 10:45</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">key</span> <span class="operator">=</span> KeyGenerator.getInstance(<span class="string">&quot;DESede&quot;</span>).generateKey();</span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;DESede&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, key);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangSan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="type">SealedObject</span> <span class="variable">sealedObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SealedObject</span>(user, cipher);</span><br><span class="line">        os.writeObject(sealedObject);</span><br><span class="line">        os.close();</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">        <span class="type">SealedObject</span> <span class="variable">sealedObject1</span> <span class="operator">=</span> (SealedObject) is.readObject();</span><br><span class="line">        is.close();</span><br><span class="line">        <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> (User) sealedObject1.getObject(key);</span><br><span class="line">        System.out.println(u1); <span class="comment">// User(name=zhangSan, age=18)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们就通过一个加密&#x2F;解密的手段来保护了对象在序列化&#x2F;反序列化过程中的安全。</p><h3 id="9-2-SignedObject"><a href="#9-2-SignedObject" class="headerlink" title="9.2 SignedObject"></a>9.2 SignedObject</h3><p>SignedObject 也是通过加解密的方式来保护序列化安全的，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oppo.serializedemo.pojo.po;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyPair;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyPairGenerator;</span><br><span class="line"><span class="keyword">import</span> java.security.Signature;</span><br><span class="line"><span class="keyword">import</span> java.security.SignedObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wick</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2023/7/30 11:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;account&quot;</span>));</span><br><span class="line">        <span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> KeyPairGenerator.getInstance(<span class="string">&quot;RSA&quot;</span>).generateKeyPair();</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="string">&quot;zhangSan&quot;</span>, <span class="number">1000.0</span>);</span><br><span class="line">        <span class="type">SignedObject</span> <span class="variable">signedObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SignedObject</span>(account, keyPair.getPrivate(), Signature.getInstance(<span class="string">&quot;SHA256withRSA&quot;</span>));</span><br><span class="line">        os.writeObject(signedObject);</span><br><span class="line">        os.close();</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;account&quot;</span>));</span><br><span class="line">        <span class="type">SignedObject</span> <span class="variable">signedObject1</span> <span class="operator">=</span> (SignedObject) is.readObject();</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account1</span> <span class="operator">=</span> (Account) signedObject1.getObject();</span><br><span class="line">        System.out.println(account1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-总结"><a href="#10-总结" class="headerlink" title="10. 总结"></a>10. 总结</h2><p>Java序列化方案成熟度高，但性能和压缩效果均一般，只适合JVM系列语言共享数据，不具备完全的跨语言能力。另外，它会带来一些数据安全性和完整性问题。在我们真正的 web 开发过程中，基本不会去使用以上的序列化方式，而是往往会选择具有跨语言能力、性能高效、压缩效果显著的方案，例如Thrift、Protocol Buffer、Json、Xml 等。但是了解 Java 的序列化&#x2F;反序列化过程，对于程序员能力的提升，还是有较大的意义。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-技术背景&quot;&gt;&lt;a href=&quot;#1-技术背景&quot; class=&quot;headerlink&quot; title=&quot;1. 技术背景&quot;&gt;&lt;/a&gt;1. 技术背景&lt;/h2&gt;&lt;p&gt;​	互联网的迅猛发展受益于网络通信技术的成熟和稳定。网络通信协议是机器双方共同约定的协议。在应用层看到的</summary>
      
    
    
    
    
    <category term="Java" scheme="https://linvaux.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>IDEA高效使用指南(一)</title>
    <link href="https://linvaux.github.io/posts/fb3714ea/"/>
    <id>https://linvaux.github.io/posts/fb3714ea/</id>
    <published>2023-07-26T13:48:42.000Z</published>
    <updated>2024-09-21T00:59:08.926Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设置全局-JDK"><a href="#设置全局-JDK" class="headerlink" title="设置全局 JDK"></a>设置全局 JDK</h2><blockquote><p>File -&gt; New Projects Setup -&gt; Structure…</p></blockquote><p><img src="/../images/TBdebShUg5j9uqXoGuWsCDUd.png" alt="image.png"><br><img src="/../images/BavFvPU62j788uDuBM3LXwPJ.png" alt="image.png"></p><h2 id="Maven-配置"><a href="#Maven-配置" class="headerlink" title="Maven 配置"></a>Maven 配置</h2><blockquote><p>Perferences -&gt; Build,Execution,Deployment -&gt; Build Tools -&gt; Maven</p></blockquote><p><img src="/../images/26SMM42qFYidXc5p9NviwA4y.png" alt="image.png"></p><h2 id="自动导包-删除无用包"><a href="#自动导包-删除无用包" class="headerlink" title="自动导包&#x2F;删除无用包"></a>自动导包&#x2F;删除无用包</h2><blockquote><p>Perferences -&gt; Editor -&gt; General -&gt; Auto Import</p></blockquote><p><img src="/../images/xkNSjKsbfXT2nwarorw6ChRx.png" alt="image.png"></p><h2 id="注释模板"><a href="#注释模板" class="headerlink" title="注释模板"></a>注释模板</h2><blockquote><p>Perferences -&gt; Editor -&gt; File and Code Templates</p></blockquote><p><img src="/../images/w7kRgFWxWKPpfbkqysKqPKzH.png" alt="image.png"><br>class 注释模板示例</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#if ($&#123;PACKAGE_NAME&#125; &amp;&amp; $&#123;PACKAGE_NAME&#125; != &quot;&quot;)package $&#123;PACKAGE_NAME&#125;;#end</span><br><span class="line">#parse(&quot;File Header.java&quot;)</span><br><span class="line">/**  </span><br><span class="line"> * @author: $&#123;USER&#125;</span><br><span class="line"> * @date: $&#123;DATE&#125; $&#123;TIME&#125;</span><br><span class="line"> * @description: </span><br><span class="line"> */</span><br><span class="line">public class $&#123;NAME&#125; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="显示方法分割线"><a href="#显示方法分割线" class="headerlink" title="显示方法分割线"></a>显示方法分割线</h2><blockquote><p>Perferences -&gt; Editor -&gt; General -&gt; Appearance</p></blockquote><p><img src="/../images/icXHF1EX4Xg3Qx24fTiDypUg.png" alt="image.png"></p><h2 id="代码自动补全"><a href="#代码自动补全" class="headerlink" title="代码自动补全"></a>代码自动补全</h2><blockquote><p>Perferences -&gt; Editor -&gt; General -&gt; Code Completion</p></blockquote><p><img src="/../images/4Lkkem9rm8M8FTrubg5PU5HP.png" alt="image.png"></p><h2 id="设置每行代码最大长度"><a href="#设置每行代码最大长度" class="headerlink" title="设置每行代码最大长度"></a>设置每行代码最大长度</h2><blockquote><p>Perferences -&gt; Editor -&gt; Code Style</p></blockquote><blockquote><p>阿里巴巴的 Java 开发规范推荐每行长度不要超过 120，但是我习惯用 200</p></blockquote><p><img src="/../images/zvhD4qmyWkMLhXHtASGitDWP.png" alt="image.png"></p><h2 id="修改注释颜色"><a href="#修改注释颜色" class="headerlink" title="修改注释颜色"></a>修改注释颜色</h2><blockquote><p>Perferences -&gt; Editor -&gt; Color Scheme -&gt; Java</p></blockquote><blockquote><p>去掉Inherit values from 前面的√，选中 Foreground 自己设置个喜欢的颜色</p></blockquote><blockquote><p>这是我现在的配置 Line comment: FFB704, Text: 02FA15</p></blockquote><p><img src="/../images/bhm5KnJH1CaU48zokiyQS23z.png" alt="image.png"><br><img src="/../images/a9PmPRUXW6Vtf35sV72ZqoWZ.png" alt="image.png"></p><h2 id="禁止-IDEA-启动时，自动打开上一个项目"><a href="#禁止-IDEA-启动时，自动打开上一个项目" class="headerlink" title="禁止 IDEA 启动时，自动打开上一个项目"></a>禁止 IDEA 启动时，自动打开上一个项目</h2><blockquote><p>Perperences -&gt; Appearance &amp; Behavior -&gt; System Settings</p></blockquote><p><img src="/../images/7zhkSUh6vz4irhHqKvTDLCRz.png" alt="image.png"></p><h2 id="修改字体"><a href="#修改字体" class="headerlink" title="修改字体"></a>修改字体</h2><blockquote><p>Perferences -&gt; Editor -&gt; Font</p></blockquote><blockquote><p>我习惯使用 Consolas 字体，但是 mac 上默认没有这个字体，需要自行安装: <a href="http://www.fontpalace.com/font-details/Consolas/">http://www.fontpalace.com/font-details/Consolas/</a></p></blockquote><p><img src="/../images/CaLeXrjC82cMMY5p9aRNkoiC.png" alt="image.png"></p><h2 id="修改文件编码"><a href="#修改文件编码" class="headerlink" title="修改文件编码"></a>修改文件编码</h2><blockquote><p>Perferences -&gt; Editor -&gt; File Encodings</p></blockquote><blockquote><p>直接使用 UTF-8 编码即可，如果出现乱码，记得勾选下面的 Transparent native-to-ascii conversion </p></blockquote><p><img src="/../images/1Pe9GChSD4mQYNrTBCcXJnHQ.png" alt="image.png"></p><h2 id="修改-IDEA-的-JVM-堆配置"><a href="#修改-IDEA-的-JVM-堆配置" class="headerlink" title="修改 IDEA 的 JVM 堆配置"></a>修改 IDEA 的 JVM 堆配置</h2><blockquote><p>IDEA 默认的堆配置貌似是 750MB，启动一个大型项目时，这点内存不大够用，可以自己通过如下配置修改</p></blockquote><blockquote><p>help -&gt; Edit custom VM options</p></blockquote><blockquote><p>修改配置 -Xmx8192m, 按照自己电脑内存大小配置 </p></blockquote><p><img src="/../images/MpKzgoQVG1tKzaiHGAFfuEPW.png" alt="image.png"></p><h2 id="窗口多标签换行显示"><a href="#窗口多标签换行显示" class="headerlink" title="窗口多标签换行显示"></a>窗口多标签换行显示</h2><blockquote><p>Perferences -&gt; Editor -&gt; General -&gt; Editor Tabs</p></blockquote><p><img src="/../images/L4MEbkBerxeU4eeGsaTrM1zk.png" alt="image.png"><br><img src="/../images/1EaPuTQNRQjzgduEEyDiGH6Z.png" alt="image.png"></p><h2 id="标识修改过的文件"><a href="#标识修改过的文件" class="headerlink" title="标识修改过的文件"></a>标识修改过的文件</h2><blockquote><p>Perferences -&gt; Editor -&gt; General -&gt; Editor Tabs</p></blockquote><p><img src="/../images/ZUEdRrJxcawphjC1ihaNn8ef.png" alt="image.png"><br><img src="/../images/YLJ2tR7htEHb1anxHWEAaL1i.png" alt="image.png"></p><h2 id="实现-Serializable-接口时，提示生成-SerialVersionUID"><a href="#实现-Serializable-接口时，提示生成-SerialVersionUID" class="headerlink" title="实现 Serializable 接口时，提示生成 SerialVersionUID"></a>实现 Serializable 接口时，提示生成 SerialVersionUID</h2><blockquote><p>Perferences -&gt; Editor -&gt; Inspections</p></blockquote><blockquote><p>在实现了 Serializable 接口的类上使用快捷键 alt+enter,就会提示生成 SerialVersionUID<br><img src="/../images/sRxKbUJi6iKdrzTQnXg5VPx2.png" alt="image.png"><br><img src="/../images/iwxTcpwLk9cKfw8gSXC7WtiT.png" alt="image.png"></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;设置全局-JDK&quot;&gt;&lt;a href=&quot;#设置全局-JDK&quot; class=&quot;headerlink&quot; title=&quot;设置全局 JDK&quot;&gt;&lt;/a&gt;设置全局 JDK&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;File -&amp;gt; New Projects Setup -&amp;g</summary>
      
    
    
    
    
    <category term="IDEA" scheme="https://linvaux.github.io/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>IDEA插件整理(一)</title>
    <link href="https://linvaux.github.io/posts/c8c9feb8/"/>
    <id>https://linvaux.github.io/posts/c8c9feb8/</id>
    <published>2023-07-25T15:24:54.000Z</published>
    <updated>2024-09-21T00:59:08.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Atom-Material-Icons"><a href="#Atom-Material-Icons" class="headerlink" title="Atom Material Icons"></a>Atom Material Icons</h2><blockquote><p>material风格图标库，装完之后页面就花里胡哨的，挺好看</p></blockquote><p><img src="/../images/4o5karobikm85LEMxj4DfxUr.png" alt="image.png"></p><h2 id="Material-Theme-UI"><a href="#Material-Theme-UI" class="headerlink" title="Material Theme UI"></a>Material Theme UI</h2><blockquote><p>material风格主题，还是挺好看的</p></blockquote><p><img src="/../images/2WeZMft79yVRxEunemT7onp8.png" alt="image.png"></p><h2 id="One-Dark-Theme"><a href="#One-Dark-Theme" class="headerlink" title="One Dark Theme"></a>One Dark Theme</h2><blockquote><p>暗黑风格主题（推荐），主要是免费</p></blockquote><p><img src="/../images/QGwGDsi745gNenshZD9k68st.png" alt="image.png"></p><h2 id="Rainbow-Brackets"><a href="#Rainbow-Brackets" class="headerlink" title="Rainbow Brackets"></a>Rainbow Brackets</h2><blockquote><p>彩虹括号</p></blockquote><p><img src="/../images/mpmkLHVZCyKwPTgDWo2ajNQN.png" alt="image.png"></p><h2 id="ignore"><a href="#ignore" class="headerlink" title=".ignore"></a>.ignore</h2><blockquote><p>生成各类.ignore文件，在创建git仓库的时候使用此插件格外方便</p></blockquote><p><img src="/../images/f7764ovtWyVzqJFDgWC5cAzY.png" alt="image.png"></p><h2 id="CodeGlance"><a href="#CodeGlance" class="headerlink" title="CodeGlance"></a>CodeGlance</h2><blockquote><p>代码缩略图，方便定位代码</p></blockquote><p><img src="/../images/xvXgEmtNUAuahcuZtoY5sHuT.png" alt="image.png"></p><h2 id="Java-Bean-to-Json"><a href="#Java-Bean-to-Json" class="headerlink" title="Java Bean to Json"></a>Java Bean to Json</h2><blockquote><p>在bean上右键，即可将此bean复制为json格式，在构造请求时比较方便</p></blockquote><h2 id="maven-search"><a href="#maven-search" class="headerlink" title="maven-search"></a>maven-search</h2><blockquote><p>maven&#x2F;gradle坐标搜索插件，贼好用，支持模糊搜索</p></blockquote><p><img src="/../images/brhT5YKKHNsTncGjpV5cCdA4.png" alt="image.png"></p><h2 id="Maven-Helper"><a href="#Maven-Helper" class="headerlink" title="Maven Helper"></a>Maven Helper</h2><blockquote><p>依赖冲突查看神器，也可以树状展示依赖关系</p></blockquote><p><img src="/../images/Xt34QvHpHA8i3jjAjiKNwbSg.png" alt="image.png"></p><h2 id="Mybatisx"><a href="#Mybatisx" class="headerlink" title="Mybatisx"></a>Mybatisx</h2><blockquote><p>mybatis-plus团队出品的插件，支持从数据库表直接生成代码，包含基本CRUD功能，很方便</p></blockquote><h2 id="MyBatisCodeHelperPro"><a href="#MyBatisCodeHelperPro" class="headerlink" title="MyBatisCodeHelperPro"></a>MyBatisCodeHelperPro</h2><blockquote><p>怎么说呢，就是很厉害，基本不用自己写代码了，但是收费</p><ul><li>演示视频：<a href="https://www.bilibili.com/video/av50632948">https://www.bilibili.com/video/av50632948</a></li><li>使用文档：<a href="https://gejun123456.github.io/MyBatisCodeHelper-Pro/#/">https://gejun123456.github.io/MyBatisCodeHelper-Pro/#/</a></li></ul></blockquote><h2 id="MyBatis-Log-EasyPlus"><a href="#MyBatis-Log-EasyPlus" class="headerlink" title="MyBatis Log EasyPlus"></a>MyBatis Log EasyPlus</h2><blockquote><p>格式化mybatis日志，很好用</p></blockquote><p><img src="/../images/E3TYbUkbjRPj1m6uZiVt1k6p.png" alt="image.png"></p><h2 id="SequenceDiagram"><a href="#SequenceDiagram" class="headerlink" title="SequenceDiagram"></a>SequenceDiagram</h2><blockquote><p>生成方法的时序图，非常有用<br>官方文档：<a href="https://vanco.github.io/SequencePlugin/">https://vanco.github.io/SequencePlugin/</a></p></blockquote><p><img src="/../images/LER7ybg174LhKcQL3HaZShkv.png" alt="image.png"></p><h2 id="PlantUML"><a href="#PlantUML" class="headerlink" title="PlantUML"></a>PlantUML</h2><blockquote><p>时序图，类图绘制插件</p></blockquote><p><img src="/../images/HsoHEk1YjMgf8QEqmFxPasDD.png" alt="image.png"></p><h2 id="Grep-Console"><a href="#Grep-Console" class="headerlink" title="Grep Console"></a>Grep Console</h2><blockquote><p>由于Intellij idea不支持显示ascii颜色，grep-console插件能很好的解决这个问题，下面就以开发JavaEE项目中，结合Log4j配置多颜色日志输出功能。</p></blockquote><p><img src="/../images/DdDMTYcUyz5Zt87Duy1U6D4D.png" alt="image.png"><br><img src="/../images/6aPcSTCmJXVjy9VZyejdF1it.png" alt="image.png"></p><h2 id="GitToolBox"><a href="#GitToolBox" class="headerlink" title="GitToolBox"></a>GitToolBox</h2><blockquote><p>git工具箱，可以显示当前代码分支和每一行代码提交人以及commit log</p></blockquote><p><img src="/../images/zdGJ2NS6vj6XhRT1CbkkDNdq.png" alt="image.png"></p><h2 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h2><blockquote><p>翻译插件，再也不用去百度翻译了</p></blockquote><h2 id="RestfulToolkit"><a href="#RestfulToolkit" class="headerlink" title="RestfulToolkit"></a>RestfulToolkit</h2><blockquote><p>根据url直接跳转到对应的controller，比较好用，尤其是url多的时候，直接搜索url就可以了<br><img src="/../images/7Sdd5MxGWthLR63qgUp5hQMt.png" alt="image.png"></p></blockquote><h2 id="Key-promoter-X"><a href="#Key-promoter-X" class="headerlink" title="Key promoter X"></a>Key promoter X</h2><blockquote><p>记性不好的可以试试，时间长了就能记住快捷键了</p></blockquote><h2 id="Statistic"><a href="#Statistic" class="headerlink" title="Statistic"></a>Statistic</h2><blockquote><p>项目信息统计</p></blockquote><p><img src="/../images/Gw7PUVv9a1H8ERJBtKfZdcgj.png" alt="image.png"></p><h2 id="Git-Commit-Message-Helper"><a href="#Git-Commit-Message-Helper" class="headerlink" title="Git Commit Message Helper"></a>Git Commit Message Helper</h2><blockquote><p>帮助生成commit message<br><img src="/../images/T4QM3G1XVVKLiZk8AYdVgPSq.png" alt="image.png"></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Atom-Material-Icons&quot;&gt;&lt;a href=&quot;#Atom-Material-Icons&quot; class=&quot;headerlink&quot; title=&quot;Atom Material Icons&quot;&gt;&lt;/a&gt;Atom Material Icons&lt;/h2&gt;&lt;bloc</summary>
      
    
    
    
    
    <category term="IDEA" scheme="https://linvaux.github.io/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Jmeter源码系列(3) - Jmeter 类详解-start方法，Jmeter 真正的启动过程</title>
    <link href="https://linvaux.github.io/posts/e7832353/"/>
    <id>https://linvaux.github.io/posts/e7832353/</id>
    <published>2023-07-14T14:07:00.000Z</published>
    <updated>2024-09-21T00:59:08.934Z</updated>
    
    <content type="html"><![CDATA[<p>在开始讲 start 方法前，大家先考虑一个问题，Jmeter 启动时带不带参数有什么影响？我们可以带着这个问题往下看。</p><h2 id="Jmeter启动参数是如何传递的？"><a href="#Jmeter启动参数是如何传递的？" class="headerlink" title="Jmeter启动参数是如何传递的？"></a>Jmeter启动参数是如何传递的？</h2><p>在前面两篇文章中，已经跟大家非常详细的介绍了 Jmeter 启动时会做什么，回顾一下就是：</p><ol><li>调用 NewDriver.main(String[] args) 方法，此方法会反射调用 Jmeter.start(String[] args) 方法。</li><li>在执行 Jmeter.start(String[] args) 方法前，Jmeter 类现需要实例化，这个类中包含了非常多的静态常量，绝大多数都是跟启动参数相关，这些参数会在类实例化时也被初始化掉。</li></ol><p>那么这些参数是从哪来的呢？其实入口就是 NewDriver.main(String[] args) ，这个方法的参数列表可以从 Jmeter 的启动脚本获取，也可以通过执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ApacheJMeter.jar xxx 来启动</span><br></pre></td></tr></table></figure><p>后面的 xxx 表示的就是启动参数，跟执行以下命令效果一样</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmeter xxx</span><br></pre></td></tr></table></figure><p>我们可以通过查看 Jmeter &#x2F;bin 目录下的 jmeter 脚本来验证这个过程，以下内容是 JMeter 在 mac 下的启动脚本，其中只保留了最后几行内容，其他系统下的脚本内容也是类似，就不在此处展开解释。<br><img src="/../images/hvUygdpNKPX9BwJzn3NiMk7v.png" alt="image.png"><br>这段脚本其实很简单，就是判断 JMETER_COMPLETE_ARGS 这个变量是不是为空，用来控制 ARGS 参数值，最后一行就是很普通的 java 应用启动命令，后面的 “$@” 是一个特殊变量，用于表示所有向脚本传递的位置参数（命令行参数）。具体来说，$@ 会将所有的位置参数作为一个单独的字符串列表返回。每个位置参数会被当作一个独立的字符串，在使用时可以通过遍历 $@ 获取每个参数。需要注意的是，”$@” 使用双引号括起来时，会将每个位置参数作为独立的字符串处理，保留参数中的空格和特殊字符。这样可以确保传递参数时的正确性，在处理包含空格或特殊字符的参数时非常有用。</p><p>顺便提一句，上面判断了 JMETER_COMPLETE_ARGS 是为了给 Java9 单独设置一些启动参数，因为在 Java 9 之前的版本中，可以使用标准的 JAVA_OPTS 环境变量来设置 Java 虚拟机的选项。然而，从 Java 9 开始，Oracle 官方建议使用 JAVA_TOOL_OPTIONS 环境变量来设置 Java 应用程序的选项，以便与新的模块化系统和命令行标志兼容。为了确保 JMeter 在不同版本的 Java 中都能正常运行，并且可以方便地配置 Java 9 相关的选项，此处单独处理了 Java 9 的选项设置。通过使用 JAVA9_OPTS 环境变量存储 Java 9 相关的选项，并将其与其他选项拼接到 ARGS 字符串中，以便将这些选项传递给 JMeter 启动脚本。这种单独处理 Java 9 的选项，能够更好地适应不同版本的 Java，并确保在升级或切换 Java 版本时不会影响到 JMeter 的启动脚本和选项设置。这样做的目的是为了提高 JMeter 的兼容性和可移植性。</p><p>ok，那现在我们知道了，NewDeriver.main(String[] args) 会接受命令行参数，然后 main 方法再反射调用 Jmeter.start(String[] args) 时，也会把参数传递下去，代码如图所示：<br><img src="/../images/EexSxwSzkJsBEGauLE2kJANm.png" alt="image.png"><br>invoke 方法第二个参数 args 就是 main 方法接收到的参数，这就完成了参数从命令行传递给 Jmeter 的过程，在实例化 Jmeter 时，这些参数又被 CLOptionDescriptor 类处理了一次，从一堆字符串变成了一个对象，方便 Jmeter 更好的处理参数，那接下来我们迎来了本文章的重点：Jmeter.start(String[] args) 方法到底做了什么？</p><h2 id="Jmeter-是如何启动的？"><a href="#Jmeter-是如何启动的？" class="headerlink" title="Jmeter 是如何启动的？"></a>Jmeter 是如何启动的？</h2><p>在解释代码之前，大家有没有发现一个现象：</p><p>当我们什么启动参数都不带时，Jmeter 会直接以 GUI 模式启动，我们可以写脚本调试，甚至直接开始测试，也可以不跑测试，写个脚本就把它关掉。但是当我们使用 cli 时，就可以直接传递一个 jmx 脚本给 Jmeter，这时 Jmeter 就会直接开始测试。这两种方式是如何实现的呢？</p><p>如果大家有观察过这个现象，那接下来的内容会非常容易理解，因为这涉及到了 Jmeter 的 2 种启动模式：</p><ol><li>startGui</li><li>startNonGui</li></ol><p>但是这个时候大家会疑惑，之前不是说 Jmeter 有三种启动模式么，分别是：GUI，NON-GUI, SERVER，为啥到这边又成了 2 种了？</p><p>其实，这前后并没有矛盾，因为 SERVER 和 NON-GUI 模式都是属于 NON-GUI 的方式启动，我们此处只是讨论 Jmeter 在启动时的宏观表现，即有没有图形界面。</p><p>接下来，我们就开始从代码出发，看下 Jmeter 真正的启动过程。</p><h3 id="1-命令行参数校验"><a href="#1-命令行参数校验" class="headerlink" title="1.命令行参数校验"></a>1.命令行参数校验</h3><p><img src="/../images/Yor8kSTZiyTNFWsoY66cWa99.png" alt="image.png"><br>在进入 start 方法后，会先对命令行参数的组合进行判断，如果参数组合不支持，则生成一个 error 信息，然后判断 error 是否为 null，如果有错误信息，则停止启动，并在控制台输出错误信息。</p><h3 id="2-初始化运行环境"><a href="#2-初始化运行环境" class="headerlink" title="2.初始化运行环境"></a>2.初始化运行环境</h3><p>参数校验通过之后，Jmeter 会进行运行环境初始化，虽然 NewDriver 已经初始化过一次(主要做类加载)，但是 Jmeter 会做更细致的初始化动作，以下是 Jmeter 初始化内容<br><img src="/../images/qdEYUhWxbfUiPnBbEFXKR3g2.png" alt="image.png"></p><ol><li>初始化 Properties：实现方法为 Jmeter.initializeProperties(CLArgsParser parser) 方法。首先检查用户是否通过 -p 参数设置了 property 文件，如果没有设置，则直接使用 bin&#x2F;jmeter.properties 文件。其次设置 Jmeter 语言环境，设置 JmeterHome，还有就是读取 user.properties，system.properties 以及用户通过命令行参数自己指定的 property 文件，最后设置下日志等级。</li><li>添加安全提供程序：根据给定的 Properties 对象，筛选匹配特定模式的键值对，并按照键的顺序逐个调用 addSecurityProvider 方法，作用是：(1)扩展功能：通过添加安全提供程序，可以扩展 Java 程序的加密、签名、哈希等安全功能，使其支持更多的算法和标准。这样，程序就可以使用更多安全服务来满足特定的需求。(2)第三方库或协议支持：有些第三方库或协议可能需要特定的加密、签名或认证机制。通过添加相应安全提供程序，可以为这些库或协议提供所需的支持，确保程序能够与它们进行兼容性的交互。(3)安全策略和规范：在某些情况下，出于安全策略和规范的考虑，需要使用特定的安全提供程序来确保符合特定的安全要求。通过添加这些提供程序，可以实施和遵循特定的安全标准。</li><li>设置默认的未捕获异常处理器：当发生未捕获异常时，使用注册的异常处理器进行处理，即在控制台输出异常信息。</li><li>设置代理：因为用户可以通过命令行参数设置代理服务器，代码比较简单，就不展开讲解了，知道是做什么就行了。</li><li>更新加载的类：又去把一堆类加载进来，核心还是调用 NewDriver.addURL(path); 方法。此处不展开讲解。</li><li>设置几个属性：设置开始时间，开始日期，以及开始的时分秒，但是感觉没啥鸟用，连注释都写了：Set some (hopefully!) useful properties，意思就是希望这几个参数你能用得上。</li></ol><h3 id="3-Jmeter-真正的启动"><a href="#3-Jmeter-真正的启动" class="headerlink" title="3.Jmeter 真正的启动"></a>3.Jmeter 真正的启动</h3><p><img src="/../images/CQMWP4PUfdmWPP8qz3jxtYP2.png" alt="image.png"></p><ol><li>首先，判断用户有没有使用 -s 参数，如果用了这个参数，则使用 Server 模式启动。下面还有个 startOptionalServers(); 方法，其实不管是哪种启动方式，都会执行这个方法，它的作用就是根据配置启动可选的 Beanshell 服务器和 Mirror 服务器。Beanshell 服务器提供了自定义逻辑的执行能力，而 Mirror 服务器则用于模拟外部服务器行为。通过这些服务器，用户可以在测试期间执行自定义逻辑和模拟环境，以满足特定的测试需求。<br><img src="/../images/zYmVN7Z9JPQ3sJtPKT6pcsUy.png" alt="image.png"></li><li>接下来判断是否使用了 -t 和 -g 两个参数，-t 用来指定 jmx 文件，-g 用来生成报告。注意，此时并没有真的把 jmx 文件加载进 Jmeter，更没有生成报告，只是做了参数的赋值操作。<br><img src="/../images/5rybjpANSZ2HLT95ww7XHXYU.png" alt="image.png"></li><li>继续判断是否使用了 -n 参数，如果没有使用这个参数，则会启动图形界面。在启动图形界面前，会先调用PluginManager.install(this, true);方法来加载插件，还记得之前讲过Jmeter 实现了JMeterPlugin 接口么？作用就在此处体现了，要去加载 Jmeter 的图标和其他的资源文件。然后就会真正的启动 GUI 了，同时会在控制台打印一段熟悉的内容<br><img src="/../images/2dgPAadi6mePAaC53Yc2YGnd.png" alt="image.png"><br>此时，Jmeter 通过图形界面真正的启动了，当然如果你在启动前指定了 jmx 文件，那么 Jmeter 打开之后，就会默认加载这个文件，否则就是默认新建 TestPlan 的页面。</li><li>如果用户使用了 -n 参数，则说明要使用 NON-GUI 启动。启动流程也很简单，先检查下几个文件夹能不能正常写入，比如通过 -o 参数指定的报告文件夹，Jmeter 默认的报告输出文件夹等。然后就是检查是否通过 -R 指定了远程执行的机器，通过 -t 生成 jtl 文件，再检查使用了 -e 参数之后，-t 参数是不是为 null，如果没有指定要生成 jtl 文件，但是要求生成报告的话，则会抛异常，因为 Jmeter 的报告就是通过解析 jtl 文件得到的，具体是怎么生成的，会在后面的章节中跟大家探讨。最后调用 startNonGui()方法来启动无界面模式的 Jmeter。<br><img src="/../images/jbcBHRdNqJKxcFiKjzdndZVZ.png" alt="image.png"></li></ol><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><p>至此，让我们通过一张图来了解下 Jmeter 的启动过程</p><p><img src="/../images/fAzxzWRan2TnVisiiFA3HQMY.png" alt="image.png"></p><p>此时，Jmeter 算是真正的启动起来了，因为 GUI 模式启动涉及到大量关于 Java Swing 的内容，不在本文章讨论范围内，我会主要从 NON-GUI 模式来跟大家讲解 Jmeter 的运行原理，因为两种模式本质上都是通过 Jmeter 执行引擎来实现测试的。下一章开始，我们将继续深入了解使用无界面模式启动后，Jmeter 是如何开始测试的…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在开始讲 start 方法前，大家先考虑一个问题，Jmeter 启动时带不带参数有什么影响？我们可以带着这个问题往下看。&lt;/p&gt;
&lt;h2 id=&quot;Jmeter启动参数是如何传递的？&quot;&gt;&lt;a href=&quot;#Jmeter启动参数是如何传递的？&quot; class=&quot;headerlin</summary>
      
    
    
    
    
    <category term="Jmeter源码系列" scheme="https://linvaux.github.io/tags/Jmeter%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Jmeter源码系列(2) - Jmeter 类详解-命令行参数处理CLOptionDescriptor</title>
    <link href="https://linvaux.github.io/posts/ebfc10d8/"/>
    <id>https://linvaux.github.io/posts/ebfc10d8/</id>
    <published>2023-07-08T14:06:03.000Z</published>
    <updated>2024-09-21T00:59:08.933Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇我们详细了解了 Jmeter 的启动类 NewDriver，知道了 NewDriver 会通过反射调用 Jmeter.start(String[] args)方法来启动 Jmeter，今天我们来分析下，Jmeter这个类内部到底做了什么。本篇章不会直接开始讲 start 方法，而是会先讲一下 Jmeter 类里面设置的 static 变量，因为这些变量会影响 jmeter 启动时的一些行为。</p><h2 id="Jmeter-类的作用"><a href="#Jmeter-类的作用" class="headerlink" title="Jmeter 类的作用"></a>Jmeter 类的作用</h2><p><a href="https://github.com/apache/jmeter/blob/master/src/core/src/main/java/org/apache/jmeter/JMeter.java">Jmeter</a>类位于 org.apache.jmeter 包下，通过类注释可以了解到它的作用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Main JMeter class; processes options and starts the GUI, non-GUI or server as appropriate.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>Jmeter.class 是 Jmeter 的主要类，是为了让 Jmeter 通过 GUI，NON-GUI 或者server模式启动。通过我们使用 Jmeter 工具也能发现，Jmeter 正常情况下启动会有用户界面，方便我们编写 jmx 脚本或者调试 jmx 脚本。但是也可以通过 jmeter -n 模式来启动命令行模式(此处应该是无界面模式更合适)执行 jmx 脚本，并且在 Jmeter 启动时，console 里面也会打印如下内容：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">================================================================================</span><br><span class="line">Don&#x27;t use GUI mode for load testing !, only for Test creation and Test debugging.</span><br><span class="line">For load testing, use CLI Mode (was NON GUI):</span><br><span class="line">   jmeter -n -t [jmx file] -l [results file] -e -o [Path to web report folder]</span><br><span class="line">&amp; increase Java Heap to meet your test requirements:</span><br><span class="line">   Modify current env variable HEAP=&quot;-Xms1g -Xmx1g -XX:MaxMetaspaceSize=256m&quot; in the jmeter batch file</span><br><span class="line">Check : https://jmeter.apache.org/usermanual/best-practices.html</span><br><span class="line">================================================================================</span><br></pre></td></tr></table></figure><p>这段内容其实包含 2 个关键内容：</p><ol><li>调试 jmx 脚本的时候可以使用有界面模式，如果要进行测试的话，建议我们使用CLI模式，即无界面模式。</li><li>告诉用户如何配置 Jmeter 的堆内存，因为 Jmeter 本身是基于 Java 开发，也是运行在 JVM 虚拟机上的，所以如果我们进行性能测试前，可以适当调整堆内存，来防止测试过程中发生 OOM 等异常。</li></ol><p>除了有界面和无界面两种启动模式，Jmeter 还有一种server模式，即集群模式。Jmeter 本身是支持分布式压测的，当单机的并发能力存在瓶颈的时候，可以通过配置 slave 节点来实现分布式压测，这个时候，Jmeter 就是以 server 模式启动的。</p><h2 id="Jmeter-中的-CLOptionDescriptor"><a href="#Jmeter-中的-CLOptionDescriptor" class="headerlink" title="Jmeter 中的 CLOptionDescriptor"></a>Jmeter 中的 CLOptionDescriptor</h2><p>打开 org.apache.jmeter.Jmeter.java 源码，我们会发现，这个类内部定义了几十个静态变量，而且这个类还实现了一个 JMeterPlugin 接口。我们先看JMeterPlugin接口，此接口内部只有两个方法</p><ul><li>String[][] getIconMappings();</li><li>String[][] getResourceBundles();</li></ul><p>第一个 getIconMappings() 方法用于获取插件中的图标映射信息。返回一个二维字符串数组，每个数组元素包含两个字符串：图标名称和图标文件的路径。这些图标文件可以用于在 JMeter 用户界面中显示插件的图标。通过实现 getIconMappings() 方法并返回相应的图标映射，插件可以将自定义的图标与插件相关联，并在 JMeter 中展示出来，以提供更好的用户体验和可视化效果。我们使用 Jmeter 的时候就能发现，每个组件前面都会带个小图标，就是通过这个方法来去加载这些图标的。</p><p>第二个 getResourceBundles() 其实更容易理解，如果大家开发过 web 项目，知道 resourceBundles 是啥，没错，就是用来做国际化的。这个方法用于获取插件中的资源绑定信息。返回一个二维字符串数组，每个数组元素包含两个字符串：资源包的基本名称和资源包的位置。资源包是包含本地化文本消息、错误消息、标签等的文件集合，用于国际化和本地化插件的用户界面。通过实现 getResourceBundles() 方法并返回相应的资源绑定信息，插件可以实现多语言支持，并根据用户的语言环境动态加载适当的本地化资源。</p><p>接下来，我们看下 Jmeter 中定义了这么多变量有啥用，当然，我不会把每个变量都解释一遍，只会对关键部分做解释说明。在这些变量中，有很多变量是类似于以下这种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REMOTE_OPT_PARAM</span> <span class="operator">=</span> <span class="string">&#x27;R&#x27;</span>;</span><br></pre></td></tr></table></figure><p>大家要注意，这个变量类型是 int，并不是 char，因为这个变量其实是代表了’R’的 ASCII 编码值（十进制数）也就是：82。这种做法是为了提高代码的可读性和可维护性。通过使用命名的常量，代码的其他部分可以直接使用 REMOTE_OPT_PARAM 来表示这个特定的值，而不是使用硬编码的字符 ‘R’ 或数字 82。这样，如果将来需要更改这个值，只需修改常量的定义即可，而不需要对代码中所有引用到这个值的地方进行修改。</p><p>这种定义的变量，会被一个叫 CLOptionDescriptor 的类解析，我们先看下这个类它的作用是什么，其实第一眼看到这个类名的时候，就能大概猜出来，这是用来解析命令行参数的。它其实是 Apache Commons CLI 库中的一个类，作用就是解析命令行参数，提供了定义选项的名称、别名、描述、参数属性和行为的方法。这个类具体的作用如下：</p><ul><li>描述选项的名称和别名：CLOptionDescriptor 允许您定义选项的名称、短名称和长名称等标识符。通过这些标识符，您可以在命令行中识别并指定特定的选项。</li><li>指定选项的描述信息：CLOptionDescriptor 允许您为选项提供文本描述或帮助信息，以帮助用户理解该选项的作用和用法。</li><li>指定选项的参数属性：CLOptionDescriptor 可以定义选项是否需要参数以及参数的类型。它支持定义选项是否需要参数、参数的最少和最多出现次数、参数的默认值等属性。</li><li>配置选项的行为：CLOptionDescriptor 提供了一些方法来配置选项的行为。例如，您可以定义选项是否为必需选项、是否允许多次使用、是否支持可变参数数量等。</li></ul><p>所以，这个类的作用，就是在 CLI 模式下，解析参数用的。比如当我们使用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmeter -h</span><br></pre></td></tr></table></figure><p>就可以看到以下输出：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">    _    ____   _    ____ _   _ _____       _ __  __ _____ _____ _____ ____</span><br><span class="line">   / \  |  _ \ / \  / ___| | | | ____|     | |  \/  | ____|_   _| ____|  _ \</span><br><span class="line">  / _ \ | |_) / _ \| |   | |_| |  _|    _  | | |\/| |  _|   | | |  _| | |_) |</span><br><span class="line"> / ___ \|  __/ ___ \ |___|  _  | |___  | |_| | |  | | |___  | | | |___|  _ &lt;</span><br><span class="line">/_/   \_\_| /_/   \_\____|_| |_|_____|  \___/|_|  |_|_____| |_| |_____|_| \_\ 5.4.1</span><br><span class="line"></span><br><span class="line">Copyright (c) 1999-2021 The Apache Software Foundation</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">To list all command line options, open a command prompt and type:</span><br><span class="line"></span><br><span class="line">jmeter.bat(Windows)/jmeter.sh(Linux) -?</span><br><span class="line"></span><br><span class="line">--------------------------------------------------</span><br><span class="line"></span><br><span class="line">To run Apache JMeter in GUI mode, open a command prompt and type:</span><br><span class="line"></span><br><span class="line">jmeter.bat(Windows)/jmeter.sh(Linux) [-p property-file]</span><br><span class="line"></span><br><span class="line">--------------------------------------------------</span><br><span class="line"></span><br><span class="line">To run Apache JMeter in NON_GUI mode:</span><br><span class="line">Open a command prompt (or Unix shell) and type:</span><br><span class="line"></span><br><span class="line">jmeter.bat(Windows)/jmeter.sh(Linux) -n -t test-file [-p property-file] [-l results-file] [-j log-file]</span><br><span class="line"></span><br><span class="line">--------------------------------------------------</span><br><span class="line"></span><br><span class="line">To run Apache JMeter in NON_GUI mode and generate a report at end :</span><br><span class="line">Open a command prompt (or Unix shell) and type:</span><br><span class="line"></span><br><span class="line">jmeter.bat(Windows)/jmeter.sh(Linux) -n -t test-file [-p property-file] [-l results-file] [-j log-file] -e -o [Path to output folder]</span><br><span class="line"></span><br><span class="line">--------------------------------------------------</span><br><span class="line">To generate a Report from existing CSV file:</span><br><span class="line">Open a command prompt (or Unix shell) and type:</span><br><span class="line"></span><br><span class="line">jmeter.bat(Windows)/jmeter.sh(Linux) -g [csv results file] -o [path to output folder (empty or not existing)]</span><br><span class="line"></span><br><span class="line">--------------------------------------------------</span><br><span class="line"></span><br><span class="line">To tell Apache JMeter to use a proxy server:</span><br><span class="line">Open a command prompt and type:</span><br><span class="line"></span><br><span class="line">jmeter.bat(Windows)/jmeter.sh(Linux) -H [your.proxy.server] -P [your proxy server port]</span><br><span class="line"></span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line">To run Apache JMeter in server mode:</span><br><span class="line">Open a command prompt and type:</span><br><span class="line"></span><br><span class="line">jmeter-server.bat(Windows)/jmeter-server(Linux)</span><br><span class="line"></span><br><span class="line">---------------------------------------------------</span><br></pre></td></tr></table></figure><p>那么这些输出是哪里来的呢？很明显不是 CLOptionDescriptor 打印的，因为这个类的作用就是解析长短参数，还有参数提示，并不会给出命令执行的结果，我们翻一下代码就能看到，其实这个命令的结果是被 Jmeter 处理之后返回的<br><img src="/../images/LatLdz57irNLe8Bn2p6BnDiR.png" alt="image.png"><br>这段代码就在 Jmeter.start(String[] args) 方法中，判断了参数列表是不是包含 ‘h’,然后打印了 org&#x2F;apache&#x2F;jmeter&#x2F;help.txt 这个文件的内容，我们也可以打开这个文件，看下内容是不是一样的<br><img src="/../images/8xrrb6e3CD9LVvyTnnKSjEUV.png" alt="image.png"><br>我们可以看到，打印内容基本一致，但是少了一个 banner 图，那是因为 banner 图是在上面的 displayAsciiArt()方法中打印的，我们也可以顺便看下这段打印 banner 的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">displayAsciiArt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> JMeter.class.getResourceAsStream(<span class="string">&quot;jmeter_as_ascii_art.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(inputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> IOUtils.toString(inputStream, StandardCharsets.UTF_8);</span><br><span class="line">                System.out.println(text);<span class="comment">//NOSONAR</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e1) &#123; <span class="comment">//NOSONAR No logging here</span></span><br><span class="line">            System.out.println(JMeterUtils.getJMeterCopyright());<span class="comment">//NOSONAR</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Version &quot;</span> + JMeterUtils.getJMeterVersion());<span class="comment">//NOSONAR</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码其实很简单，就是读了一个文件，然后输出到控制台，仅此而已。所以，综上所述，Jmeter 这个类，内部的静态变量其实就是在解析命令行参数，最后这些参数会被存储在 CLOptionDescriptor[] options 对象中，这个 option 对象非常重要，因为在 jmeter 真正启动前，会从 option 中获取好几个参数，来决定使用何种启动方式。</p><h2 id="Jmeter-支持的命令行参数"><a href="#Jmeter-支持的命令行参数" class="headerlink" title="Jmeter 支持的命令行参数"></a>Jmeter 支持的命令行参数</h2><table><thead><tr><th>短命令</th><th>长命令</th><th>说明</th></tr></thead><tbody><tr><td><code>-h</code></td><td><code>--help</code></td><td>显示帮助信息。</td></tr><tr><td><code>-v</code></td><td><code>--version</code></td><td>显示 JMeter 版本信息。</td></tr><tr><td><code>-n</code></td><td><code>--nongui</code></td><td>以非 GUI （无界面）模式运行 JMeter。</td></tr><tr><td><code>-t &lt;文件名&gt;</code></td><td><code>--testfile &lt;文件名&gt;</code></td><td>指定要执行的 JMX 测试计划文件。</td></tr><tr><td><code>-l &lt;文件名&gt;</code></td><td><code>--logfile &lt;文件名&gt;</code></td><td>指定测试结果的日志文件名。</td></tr><tr><td><code>-j &lt;文件名&gt;</code></td><td><code>--jmeterlogfile &lt;文件名&gt;</code></td><td>指定 JMeter 的日志文件名。</td></tr><tr><td><code>-r</code></td><td><code>--runremote</code></td><td>以远程方式运行测试计划，用于分布式测试。</td></tr><tr><td><code>-R &lt;远程主机列表&gt;</code></td><td><code>--remotestart &lt;远程主机列表&gt;</code></td><td>通过指定远程主机列表，以分布式方式运行测试计划。</td></tr><tr><td><code>-G &lt;属性文件&gt;</code></td><td><code>--globalproperties &lt;属性文件&gt;</code></td><td>指定全局属性文件。</td></tr><tr><td><code>-D &lt;name&gt;=&lt;value&gt;</code></td><td><code>--systemproperty &lt;name&gt;=&lt;value&gt;</code></td><td>设置额外的系统属性。</td></tr><tr><td><code>-S</code></td><td><code>--systemPropertiesFile &lt;文件名&gt;</code></td><td>指定系统属性文件。</td></tr><tr><td><code>-P &lt;name&gt;=&lt;value&gt;</code></td><td><code>--jmeterproperty &lt;name&gt;=&lt;value&gt;</code></td><td>设置 JMeter 属性值。此处参数是小写</td></tr><tr><td><code>-H &lt;代理主机&gt;</code></td><td><code>--proxyHost &lt;代理主机&gt;</code></td><td>指定代理服务器的主机名。</td></tr><tr><td><code>-P &lt;代理端口&gt;</code></td><td><code>--proxyPort &lt;代理端口&gt;</code></td><td>指定代理服务器的端口号。此处参数是大写</td></tr><tr><td><code>-N &lt;非代理的主机列表&gt;</code></td><td><code>--nonProxyHosts &lt;非代理的主机列表&gt;</code></td><td>指定不需要代理的主机。</td></tr><tr><td><code>-X</code></td><td><code>--remoteexit</code></td><td>告知远程服务器在测试结束后退出。</td></tr><tr><td><code>-H</code></td><td><code>--help-report</code></td><td>显示关于报告生成的帮助信息。</td></tr><tr><td><code>-L</code></td><td><code>--loglevel</code></td><td>指定 JMeter 日志的级别。</td></tr><tr><td><code>-q &lt;属性文件&gt;</code></td><td><code>--addprop &lt;属性文件&gt;</code></td><td>指定要加载的其他 JMeter 属性文件。</td></tr><tr><td><code>-s</code></td><td><code>--server</code></td><td>以服务器模式运行 JMeter 使用 JMeter 远程实例。</td></tr><tr><td><code>-f</code></td><td><code>--forceDeleteResultFile</code></td><td>在运行之前强制删除已存在的测试结果文件。</td></tr><tr><td><code>-i</code></td><td><code>--ignorelineendings</code></td><td>忽略测试计划文件中的行结束标记。</td></tr><tr><td><code>-H</code></td><td><code>--useSystemProxy</code></td><td>使用系统代理设置。</td></tr></tbody></table><p>后面一章正式讲解 Jmeter.start(String[] args) 方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上一篇我们详细了解了 Jmeter 的启动类 NewDriver，知道了 NewDriver 会通过反射调用 Jmeter.start(String[] args)方法来启动 Jmeter，今天我们来分析下，Jmeter这个类内部到底做了什么。本篇章不会直接开始讲 star</summary>
      
    
    
    
    
    <category term="Jmeter源码系列" scheme="https://linvaux.github.io/tags/Jmeter%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Jmeter源码系列(1)-NewDriver类详解-Jmeter 的启动器</title>
    <link href="https://linvaux.github.io/posts/69241c26/"/>
    <id>https://linvaux.github.io/posts/69241c26/</id>
    <published>2023-07-07T15:04:18.000Z</published>
    <updated>2024-09-21T00:59:08.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p><a href="https://jmeter.apache.org/">Jmeter</a> 全称（Apache JMeter）是一个开源的、功能强大的性能测试工具，用于对各种应用程序和协议进行功能、负载、压力和性能测试。它被广泛应用于软件开发和计划阶段，以确保应用程序在各种负载情况下的稳定性和可靠性。<br>本系列将从 Jmeter 代码层面陆续剖析其实现原理，包括但不限于 Jmeter 设计思路，Jmeter 核心对象&#x2F;接口&#x2F;方法。如有错误，敬请指正！</p><h2 id="NewDriver"><a href="#NewDriver" class="headerlink" title="NewDriver"></a>NewDriver</h2><p>NewDriver 是 org.apache.jmeter 包下的一个类，如下是 NewDriver 源码中的类说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Main class for JMeter - sets up initial classpath and the loader.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>从这个说明中，我们可以知道，这个类提供了 2 个主要功能：</p><ul><li>初始化 classpath</li><li>初始化一个 loader, 这个 loader 其实就是一个动态类加载器</li></ul><p>以下内容摘抄自 NewDriver 源码，在源码中会使用注释来说明关键代码的作用，最后也会做总结，让我们开始吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NewDriver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一堆常量，会在 static 代码块中使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CLASSPATH_SEPARATOR</span> <span class="operator">=</span> File.pathSeparator;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">OS_NAME</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">OS_NAME_LC</span> <span class="operator">=</span> OS_NAME.toLowerCase(java.util.Locale.ENGLISH);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JAVA_CLASS_PATH</span> <span class="operator">=</span> <span class="string">&quot;java.class.path&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JMETER_LOGFILE_SYSTEM_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;jmeter.logfile&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HEADLESS_MODE_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;java.awt.headless&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态类加载器，继承自 URLClassLoader，提供了一个静态方法 updateLoader(URL [] urls) 实现了动态加载 jar</span></span><br><span class="line"><span class="comment">     * 的功能。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DynamicClassLoader loader;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String JMETER_INSTALLATION_DIRECTORY;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Exception&gt; EXCEPTIONS_IN_INIT = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;URL&gt; jars = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 启动时从 jvm 获取 classpath</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">initiaClasspath</span> <span class="operator">=</span> System.getProperty(JAVA_CLASS_PATH);</span><br><span class="line">        String tmpDir;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 按照指定标记符来分割给定的字符串，但是 StringTokenizer 是一个遗留类，出于兼容性原因而保留，建议使用 String 的拆分方法或 java.util.regex 包。</span></span><br><span class="line"><span class="comment">         * 顺便说一下，Jmeter 源码中会包含非常多的过时的方法或者写法，有些是因为 Jmeter 本身开发较早，当时的 jdk 版本没有我们常用的新方法，</span></span><br><span class="line"><span class="comment">         * 有些则是因为当时 jdk 早期版本存在 bug，jmeter 会使用另一种写法来规避这些 bug，当然，现在这些 bug 可能已经修复了，不过 jmeter 的源码中</span></span><br><span class="line"><span class="comment">         * 任然会保留这部分注释</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">StringTokenizer</span> <span class="variable">tok</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTokenizer</span>(initiaClasspath, File.pathSeparator);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 对 mac 系统做了单独的判断，我也没有深究为啥要单独处理，不晓得现在还需不需要这么写</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (tok.countTokens() == <span class="number">1</span>|| (tok.countTokens()  == <span class="number">2</span> &amp;&amp; OS_NAME_LC.startsWith(<span class="string">&quot;mac os x&quot;</span>))) &#123;</span><br><span class="line">            <span class="type">File</span> <span class="variable">jar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(tok.nextToken());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                tmpDir = jar.getCanonicalFile().getParentFile().getParent();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                tmpDir = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 从 jvm 获取 jmeter.home 属性，没有的话就默认从环境变量 JMETER_HOME 取值，当然这个值也不一定有，因为不是所有人都会配置 JMETER_HOME 这个环境变量</span></span><br><span class="line"><span class="comment">             * 其实从这边开始，大家就会发现，Jmeter 会经常使用 System.getProperty 来获取一些属性，在后面的代码中我们也会经常见到这样的代码</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            tmpDir = System.getProperty(<span class="string">&quot;jmeter.home&quot;</span>, System.getenv(<span class="string">&quot;JMETER_HOME&quot;</span>));</span><br><span class="line">            <span class="keyword">if</span> (tmpDir == <span class="literal">null</span> || tmpDir.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">File</span> <span class="variable">userDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(System.getProperty(<span class="string">&quot;user.dir&quot;</span>));</span><br><span class="line">                tmpDir = userDir.getAbsoluteFile().getParent();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmpDir == <span class="literal">null</span>) &#123;</span><br><span class="line">            tmpDir = System.getenv(<span class="string">&quot;JMETER_HOME&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        JMETER_INSTALLATION_DIRECTORY = tmpDir;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">usesUNC</span> <span class="operator">=</span> OS_NAME_LC.startsWith(<span class="string">&quot;windows&quot;</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">classpath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 下面的几个目录大家就很眼熟了，就是 Jmeter 解压后，主目录下的文件夹，里面都是 Jmeter 可能用到的一些 jar 包</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        File[] libDirs = <span class="keyword">new</span> <span class="title class_">File</span>[] &#123; <span class="keyword">new</span> <span class="title class_">File</span>(JMETER_INSTALLATION_DIRECTORY + File.separator + <span class="string">&quot;lib&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">File</span>(JMETER_INSTALLATION_DIRECTORY + File.separator + <span class="string">&quot;lib&quot;</span> + File.separator + <span class="string">&quot;ext&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">File</span>(JMETER_INSTALLATION_DIRECTORY + File.separator + <span class="string">&quot;lib&quot;</span> + File.separator + <span class="string">&quot;junit&quot;</span>)&#125;;</span><br><span class="line">        <span class="keyword">for</span> (File libDir : libDirs) &#123;</span><br><span class="line">            File[] libJars = libDir.listFiles((dir, name) -&gt; name.endsWith(<span class="string">&quot;.jar&quot;</span>));</span><br><span class="line">            <span class="keyword">if</span> (libJars == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Throwable</span>(<span class="string">&quot;Could not access &quot;</span> + libDir).printStackTrace();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 不晓得为啥要排个序</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Arrays.sort(libJars);</span><br><span class="line">            <span class="keyword">for</span> (File libJar : libJars) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> libJar.getPath();</span><br><span class="line">                    <span class="keyword">if</span> (usesUNC) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (s.startsWith(<span class="string">&quot;\\\\&quot;</span>) &amp;&amp; !s.startsWith(<span class="string">&quot;\\\\\\&quot;</span>)) &#123;</span><br><span class="line">                            s = <span class="string">&quot;\\\\&quot;</span> + s;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.startsWith(<span class="string">&quot;//&quot;</span>) &amp;&amp; !s.startsWith(<span class="string">&quot;///&quot;</span>)) &#123;</span><br><span class="line">                            s = <span class="string">&quot;//&quot;</span> + s;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    jars.add(<span class="keyword">new</span> <span class="title class_">File</span>(s).toURI().toURL());</span><br><span class="line">                    classpath.append(CLASSPATH_SEPARATOR);</span><br><span class="line">                    classpath.append(s);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">                    EXCEPTIONS_IN_INIT.add(<span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;Error adding jar:&quot;</span>+libJar.getAbsolutePath(), e));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.setProperty(JAVA_CLASS_PATH, initiaClasspath + classpath.toString());</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 类加载器会加载扫描到的这些 jar 包，为 Jmeter 真正启动做好准备</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        loader = AccessController.doPrivileged(</span><br><span class="line">                (PrivilegedAction&lt;DynamicClassLoader&gt;) () -&gt;</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">DynamicClassLoader</span>(jars.toArray(<span class="keyword">new</span> <span class="title class_">URL</span>[jars.size()]))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中，我们可以看到，NewDriver 在实例化时，会执行一个静态代码块，主要作用就是加载 Jmeter 安装目录下的 jar 包。</p><h2 id="Main方法介绍"><a href="#Main方法介绍" class="headerlink" title="Main方法介绍"></a>Main方法介绍</h2><p>下面介绍 NewDriver 的 main 方法，这个方法就是整个 Jmeter 启动的入口方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检查初始化是不是报错了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(!EXCEPTIONS_IN_INIT.isEmpty()) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Configuration error during init, see exceptions:&quot;</span>+exceptionsToString(EXCEPTIONS_IN_INIT));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 设置当前线程的类加载器，也就是 Jmeter 自己写的那个动态类加载器</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Thread.currentThread().setContextClassLoader(loader);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 配置一些日志属性，不重要</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            setLoggingProperties(args);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 判断要不要用 GUI 模式启动，默认 true，也可以通过 Jmeter 命令行参数 -n 来指定使用非 GUI 模式启动</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span>(System.getProperty(HEADLESS_MODE_PROPERTY) == <span class="literal">null</span> &amp;&amp; shouldBeHeadless(args)) &#123;</span><br><span class="line">                    System.setProperty(HEADLESS_MODE_PROPERTY, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 获取 Jmeter 类，作用类似于 Class.forName(String clazzName)</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                Class&lt;?&gt; initialClass = loader.loadClass(<span class="string">&quot;org.apache.jmeter.JMeter&quot;</span>);</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 获取 Jmeter 实例</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> initialClass.getDeclaredConstructor().newInstance();</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 获取 Jmeter.start方法，并调用</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="type">Method</span> <span class="variable">startup</span> <span class="operator">=</span> initialClass.getMethod(<span class="string">&quot;start&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>].getClass() &#125;);</span><br><span class="line">                startup.invoke(instance, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; args &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(Throwable e)&#123; </span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                System.err.println(<span class="string">&quot;JMeter home directory was detected as: &quot;</span>+JMETER_INSTALLATION_DIRECTORY);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>main 方法其实很简单直接，就是看下是不是要启动 GUI，然后就是通过反射调用 Jmeter 的 start 方法，来开始测试。<br>综上，NewDriver 其实就是一个启动器，正如其所在源码模块 launcher 一样，他的作用就是为 Jmeter 真正启动做好准备。<br>好了，NewDriver 就介绍完了，下一章将介绍 Jmeter 这个核心类，以及调用其 start(String[] args) 之后会发生什么…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://jmeter.apache.org/&quot;&gt;Jmeter&lt;/a&gt; 全称（Apa</summary>
      
    
    
    
    
    <category term="Jmeter源码系列" scheme="https://linvaux.github.io/tags/Jmeter%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Jdk11获取系统信息</title>
    <link href="https://linvaux.github.io/posts/caf2f46/"/>
    <id>https://linvaux.github.io/posts/caf2f46/</id>
    <published>2023-06-08T14:01:20.000Z</published>
    <updated>2024-09-21T00:59:08.931Z</updated>
    
    <content type="html"><![CDATA[<p>下面用到的 api 仅在 jdk11 上测试通过，其他 jdk 版本没试过</p><h2 id="工具类-SystemInfoUtils-java"><a href="#工具类-SystemInfoUtils-java" class="headerlink" title="工具类 SystemInfoUtils.java"></a>工具类 SystemInfoUtils.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.demo.constant.SystemInfoConstant;</span><br><span class="line"><span class="keyword">import</span> com.sun.management.OperatingSystemMXBean;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.management.ManagementFactory;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.NetworkInterface;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 系统信息工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemInfoUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取本地IP地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 本机 ip，过滤了回环地址和 localhost</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getLocalIP</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; ipList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取本地所有网络接口</span></span><br><span class="line">            Enumeration&lt;NetworkInterface&gt; networkInterfaces = NetworkInterface.getNetworkInterfaces();</span><br><span class="line">            <span class="keyword">while</span> (networkInterfaces.hasMoreElements()) &#123;</span><br><span class="line">                <span class="type">NetworkInterface</span> <span class="variable">networkInterface</span> <span class="operator">=</span> networkInterfaces.nextElement();</span><br><span class="line">                <span class="comment">// 排除虚拟接口和未启用的接口</span></span><br><span class="line">                <span class="keyword">if</span> (networkInterface.isVirtual() || !networkInterface.isUp()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Enumeration&lt;InetAddress&gt; inetAddresses = networkInterface.getInetAddresses();</span><br><span class="line">                <span class="keyword">while</span> (inetAddresses.hasMoreElements()) &#123;</span><br><span class="line">                    <span class="type">InetAddress</span> <span class="variable">inetAddress</span> <span class="operator">=</span> inetAddresses.nextElement();</span><br><span class="line">                    <span class="keyword">if</span> (!inetAddress.isLinkLocalAddress()) &#123;</span><br><span class="line">                        ipList.add(inetAddress.getHostAddress());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;本机 IP 获取失败, 异常详情: &quot;</span> + ExceptionUtil.getErrorMessage(e));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ipList.stream().filter(e -&gt; !SystemInfoConstant.INVALID_IP_LIST.contains(e)).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取CPU数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 逻辑处理器数量，物理核数 * 2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getCpuCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 此处有坑，OperatingSystemMXBean 存在于两个包：java.lang.management.OperatingSystemMXBean 和 com.sun.management.OperatingSystemMXBean</span></span><br><span class="line">        <span class="comment">// 一定要找对包，不然有些方法找不到，太特么坑了</span></span><br><span class="line">        java.lang.management.<span class="type">OperatingSystemMXBean</span> <span class="variable">operatingSystemMXBean</span> <span class="operator">=</span> ManagementFactory.getOperatingSystemMXBean();</span><br><span class="line">        <span class="keyword">return</span> operatingSystemMXBean.getAvailableProcessors();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取总内存大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 物理内存大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getTotalPhysicalMemory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">OperatingSystemMXBean</span> <span class="variable">osBean</span> <span class="operator">=</span> ManagementFactory.getPlatformMXBean(OperatingSystemMXBean.class);</span><br><span class="line">        <span class="type">long</span> <span class="variable">physicalMemorySize</span> <span class="operator">=</span> osBean.getTotalPhysicalMemorySize();</span><br><span class="line">        <span class="type">double</span> <span class="variable">physicalMemoryGB</span> <span class="operator">=</span> (<span class="type">double</span>) physicalMemorySize / <span class="number">1024</span> / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="type">DecimalFormat</span> <span class="variable">decimalFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#.##&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> decimalFormat.format(physicalMemoryGB) + <span class="string">&quot;GB&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取磁盘总大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 磁盘总量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getDiskSizeTotal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">diskSize</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Path</span> <span class="variable">rootDir</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">            <span class="type">FileStore</span> <span class="variable">store</span> <span class="operator">=</span> Files.getFileStore(rootDir);</span><br><span class="line">            <span class="type">long</span> <span class="variable">totalSpace</span> <span class="operator">=</span> store.getTotalSpace();</span><br><span class="line">            <span class="type">double</span> <span class="variable">totalGB</span> <span class="operator">=</span> (<span class="type">double</span>) totalSpace / <span class="number">1024</span> / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">            <span class="type">DecimalFormat</span> <span class="variable">decimalFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#.##&quot;</span>);</span><br><span class="line">            diskSize = decimalFormat.format(totalGB + <span class="string">&quot;GB&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;磁盘信息获取失败, 异常详情: &#123;&#125;&quot;</span>, ExceptionUtil.getErrorMessage(e));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> diskSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取已使用磁盘大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 磁盘已使用量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getDiskSizeUsed</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">diskSize</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Path</span> <span class="variable">rootDir</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">            <span class="type">FileStore</span> <span class="variable">store</span> <span class="operator">=</span> Files.getFileStore(rootDir);</span><br><span class="line">            <span class="type">long</span> <span class="variable">usableSpace</span> <span class="operator">=</span> store.getUsableSpace();</span><br><span class="line">            <span class="type">double</span> <span class="variable">usableGB</span> <span class="operator">=</span> (<span class="type">double</span>) usableSpace / <span class="number">1024</span> / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">            <span class="type">DecimalFormat</span> <span class="variable">decimalFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#.##&quot;</span>);</span><br><span class="line">            diskSize = decimalFormat.format(usableGB + <span class="string">&quot;GB&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;磁盘信息获取失败, 异常详情: &#123;&#125;&quot;</span>, ExceptionUtil.getErrorMessage(e));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> diskSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取可用磁盘大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 磁盘可使用量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getDiskSizeFree</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">diskSize</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Path</span> <span class="variable">rootDir</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">            <span class="type">FileStore</span> <span class="variable">store</span> <span class="operator">=</span> Files.getFileStore(rootDir);</span><br><span class="line">            <span class="type">long</span> <span class="variable">freeSpace</span> <span class="operator">=</span> store.getUnallocatedSpace();</span><br><span class="line">            <span class="type">double</span> <span class="variable">freeGB</span> <span class="operator">=</span> (<span class="type">double</span>) freeSpace / <span class="number">1024</span> / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">            <span class="type">DecimalFormat</span> <span class="variable">decimalFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#.##&quot;</span>);</span><br><span class="line">            diskSize = decimalFormat.format(freeGB + <span class="string">&quot;GB&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;磁盘信息获取失败, 异常详情: &#123;&#125;&quot;</span>, ExceptionUtil.getErrorMessage(e));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> diskSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="常量类-SystemInfoConstant-java"><a href="#常量类-SystemInfoConstant-java" class="headerlink" title="常量类 SystemInfoConstant.java"></a>常量类 SystemInfoConstant.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 系统信息常量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemInfoConstant</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ipv4 回环地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">IPV4_LOOP_ADDRESS</span> <span class="operator">=</span> <span class="string">&quot;0.0.1.1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ipv6 回环地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">IPV6_LOOP_ADDRESS</span> <span class="operator">=</span> <span class="string">&quot;0:0:0:0:0:0:0:1%lo0&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 本机 IP</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCAL_HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无效的 ip 地址列表，需要排除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; INVALID_IP_LIST = List.of(IPV4_LOOP_ADDRESS, IPV6_LOOP_ADDRESS, LOCAL_HOST);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="异常信息获取工具类-ExceptionUtil-java"><a href="#异常信息获取工具类-ExceptionUtil-java" class="headerlink" title="异常信息获取工具类 ExceptionUtil.java"></a>异常信息获取工具类 ExceptionUtil.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.StringWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 异常工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionUtil</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常信息允许的最大长度，超过这个长度会被截取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">ERROR_MSG_MAX_LENGTH</span> <span class="operator">=</span> <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取异常的堆栈信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 异常对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 堆栈信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getErrorMessage</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(e.getMessage())) &#123;</span><br><span class="line">            <span class="keyword">return</span> e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringWriter</span> <span class="variable">sw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line">        e.printStackTrace(<span class="keyword">new</span> <span class="title class_">PrintWriter</span>(sw, Boolean.TRUE));</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> sw.toString();</span><br><span class="line">        <span class="keyword">return</span> message.length() &gt; ERROR_MSG_MAX_LENGTH ? message.substring(<span class="number">0</span>, ERROR_MSG_MAX_LENGTH) : message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面用到的 api 仅在 jdk11 上测试通过，其他 jdk 版本没试过&lt;/p&gt;
&lt;h2 id=&quot;工具类-SystemInfoUtils-java&quot;&gt;&lt;a href=&quot;#工具类-SystemInfoUtils-java&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="Java" scheme="https://linvaux.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
